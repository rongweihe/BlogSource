<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.5.11" created="2017-11-01 01:24" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>加贝木苇的理想国</title>
	<link>http://acmerbar.com</link>
	<description>Work Hard,Work Regulary</description>
	<pubDate>Wed, 01 Nov 2017 01:24:02 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://acmerbar.com</wp:base_site_url>
	<wp:base_blog_url>http://acmerbar.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[jiabei]]></wp:author_login><wp:author_email><![CDATA[1952281585@qq.com]]></wp:author_email><wp:author_display_name><![CDATA[jiabei]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>https://wordpress.org/?v=4.5.11</generator>

	<item>
		<title>Hello world!</title>
		<link>http://acmerbar.com/1.html</link>
		<pubDate>Fri, 06 Nov 2015 02:25:05 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[Welcome to WordPress. This is your first post. Edit or delete it, then start writing!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2015-11-06 02:25:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-06 02:25:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>1</wp:comment_id>
			<wp:comment_author><![CDATA[Mr WordPress]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>https://wordpress.org/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-06 02:25:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-06 02:25:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi, this is a comment.
To delete a comment, just log in and view the post&#039;s comments. There you will have the option to edit or delete them.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[He]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1722896854@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[219.154.152.39]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-06 14:15:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-06 14:15:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You are good!]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1449462096.12833404541015625;s:5:"event";s:15:"status-approved";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>hello world !</title>
		<link>http://acmerbar.com/4.html</link>
		<pubDate>Fri, 06 Nov 2015 13:31:28 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=4</guid>
		<description></description>
		<content:encoded><![CDATA[hello world !,

这是我的第一篇博客，NICE！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>4</wp:post_id>
		<wp:post_date><![CDATA[2015-11-06 13:31:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-06 13:31:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>About me</title>
		<link>http://acmerbar.com/8.html</link>
		<pubDate>Sat, 07 Nov 2015 07:55:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=8</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

#define G 个人简介
#define L 联系方式
#define X 兴趣爱好

int main()
{
char read;
while(cin&gt;&gt;read)
{
if(read=='G') printf("NYIST计科13级 ACMer,thinkinger,欢迎一起学习交流~~\n");
else if(read=='L') {
printf("QQ@：1952281585@qq.com\n");
printf("moblie phone：150 8332 7950\n");
printf("Blog : www.acmerbar.com\n");

printf("Weibo :weibo.com/u/3854793919");

printf("CSDN: blog.csdn.net/u013050857");
}
else {
printf("Reading ~~~\n");
printf("Runing ~~~\n");
printf("Thinking ~~~\n");
printf("Working ~~~\n");
printf("Eating ~~~\n");
printf("Sleeping ~~~\n");
printf("Making freind ~~~\n");
}
}
return 0;
}
上大学之前不知道怎么搭建个人网站，如今总算是有了自己的博客了，搭建这个博客主要是用来
记录大学生涯，和一些读书，学习的事情，总觉得一些东西记录下来总是好的。
一开始也不知道能用多久，于是就先续费一年吧，第一篇文章会把搭建这个网站中间出现的各种问题，
总结一下，希望有人看到了也能提供一点点的帮助~~也会陆续把原先的博客比较重要的文章搬过来。

Created By 加贝木苇 15:53 2015/11/7 星期六

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>8</wp:post_id>
		<wp:post_date><![CDATA[2015-11-07 15:55:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-07 07:55:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[about-me]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="about-me"><![CDATA[about me]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[37]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>如何搭建一个自有域名的 WordPress 博客？</title>
		<link>http://acmerbar.com/9.html</link>
		<pubDate>Sat, 07 Nov 2015 08:49:01 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=9</guid>
		<description></description>
		<content:encoded><![CDATA[首先推荐知乎：<a href="http://www.zhihu.com/question/19594033" target="_blank">如何搭建一个自有域名的 WordPress 博客？</a>

里面讲的很详细了，

【1】一般而言，博客搭建大致以下几个流程

博客搭建并不复杂，只是过程有点繁琐
<ol>
	<li>购买域名(Domain Name)</li>
	<li>注册一个主机空间(Web Host)</li>
	<li>域名解析(DNSPod)</li>
	<li>安装WordPress</li>
	<li>安装WordPress主题</li>
	<li>自己折腾wordpress的其他设置</li>
</ol>
<strong>购买域名</strong>，可以选择国内，国外，国内的有万网，新网等等其他的，国外的有一个牛逼的顶级域名服务提供商-<a href="https://www.godaddy.com" target="_blank">godaddy</a> 说实话，以前还不知道，上去注册购买了一番，为什么要选择它呢，据说购买商品的时候会时不时的提高优惠码打折活动，卖完大概算下来，一年差不多80多RMB，因为这个网站是全英文的，购买商品会有些地方不懂的，下面提供一个帮助：

<a href="http://jingyan.baidu.com/article/7f41ecec1ad229593c095c4e.html" target="_blank">godaddy注册使用流程</a>

然后就要购买主机了或者服务器了，主机和云服务器有什么区别？

一般而言，
<pre id="best-content-1667065941" class="best-text mb-10">主机和服务器是相对而言的。 专业的服务器的配置是很高的，不过本身从硬件上来说还是电脑主机，当用作网络服务时就叫服务器了。</pre>
<pre id="best-content-1575758344" class="best-text mb-10">云服务器也可以称为云主机.它是在一组集群服务器上划分出来的多个类似独立主机的部分.集群中的每台服务器都会有云主机的一个镜像.当其中一台机器出现硬件故障时.系统会自动访问其他机器上的镜像备份.从而提高了云主机的稳定与安全.它其实就是一台虚拟服务器.拥有与服务器一模一样的功能与使用方法.有独立的IP和带宽.用户可以根据需要安装各种操作系统以及配置各种网站运行环境.
虚拟主机又叫空间.它只是在服务器硬盘上划分出来的一小部分容量.共享的是服务器的带宽以及IP.没有独立的操作系统.用户也无法根据需要自由配置环境.它所支持的程序也是在服务器上默认已经分配好的.功能非常有限.
所以无论是从性能还是安全方面来对比.云主机都远远强于虚拟主机</pre>
服务器的作用范围比主机更广泛，

<strong>购买主机</strong>

其实之前在HDU界面上看到了阿里云服务器学生优惠的活动， 果断买了一个月的云服务器玩玩，然后搭建了HUST-OJ测试，之后又在注册一个域名，然后提示说还要备案审核，照片提交了好几次都没有审核过，最后也不知道提交了几次，然后邮件发过来说是通过了，不过现在都没管了，同学又推荐了老薛主机，上网站看了看感觉还不错，付款的时候加了一个优惠码，80%折扣，买了一个美国虚拟主机，300M存储，不知道够不够用，反正觉得如果光写文章应该问题不大的，

<strong>域名和主机绑定</strong>

然后域名，主机都ok了，接下来要上dnspod 网站给你的域名来一次解析，就是域名绑定你的主机

这里为什么要给域名 解析，dns又是什么，学过计算机网络的应该不陌生，不懂的可以上网查找资料，这里就不在详细解释了。

解析流程可以参考这篇文章：

<a href="http://wenku.baidu.com/view/5e7972c37f1922791688e879.html" target="_blank">Godaddy绑定域名DNSpod解析教程</a>

关键点：

（1）

登录goDaddy网站，点击“My Account” ，点击“Domain”右侧的“Launch”，进入域名管理页面，在“NameServers”一栏点击“Set NameServers”，在弹出的对话框中前两个Name Server处分别填写DNSPod的域名服务“F1G1NS1.DNSPOD.NET”、“F1G1NS2.DNSPOD.NET”。
(2)将域名指向主机服务器的ip，即在DNSPod中添加“A记录”，注意要添加带“www”的和不带“www”两个记录，也就是在www 和 @ 的选项里把主机ip加进去，添加完后见下图：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/2a841332104e13aba4fc92dff5e0ba23_b1.png"><img class="alignleft size-medium wp-image-12" src="http://acmerbar.com/wp-content/uploads/2015/11/2a841332104e13aba4fc92dff5e0ba23_b1-300x196.png" alt="" width="300" height="196" /></a>

然后等待解析一般时间在0~72小时左右就可以访问你的网站了

<strong>安装wordpress</strong>

老薛主机后台管理是cPanel ,支持一键安装wordpress，

<a href="http://help.wopus.org/cpanel/cp-advanced/230.html" target="_blank">cPanel 一键安装wordpress</a>

然后大概就是这样，出现问题可以百度查找相关信息，或者提出问题和博主交流。安装如上流程，搭建一个博客也就不是很难了。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>9</wp:post_id>
		<wp:post_date><![CDATA[2015-11-07 16:49:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-07 08:49:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a6%82%e4%bd%95%e6%90%ad%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%87%aa%e6%9c%89%e5%9f%9f%e5%90%8d%e7%9a%84-wordpress-%e5%8d%9a%e5%ae%a2%ef%bc%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HUST-OJ搭建ACM在线评测系统</title>
		<link>http://acmerbar.com/13.html</link>
		<pubDate>Sat, 07 Nov 2015 09:35:11 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=13</guid>
		<description></description>
		<content:encoded><![CDATA[大约两周前完成的，期间遇到好多问题，学习到了一些知识，写个总结：

参考资料：

<a href="http://download.csdn.net/detail/u013050857/9250577" target="_blank">HUST-OJ搭建ACM在线评测系统</a>.pdf

安装pdf的流程一步步进行，应该是没有问题的（前提是你得先有一个服务器ip）

遇到一些问题：

【1】 阅读配置文件，弄清各设置含义

参考<a href="http://code.google.com/p/hustoj/wiki/Configuration">http://code.google.com/p/hustoj/wiki/Configuration</a>

源码<a href="http://code.google.com/p/hustoj/source/browse/trunk/core/judge_client/judge_client.cc">http://code.google.com/p/hustoj/source/browse/trunk/core/judge_client/judge_client.cc</a>

【2】修改文件的时候，注意vim编辑器下保存命令 :wq

#vim /home/judge/etc/judge.conf
<div class="line number1 index0 alt2"><code class="cpp plain">注意和上面的配置文件一样 参考修改</code></div>
<div class="line number2 index1 alt1"><code class="cpp plain">OJ_HOST_NAME=127.0.0.1 如果用mysql连接读取数据库，数据库的主机地址 // 不能修改！！！</code></div>
<div class="line number3 index2 alt2"><code class="cpp plain">OJ_USER_NAME=root 数据库帐号</code></div>
<div class="line number4 index3 alt1"><code class="cpp plain">OJ_PASSWORD=root 数据库密码</code></div>
<div class="line number5 index4 alt2"><code class="cpp plain">OJ_DB_NAME=jol 数据库名称</code></div>
<div class="line number6 index5 alt1"><code class="cpp plain">OJ_PORT_NUMBER=3306 数据库端口</code></div>
<div class="line number7 index6 alt2"><code class="cpp plain">OJ_RUNNING=4 judged会启动judge_client判题，这里规定最多同时运行几个judge_client</code></div>
<div class="line number8 index7 alt1"><code class="cpp plain">OJ_SLEEP_TIME=5 judged通过轮询数据库发现新任务，轮询间隔的休息时间，单位秒</code></div>
<div class="line number9 index8 alt2"><code class="cpp plain">OJ_TOTAL=1 老式并发处理中总的judged数量</code></div>
<div class="line number10 index9 alt1"><code class="cpp plain">OJ_MOD=0 老式并发处理中，本judged负责处理solution_id按照TOTAL取模后余数为几的任务。</code></div>
<div class="line number11 index10 alt2"><code class="cpp plain">OJ_JAVA_TIME_BONUS=2 Java等虚拟机语言获得的额外运行时间。</code></div>
<div class="line number12 index11 alt1"><code class="cpp plain">OJ_JAVA_MEMORY_BONUS=512 Java等虚拟机语言获得的额外内存。</code></div>
<div class="line number13 index12 alt2"><code class="cpp plain">OJ_SIM_ENABLE=0 是否使用sim进行代码相似度的检测</code></div>
<div class="line number14 index13 alt1"><code class="cpp plain">OJ_HTTP_JUDGE=0 是否使用HTTP方式连接数据库，如果启用，则前面的HOST_NAME等设置忽略。</code></div>
<div class="line number15 index14 alt2"><code class="cpp plain">OJ_HTTP_BASEURL=http:</code><code class="cpp comments">//127.0.0.1/JudgeOnline 使用HTTP方式连接数据库的基础地址，就是OJ的首页地址。</code></div>
<div class="line number16 index15 alt1"><code class="cpp plain">OJ_HTTP_USERNAME=admin 使用HTTP方式所用的用户帐号（HTTP_JUDGE权限），该帐号登录时不能启用VCODE图形验证码，但可以登录成功后启用。</code></div>
<div class="line number17 index16 alt2"><code class="cpp plain">OJ_HTTP_PASSWORD=admin 密码</code></div>
<div class="line number18 index17 alt1"><code class="cpp plain">OJ_OI_MODE=0 是否启用OI模式，即无论是否出错都继续判剩余的数据，在ACM比赛中一旦出错就停止运行。</code></div>
<div class="line number19 index18 alt2"><code class="cpp plain">OJ_SHM_RUN=0 是否使用/dev/shm的共享内存虚拟磁盘来运行答案，如果启用能提高判题速度，但需要较多内存。</code></div>
<div class="line number20 index19 alt1"><code class="cpp plain">OJ_USE_MAX_TIME=1 是否使用所有测试数据中最大的运行时间作为最后运行时间，如果不启用则以所有测试数据的总时间作为超时判断依据。</code></div>
【3】之前sb了
把OJ_HOST_NAME改成我的主机地址了，实际上是不能改的（mysql默认不准外部连接，只能用本地回环或unix socket连接
）
修改完之后重启，把之前的题目进行重判

【4】关于java代码报RE的问题，目前博主苦求解决办法中~~

……T_T……

推荐几篇参考文章：

<a href="http://www.z4zr.com/page/666.html" target="_blank">cenos 搭建HUSTOJ</a>

<a href="http://oss.aliyuncs.com/aliyun_portal_storage/help/ecs/ECS云服务器用户操作帮助指南.pdf?spm=5176.2020520130.105.28.jdFNUH&amp;file=ECS云服务器用户操作帮助指南.pdf&amp;crazycache=1" target="_blank">ESC云服务器操作指南</a>

有问题的欢迎和博主交流~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date><![CDATA[2015-11-07 17:35:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-07 09:35:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hust-oj%e6%90%ad%e5%bb%baacm%e5%9c%a8%e7%ba%bf%e8%af%84%e6%b5%8b%e7%b3%bb%e7%bb%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[254]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[87]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[binggo]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[binggo@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[120.194.101.90]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-07 21:33:07]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-07 13:33:07]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[点赞！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1446903187.5425140857696533203125;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1449462094.9045069217681884765625;s:5:"event";s:15:"status-approved";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>【Linux学习笔记】之字符界面操作</title>
		<link>http://acmerbar.com/21.html</link>
		<pubDate>Sun, 08 Nov 2015 03:04:51 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=21</guid>
		<description></description>
		<content:encoded><![CDATA[Linux 系统主要由以下3个重要的部分组成：
<ul>
	<li>内核（kernel）。</li>
	<li>Shell。</li>
	<li>应用程序。</li>
</ul>
目前主流shell有 sh,csh,ksh,tcsh,bash..

在linux 系统中，bash具有以下功能：
<ul>
	<li>兼容Bourne Shell;</li>
	<li>包含C Shell 以及 Korn Shell的最佳功能；</li>
	<li>具有命令列编写修改的能力</li>
	<li>具有工作控制的能力，可以控制前台和后台程序；</li>
	<li>具有Shell编程能力。</li>
</ul>
常用命令

<strong>【1</strong><strong>】</strong>关闭和重启系统

1.1在 linux 下常用的命令有：shutdown,halt,reboot,init.

1.1.1  # shutdown –h now //立即关闭系统

# shutdown –h 45  //45分钟后关闭系统

1.1.2  # halt           //立即关闭系统

1.1.3  #reboot         //重启系统

1.1.4  init命令：是所有进程的祖先，它的进程号始终为1，所以发送“TERM”信号给init

会终止所有的用户进程和守护进程，init定义了7个级别，init0 表示关闭系统，init1表示重启。

<strong>【2</strong>】获取帮助

2.1 使用man手册：# ls man    //显示ls命令的man手册

2.2 使用help 手册：# mkdir –help //查看mkdir命令帮助

2.3 whereis 命令：查找命令所在的位置

【3】命令的排列，替换和别名

3.1 “；”# ls –l /boot ;du –hs /root //同时执行两个命令

3.2 “&amp;&amp;”# ls –l /boot &amp;&amp;du –hs /root//当前一个命令执行正确后才执行后一个命令

3.5 “命令1 $(命令2)” # kill -9 $ (pidof yes) //杀死 yes命令进程

3.6 “命令别名” # alians ok = “ls –l”

#ok 等于 # ls –l

取消别名 unalias [别名]

【4】文件名匹配和输出重定向

4.1 # rm *.bak //rm命令删除当前目录下所有文件以字符串.bak结尾的文件，使用通配符”*” 可以匹配一个或多个字符，在这里，告诉shell将命令rm的参数扩展到所有以”*.bak”结尾的文件，shell就将扩展后的参数告诉rm命令，shell在执行命令前，将读取并解释命令行。

4.2 # ls *.???? //在匹配时，一个问号只能代表一个字符，如上例，假设在增加两个新文件：311.bak,和 some.bak，现在，列出所有点号后面只有4个字符的文件，可使用该命令。

4.3 管道命令

4.3.1 #ls /etc|more  // 显示目录 /etc的内容 ，并且分页显示内容。

4.3.2 # rpm –qa |grep a|more // 显示已经按照在系统上的RPM包，命令grep a 过滤软件包，并且分页显示内容。

4.4 输出重定向

4.4.1 #ls /boot &gt; /root/abc //使用输出重定向将/boot的内容保存到文件 /root/abc

# cat /root/abc

4.4.2#echo hihi &gt; /root/abc //使用echo命令和输出重定向创建文本文件 /root/abc ,内容是hihi

4.5 输入重定向

4.5.1 #命令语法： command &lt; file

# cat &lt; /root/abc      // 将文件/root/abc的内容作为输入让cat命令执行。

hihi

# 追加重定向

root@jiabei-VirtualBox ~# echo aaa &gt; /root/mm
root@jiabei-VirtualBox ~# echo bbb &gt; /root/mm
root@jiabei-VirtualBox ~# echo /root/mm
/root/mm
root@jiabei-VirtualBox ~# cat /root/mm
bbb
root@jiabei-VirtualBox ~# echo aaa &gt;&gt; /root/mm
root@jiabei-VirtualBox ~# cat /root/mm
bbb
aaa
root@jiabei-VirtualBox ~#

&nbsp;

总结：

Man命令是一种显示Unix、Linux在线手册的命令，可以用来查看命令，函数或文件的帮助手册，使用help 命令可以查找shell命令的用法，只需在查找的命令后面输入help就可以了，

在Linux系统中，shell是最常使用的命令，其主要作用是侦听用户命令，启动指令所指定的进程并将结果返回给用户，一个shell命令可能含有多个参数和可选项，

Linux系统是在命令行下诞生的，所以命令行有许多非常实用的功能：

命令行自动补全，

命令历史记录

命令的排列

命令替换

命令别名

文件名匹配

管道

重定向文件

Vim编辑器是Linux系统的标准编辑器，常用3中基本工作模式：

命令模式，插入模式，末行模式

<a href="http://acmerbar.com/wp-content/uploads/2015/11/52c18a4a9bc47.jpg"><img class="aligncenter size-full wp-image-22" src="http://acmerbar.com/wp-content/uploads/2015/11/52c18a4a9bc47.jpg" alt="" width="500" height="256" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date><![CDATA[2015-11-08 11:04:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-08 03:04:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%90linux%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e3%80%91%e4%b9%8b%e5%ad%97%e7%ac%a6%e7%95%8c%e9%9d%a2%e6%93%8d%e4%bd%9c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[%e3%80%90linux%e5%91%bd%e4%bb%a4%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e3%80%91%e4%b9%8b%e5%ad%97%e7%ac%a6%e7%95%8c%e9%9d%a2%e6%93%8d%e4%bd%9c]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>【Linux学习笔记】之文件和目录</title>
		<link>http://acmerbar.com/23.html</link>
		<pubDate>Sun, 08 Nov 2015 03:59:20 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=23</guid>
		<description></description>
		<content:encoded><![CDATA[【5】Linux 的文件扩展名

5.1 压缩的和归档的文件

.bz2  //使用bzip2压缩的文件

.gz   //使用gzip压缩的文件

.tar  //使用tar压缩的文件

.tbz  //使用tar,bzip压缩的文件

.tgz  //使用tar,gzip压缩的文件

.zip  //使用zip压缩的文件

5.2 文件格式

.au   //音频文件

.gif   //GIF图像

.html/.htm //HTML 文件

.jpg  // 图片

.pdf  //pdf

.png  // 图片

.ps   // PostScript 文件

.txt   // 纯文本

.wav   //音频文件

.XPm // 图像文件

5.3系统配置文件

.conf   // 系统配置文件

.lock     //锁文件，判断程序或者设备是否正在使用

.rpm   //软件包管理文件

5.4 编程和脚本文件

.c    //C程序源码文件

.cpp   //C++源码文件

.h    //头文件

.o    //对象文件

.pl    //Perl脚本

.py   //python 脚本

.so   //库文件

.sh   //shell脚本

.tcl   //TCL脚本

#   File it   // 查看it文件的属性

【6】Linux 文件类型有以下几种：

普通文件，目录文件，字符设备文件，快设备文件，符号链接文件。
<ul>
	<li>普通文件 ：# ls –lh install.log</li>
</ul>
-rw-r—r— 1 root 10k 11-08 11:09 install.log

“ls -lh”  命令查看某个文件的属性，第一个是- 表示普通文件
<ul>
	<li>目录文件 ：# ls –lh</li>
</ul>
drwxr-xr-x 2 root root 4.0k 11-08 11:10 bbb

….

属性第一个是d的表示目录文件。
<ul>
	<li>设备文件 # ls –l /dev|grep sd</li>
</ul>
/dev/hda1 /dev/sda1  等等都是设备文件

“brw-rw---” //快设备文件

“crw-rw---” //字符设备文件
<ul>
	<li>管道文件，有时候也叫做FIFO文件（先进先出文件）</li>
</ul>
# ls –l  /dev/initctl

Prw------ 1 root root 0 Dec 5 02:00 /dev/initctl

第一个字母是 “p”
<ul>
	<li>链接文件</li>
</ul>
类似于Windows的快捷方式，分为硬链接和软链接两种。

# ls –l

Lrwxrwxrwx 1 root root 4 11-08 11:20 1.txt

第一个字母是“l”的文件

硬链接和软链接的区别：

&nbsp;

为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名（见 <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/#fig2">图 2.</a>hard link 就是 file 的一个别名，他们有共同的 inode）。硬链接可由命令 link 或 ln 创建。如下是对文件 oldfile 创建硬链接。

link oldfile newfile

ln oldfile newfile

由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：

文件有相同的 inode 及 data block；

只能对已存在的文件进行创建；

不能交叉文件系统进行硬链接的创建；

不能对目录进行创建，只可对文件创建；

删除一个硬链接文件并不影响其他有相同 inode 号的文件。

&nbsp;

软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（图2） 因此软链接的创建与使用没有类似硬链接的诸多限制：

软链接有自己的文件属性及权限等；

可对不存在的文件或目录创建软链接；

软链接可交叉文件系统；

软链接可对文件或目录创建；

创建软链接时，链接计数 i_nlink 不会增加；

删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

<strong>图</strong><strong> 1. </strong><strong>通过文件名打开文件</strong>

<strong>图</strong><strong> 2. </strong><strong>软链接的访问</strong>

&nbsp;

【7】Linux目录结构：

现代操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用。在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性。为了便于文件的管理，Linux 还引入了目录（有时亦被称为文件夹）这一概念。目录使文件可被分类管理，且目录的引入使 Linux 的文件系统形成一个层级结构的目录树。清单 1.所示的是普通 Linux 系统的顶层目录结构，其中 /dev 是存放了设备相关文件的目录。

清单 1. Linux 系统的顶层目录结构

/              根目录

├── bin     存放用户二进制文件

├── boot    存放内核引导配置文件

├── dev     存放设备文件

├── etc     存放系统配置文件

├── home    用户主目录

├── lib     动态共享库

├── lost+found         文件系统恢复时的恢复文件

├── media   可卸载存储介质挂载点

├── mnt     文件系统临时挂载点

├── opt     附加的应用程序包

├── proc    系统内存的映射目录，提供内核与进程信息

├── root    root 用户主目录

├── sbin    存放系统二进制文件

├── srv     存放服务相关数据

├── sys     sys 虚拟文件系统挂载点

├── tmp     存放临时文件

├── usr     存放用户应用程序

└── var     存放邮件、系统日志等变化文件

Linux 与其他类 UNIX 系统一样并不区分文件与目录：目录是记录了其他文件名的文件。使用命令 mkdir 创建目录时，若期望创建的目录的名称与现有的文件名（或目录名）重复，则会创建失败。

【8】文件目录操作

pwd :显示当前工作目录。

cd:更改工作目录路径。

ls:列出子目录和文件信息。

touch:创建空文件，更改文件或目录文件。

mkdir:创建目录。

rmdir || rm :删除目录。

cp:复制目录和文件。

mv:移动或更名文件或目录。

wc :统计文件字节数-w，字数-c，行数 -l。

&nbsp;

总结：

在Linux系统中除了一般文件之外，所有的目录和设备(光驱，硬盘)都是以文件的形式存在

，linux 文件类型和Linux文件名所代表的是不同的意义，文件类似常见的有：

普通，目录，字符设备，快设备，符号链接文件

Linux系统都有跟文件系统，包含系统引导和使用其他文件系统得以挂载的所必要的文件，Linux系统的目录结构是分层的树形结构，都是挂载在跟文件系统“/”下

在Linux系统下对文件和目录进行操作的命令主要有：

Pwd,cd,cp,rm.rmdir,mkdir,ls,touch,mv,wc等。

在Linux系统中，内核为每一个新创建的文件分配一个inode(索引节点)号，文件属性保存在

索引节点里面，在访问文件时，索引节点被复制到内存里面，从而实现文件的快速访问。

在Linux系统中，包括软，硬链接两种链接，硬链接是一个指针，指向文件索引节点，系统不为他分配节点，硬链接节省空间，也是Linux系统整合文件系统的传统方式，软链接又叫符号链接，这个文件包含了另一个文件的路径名，可以是任意文件或目录，可以链接不同系统的文件。

<a href="http://acmerbar.com/wp-content/uploads/2015/11/52c18a4a9bc471.jpg"><img class="aligncenter size-full wp-image-24" src="http://acmerbar.com/wp-content/uploads/2015/11/52c18a4a9bc471.jpg" alt="" width="500" height="256" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date><![CDATA[2015-11-08 11:59:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-08 03:59:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%90linux%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e3%80%91%e4%b9%8b%e6%96%87%e4%bb%b6%e5%92%8c%e7%9b%ae%e5%bd%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[14]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[yuan]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[15396452@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[117.136.36.191]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-09 11:25:41]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-09 03:25:41]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[学习！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1447039541.2317659854888916015625;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1449462092.24297809600830078125;s:5:"event";s:15:"status-approved";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>鸟哥的Linux私房菜-学习笔记-概论</title>
		<link>http://acmerbar.com/26.html</link>
		<pubDate>Sun, 08 Nov 2015 04:04:38 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=26</guid>
		<description></description>
		<content:encoded><![CDATA[distributions主要分为两大系统，一种是使用RPM方式安装软件的系统，包括Red Hat, Fedora, SuSE等都是这类； 一种则是使用Debian的dpkg方式安装软件的系统，包括Debian, Ubuntu, B2D等等。

到底是要买商业版还是社群版的Linux distribution呢？如果是要装在个人计算机上面做为桌面计算机用的，建议使用社群版， 包括Fedora, Ubuntu, OpenSuSE等等。如果是用在服务器上面的，建议使用商业版本，包括Red Hat, SuSE等。 这是因为社群版通常开发者会加入最新的软件，这些软件可能会有一些bug存在。至于商业版则是经过一段时间的磨合后， 才将稳定的软件放进去。

举例来说，Fedora出来的软件套件经过一段时间的维护后，等到该软件稳定到不容易发生错误后， Red Hat才将该软件放到他们最新的释出版本中。所以，Fedora的软件比较经常改版，Red Hat的软件就较少更版。
<ul class="list1">
	<li><span class="text_import1">选择适合你的Linux distribution</span></li>
</ul>
那我到底应该要选择哪一个distributions？就如同我们上面提到的，其实每个distributions差异性并不大！ 不过，由于套件管理的方式主要分为Debian的dpkg及Red Hat系统的RPM方式， 目前鸟哥的建议是，先学习以RPM套件管理为主的RHEL/Fedora/SuSE/CentOS等台湾使用者较多的版本， 这样一来，发生问题时，可以提供解决的管道比较多。如果你已经接触过Linux了， 还想要探讨更严谨的Linux版本，那可以考虑使用Debian，如果你是以效能至上来考虑， 那么或许Gentoo是不错的建议！

总之，版本很多，但是各版本差异其实不大，建议你一定要先选定一个版本后， 先彻头彻尾的了解他，那再继续玩其他的版本时，就可以很快的进入状况。 鸟哥的网站仅提供一个版本，不过是以比较基础的方式来介绍的， 因此，如果能够熟练俺这个网站的话，呵呵！哪一个distributions对你来说，都不成问题啦！

不过，如果依据计算机主机的用途来分的话，在台湾鸟哥会这样建议：
<ul>
	<li>用于企业环境：建议使用商业版本，例如Red Hat的RHEL或者是Novell的SuSE都是很不错的选择！ 毕竟企业的环境强调的是永续的经营，你可不希望网管人员走了之后整个机房的主机都没有人管理吧！ 由于商业版本都会提供客户服务，所以可以降低企业的风险喔！</li>
	<li>用于个人或教学的服务器环境：要是你的服务器所在环境如果当机还不会造成太大的问题的话， 加上你的环境是在教学的场合当中时(就是说，唔！经费不足的环境啦！)那么可以使用『号称』完全兼容商业版RHEL的CentOS。 因为CentOS是抓RHEL的原始码来重新兜起来的一个Linux distribution，所以号称兼容于RHEL。 这一版的软件完全与RHEL相同，在改版的幅度较小，适合于服务器系统的环境；</li>
	<li>用于个人的桌面计算机：想要尝鲜吗？建议使用很炫的Fedora/Ubuntu等Desktop(桌面环境)使用的版本！ 如果不想要安装Linux的话，那么Fedora或CentOS也有推出Live CD了！也很容易学习喔！</li>
</ul>
<span class="text_h2">关于授权</span>
<div class="block2">

现在市面上有好多的软件，有的是自由软件，有的是专利软件。有的专利软件免费，有的自由软件要钱～ 啊！好烦啊！怎么分辨这些东西？其实，鸟哥并不是律师，对于法律也不十分懂，不过， 还是有几个授权模式可以来谈一谈～

<hr />

<ul class="list1">
	<li class="text_import1">Open Source (开放源码)</li>
</ul>
软件以Open Source的方式释出时，表示除了可执行的软件本身外，一定伴随着原始码的释出喔！通常Open Source的软件有几个好处：
<ol>
	<li>程序设计师通常会等到程序成熟之后才会释出(免得被笑, ^_^)，所以通常程序在雏形的时候，就已经具有相当的优良体质；</li>
	<li>Open Source的精神，相信当程序原设计人将程序原始码释出之后，其他的程序设计师接受这份原始码之后， 由于需要将程序改成自己所需的样式，所以会经由本身的所学来加以改良，并从中加以改良与除虫， 所以程序的debug功能会比传统的close source来的快！</li>
	<li>由于程序是伴随原始码的，因此，系统将会不易存在鲜为人知的木马程序或一些安全漏洞， 相对而言，会比较更加的安全！</li>
</ol>
Open source的代表授权为GNU的GPL授权及BSD等等，底下列出知名的Open Source授权网页：
<ul>
	<li><span class="text_import2">GNU General Public License</span>：
<a href="http://www.gnu.org/licenses/licenses.html#GPL" target="_blank">http://www.gnu.org/licenses/licenses.html#GPL</a>
目前有version 2, version 3两种版本，Linux使用的是version 2这一版。 鸟哥也有收集一份GPL version 2 的中文化条文，您可以参考：<a href="http://vbird.dic.ksu.edu.tw/linux_basic/1010appendix_A.php" target="_blank">http://vbird.dic.ksu.edu.tw/linux_basic/1010appendix_A.php</a></li>
	<li><span class="text_import2">Berkeley Software Distribution (BSD)</span>：
<a href="http://en.wikipedia.org/wiki/BSD_license" target="_blank">http://en.wikipedia.org/wiki/BSD_license</a>
使用BSD source code最常接触到的就是BSD授权模式了！这个授权模式其实与GPL很类似， 而其精神也与Open Source相呼应呢！</li>
	<li><span class="text_import2">Apache License, Version 2.0</span>：
<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">http://www.apache.org/licenses/LICENSE-2.0</a>
Apache是一种网页服务器软件，这个软件的发布方式也是使用Open source的。只是在apache的授权中规定， 如果想要重新发布此软件时(如果你有修改过该软件)，软件的名称依旧需要定名为Apache才行！</li>
</ul>

<hr />

<ul class="list1">
	<li class="text_import1">Close Source</li>
</ul>
相对于Open Source的软件会释出原始码，Close source的程序则仅推出可执行的二进制程序(binary program)而已。 这种软件的优点是有专人维护，你不需要去更动他；缺点则是灵活度大打折扣，用户无法变更该程序成为自己想要的样式！ 此外，若有木马程序或者安全漏洞，将会花上相当长的一段时间来除错！这也是所谓专利软件(copyright)常见的软件出售方式。

虽然专利软件常常代表就是需要花钱去购买，不过有些专利软件还是可以免费提供大众使用的！ 免费的专利软件代表的授权模式有：
<ul>
	<li><span class="text_import2">Freeware</span>：
<a href="http://en.wikipedia.org/wiki/Freeware" target="_blank">http://en.wikipedia.org/wiki/Freeware</a>
不同于Free software，Freeware为『免费软件』而非『自由软件！』虽然它是免费的软件，但是不见得要公布其原始码， 端看释出者的意见啰！这个东西与Open Source毕竟是不太相同的东西喔！此外，目前很多标榜免费软件的程序很多都有小问题！ 例如假藉免费软件的名义，实施用户数据窃取的目的！ 所以『<span class="text_import2">来路不明的软件请勿安装</span>！』</li>
	<li><span class="text_import2">Shareware</span>：
<a href="http://en.wikipedia.org/wiki/Shareware" target="_blank">http://en.wikipedia.org/wiki/Shareware</a>
共享件这个名词就有趣了！与免费软件有点类似的是，Shareware在使用初期，它也是免费的，但是， 到了所谓的『试用期限』之后，你就必须要选择『付费后继续使用』或者『将它移除』的宿命～ 通常，这些共享件都会自行撰写失效程序，让你在试用期限之后就无法使用该软件。</li>
</ul>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date><![CDATA[2015-11-08 12:04:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-08 04:04:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%b8%9f%e5%93%a5%e7%9a%84linux%e7%a7%81%e6%88%bf%e8%8f%9c-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-%e6%a6%82%e8%ae%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>鸟哥的Linux私房菜-学习笔记-第二章【Linux 如何学习】</title>
		<link>http://acmerbar.com/27.html</link>
		<pubDate>Sun, 08 Nov 2015 04:07:03 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=27</guid>
		<description></description>
		<content:encoded><![CDATA[建议：
<ol>
	<li><span class="text_import2">计算机概论与硬件相关知识：</span>
因为既然想要走Linux这门路，资讯相关的基础技能也不能没有啊！ 所以先理解一下基础的硬件知识，不用一定要全懂啦！又不是真的要你去组计算机～^_^， 但是至少要『听过、有概念』即可；</li>
	<li><span class="text_import2">先从Linux的安装与指令学起：</span>
没有Linux怎么学习Linux呢？所以好好的安装起一套你需要的Linux吧！虽然说Linux distributions很多， 不过基本上架构都是大同小异的，差别在於介面的亲和力与软件的选择不同罢了！ 选择一套你喜欢的就好了，倒是没有哪一套特别好说～</li>
	<li><span class="text_import2">Linux操作系统的基础技能：</span>
这些包含了『使用者、群组的概念』、『权限的观念』，『程序的定义』等等，尤其是权限的概念， 由於不同的权限设定会妨碍你的使用者的便利性，但是太过於便利又会导致入侵的可能！ 所以这里需要了解一下你的系统呦！</li>
	<li><span class="text_import2">务必学会vi文书编辑器：</span>
Linux的文书编辑器多到会让你数到生气！不过，vi却是强烈建议要先学习的！ 这是因为vi会被很多软件所呼叫，加上所有的Unix like系统上面都有vi，所以你一定要学会才好！</li>
	<li><span class="text_import2">Shell与Shell Script的学习：</span>
其实鸟哥上面一直谈到的『文字介面』说穿了就是一个名为shell的软件啦！既然要玩文字介面，当然就是要会使用shell的意思。 但是shell上面的数据太多了，包括『正规表示法』、『管线命令』与『数据流重导向』等等，真的需要了解比较好呦！ 此外，为了帮助你未来的管理服务器的便利性，shell scripts也是挺重要的！要学要学！</li>
	<li><span class="text_import2">一定要会软件管理员：</span>
因为玩Linux常常会面临得要自己安装驱动程式或者是安装额外软件的时候，尤其是嵌入式设备或者是学术研究单位等。 这个时候Tarball/RPM/DPKG等软件管理员的安装方式的了解，对你来说就重要到不行了！</li>
	<li><span class="text_import2">网路基础的建立：</span>
如果上面你都通过了，那么网路的基础就是下一阶段要接触的咚咚，这部份包含了『IP概念』『路由概念』等等；</li>
	<li>如果连网路基础都通过了，那么网站的架设对你来说，简直就是『太简单啦！』</li>
</ol>
在一些基础知识上，可能的话，当然得去书店找书来读啊！ 如果您想要由网路上面阅读的话，那么这里推荐一下由Netman大哥主笔的Study-Area里面的基础文章，相当的实用！

<span class="text_h1">重点回顾</span>
<div class="block1">
<ul class="text_import2">
	<li>Linux在企业应用方面，著重於『网路服务器』、『关键任务的应用(金融数据库、大型企业网管环境)』及『高效能运算』等任务；</li>
	<li>Linux在个人环境的使用上，著重於：桌面计算机、手持系统(PDA、手机)、嵌入式设备(如家电用品等)；</li>
	<li>Linux distributions有针对桌面计算机所开发的，例如Ubuntu, OpenSuSE及Fedora等等，为学习X Window的好工具；</li>
	<li>有心朝Linux学习者，应该多接触文字介面(shell)的环境，包括正规表示法、管线命令与资料流重导向，最好都要学习！ 最好连shell script都要有能力自行撰写；</li>
	<li>『实作』是学习Linux的最佳方案，空读书，遇到问题也不见得能够自己处理的！</li>
	<li>学习Linux时，建立兴趣、建立成就感是很重要的，另外，协助回答问题、参与社群活动也是增加热情的方式！</li>
	<li>Linux文件计画的网站在：http://www.tldp.org</li>
</ul>
</div>
<ul>
	<li><a href="http://www.study-area.org/compu/compu.htm" target="_blank">电脑基础 (http://www.study-area.org/compu/compu.htm)</a></li>
	<li><a href="http://www.study-area.org/network/network.htm" target="_blank">网路基础 (http://www.study-area.org/network/network.htm)</a></li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>27</wp:post_id>
		<wp:post_date><![CDATA[2015-11-08 12:07:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-08 04:07:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%b8%9f%e5%93%a5%e7%9a%84linux%e7%a7%81%e6%88%bf%e8%8f%9c-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-%e7%ac%ac%e4%ba%8c%e7%ab%a0%e3%80%90linux-%e5%a6%82%e4%bd%95%e5%ad%a6%e4%b9%a0%e3%80%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>鸟哥的Linux私房菜-学习笔记-第三章【主机规划与磁盘分区】</title>
		<link>http://acmerbar.com/28.html</link>
		<pubDate>Sun, 08 Nov 2015 04:08:50 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=28</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>磁盘分区</strong>

个人计算机常见的磁盘介面有两种， 分别是IDE与SATA介面，目前(2009)的主流已经是SATA介面了，但是老一点的主机其实大部分还是使用IDE介面。 我们称呼可连接到IDE介面的装置为IDE装置，不管是磁盘还是光盘设备。

以IDE介面来说，由于一个IDE排线可以连接两个IDE装置，又通常主机都会提供两个IDE介面，因此最多可以接到四个IDE装置。 也就是说，如果你已经有一个光盘设备了，那么最多就只能再接三颗IDE介面的磁盘。 这两个IDE介面通常被称为<span class="text_import2">IDE1(primary)及IDE2(secondary)</span>， 而每条排线上面的IDE装置可以被区分为<span class="text_import2">Master与Slave</span>。这四个IDE装置的档名为：
<table border="1" width="95%" cellspacing="0" cellpadding="3" bgcolor="lightyellow">
<tbody>
<tr align="center" bgcolor="#182448">
<td>IDE\Jumper</td>
<td>Master</td>
<td>Slave</td>
</tr>
<tr align="center">
<td bgcolor="#182448">IDE1(Primary)</td>
<td class="text_import1">/dev/hda</td>
<td class="text_import1">/dev/hdb</td>
</tr>
<tr align="center">
<td bgcolor="#182448">IDE2(Secondary)</td>
<td class="text_import1">/dev/hdc</td>
<td class="text_import1">/dev/hdd</td>
</tr>
</tbody>
</table>
<span class="text_h2">磁碟的组成复习</span>
<div class="block2">

我们在<a href="http://vbird.dic.ksu.edu.tw/linux_basic/0105computers.php" target="_blank">计算机概论</a>谈过磁碟的组成主要有磁碟盘、机械手臂、磁碟读取头与主轴马达所组成， 而数据的写入其实是在磁碟盘上面。<span class="text_import2">磁碟盘上面又可细分出磁区(Sector)与磁柱(Cylinder)两种单位， 其中磁区每个为512bytes那么大。</span>假设磁碟只有一个磁碟盘，那么磁碟盘有点像底下这样：

<a target="_blank" name="fig2.2.1"></a><center><img title="磁碟盘组成示意图" src="http://acmerbar.com/wp-content/uploads/2015/11/harddisk.jpg" alt="磁碟盘组成示意图" border="1" />
图2.2.1、磁碟盘组成示意图</center>那么是否每个磁区都一样重要呢？其实整颗磁碟的第一个磁区特别的重要，因为他记录了整颗磁碟的重要资讯！ 磁碟的第一个磁区主要记录了两个重要的资讯，分别是：
<ul class="text_import2">
	<li>主要启动记录区(Master Boot Record, MBR)：可以安装启动管理程序的地方，有446 bytes</li>
	<li>分割表(partition table)：记录整颗硬盘分割的状态，有64 bytes</li>
</ul>
MBR是很重要的，因为当系统在启动的时候会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪里且该如何进行启动。 如果你要安装多重启动的系统，MBR这个区块的管理就非常非常的重要了！ ^_^

那么分割表又是啥？其实你刚刚拿到的整颗硬盘就像一根原木，你必须要在这根原木上面切割出你想要的区段， 这个区段才能够再制作成为你想要的家具！如果没有进行切割，那么原木就不能被有效的使用。 同样的道理，你必须要针对你的硬盘进行分割，这样硬盘才可以被你使用的！

</div>
<strong>磁盘分区表（partition table）</strong>

我们<span class="text_import2">利用参考对照磁柱号码的方式来处理, 在分割表所在的64 bytes容量中，总共分为四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码</span>。 若将硬盘以长条形来看，然后将磁柱以直条图来看，那么那64 bytes的记录区段有点像底下的图示：

<center><img title="磁盘分区表的作用示意图" src="http://acmerbar.com/wp-content/uploads/2015/11/partition-1.png" alt="磁盘分区表的作用示意图" border="0" />
图2.3.1、磁盘分区表的作用示意图</center>假设上面的硬盘装置档名为/dev/hda时，那么这四个分割槽在Linux系统中的装置档名如下所示， 重点在於档名后面会再接一个数字，这个数字与该分割槽所在的位置有关！
<ul>
	<li>P1:/dev/hda1</li>
	<li>P2:/dev/hda2</li>
	<li>P3:/dev/hda3</li>
	<li>P4:/dev/hda4</li>
</ul>
上图中我们假设硬盘只有400个磁柱，共分割成为四个分割槽，第四个分割槽所在为第301到400号磁柱的范围。 当你的操作系统为Windows时，那么第一到第四个分割槽的代号应该就是C, D, E, F。当你有数据要写入F槽时， 你的数据会被写入这颗磁碟的301~400号磁柱之间的意思。

由於分割表就只有64 bytes而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主要(Primary)或延伸(Extended)分割槽。 根据上面的图示与说明，我们可以得到几个重点资讯：
<ul class="text_import2">
	<li>其实所谓的『分割』只是针对那个64 bytes的分割表进行配置而已！</li>
	<li>硬盘默认的分割表仅能写入四组分割资讯</li>
	<li>这四组分割资讯我们称为主要(Primary)或延伸(Extended)分割槽</li>
	<li>分割槽的最小单位为磁柱(cylinder)</li>
	<li>当系统要写入磁碟时，一定会参考磁盘分区表，才能针对某个分割槽进行数据的处理</li>
</ul>
思考分割的角度：
<ol>
	<li><span class="text_import2">数据的安全性：</span>
因为每个分割槽的数据是分开的！所以，当你需要将某个分割槽的数据重整时，例如你要将计算机中Windows的C槽重新安装一次系统时， 可以将其他重要数据移动到其他分割槽，例如将邮件、壁纸数据移动到D槽去，那么C槽重灌系统并不会影响到D槽！ 所以善用分割槽，可以让你的数据更安全。</li>
	<li><span class="text_import2">系统的效能考量：</span>
由於分割槽将数据集中在某个磁柱的区段，例如上图当中第一个分割槽位於磁柱号码1~100号，如此一来当有数据要读取自该分割槽时， 磁碟只会搜寻前面1~100的磁柱范围，由於数据集中了，将有助於数据读取的速度与效能！所以说，分割是很重要的！</li>
</ol>
主要分割、扩展分配与逻辑分割的特性我们作个简单的定义：
<ul class="text_import2">
	<li>主要分割与扩展分配最多可以有四笔(硬盘的限制)</li>
	<li>扩展分配最多只能有一个(操作系统的限制)</li>
	<li>逻辑分割是由扩展分配持续切割出来的分割槽；</li>
	<li>能够被格式化后，作为数据存取的分割槽为主要分割与逻辑分割。扩展分配无法格式化；</li>
	<li>逻辑分割的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分割(5号到63号)， SATA硬盘则有11个逻辑分割(5号到15号)。</li>
</ul>
<strong>启动流程与主要启动记录区(MBR)</strong>

CMOS是记录各项硬件参数且嵌入在主板上面的储存器，BIOS则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。<span class="text_import2">这个BIOS就是在启动的时候，计算机系统会主动运行的第一个程序了！</span>

接下来BIOS会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS会依据使用者的配置去取得能够启动的硬盘， 并且<span class="text_import2">到该硬盘里面去读取第一个磁区的MBR位置。 MBR这个仅有446 bytes的硬盘容量里面会放置最基本的启动管理程序</span>， 此时BIOS就功成圆满，而接下来就是MBR内的启动管理程序的工作了。

<span class="text_import2">这个启动管理程序的目的是在加载(load)核心文件</span>， 由於启动管理程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式，因此就能够读取核心文件， 然后接下来就是核心文件的工作，启动管理程序也功成圆满，之后就是大家所知道的操作系统的任务啦！

简单的说，整个启动流程到操作系统之前的动作应该是这样的：
<ol class="text_import2">
	<li><strong>BIOS</strong>：启动主动运行的韧体，会认识第一个可启动的装置；</li>
	<li><strong>MBR</strong>：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；</li>
	<li><strong>启动管理程序(boot loader)</strong>：一支可读取核心文件来运行的软件；</li>
	<li><strong>核心文件</strong>：开始操作系统的功能...</li>
</ol>
由上面的说明我们会知道，BIOS与MBR都是硬件本身会支持的功能，至於Boot loader则是操作系统安装在MBR上面的一套软件了。由於MBR仅有446 bytes而已，因此这个启动管理程序是非常小而美的。 这个boot loader的主要任务有底下这些项目：
<ul class="text_import2">
	<li><strong>提供菜单</strong>：使用者可以选择不同的启动项目，这也是多重启动的重要功能！</li>
	<li><strong>加载核心文件</strong>：直接指向可启动的程序区段来开始操作系统；</li>
	<li><strong>转交其他loader</strong>：将启动管理功能转交给其他loader负责。</li>
</ul>
上面前两点还容易理解，但是注意第三点，表示你的计算机系统里面可能具有两个以上的启动管理程序呢！ 有可能吗？我们的硬盘不是只有一个MBR而已？是没错，但是<span class="text_import2">启动管理程序除了可以安装在MBR之外， 还可以安装在每个分割槽的启动磁区(boot sector)！</span>

我们举一个例子来说，假设你的个人计算机只有一个硬盘，里面切成四个分割槽，其中第一、二分割槽分别安装了Windows及Linux， 你要如何在启动的时候选择用Windows还是Linux启动呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的启动管理程序， 那么整个流程可以图示如下：

<center><img title="启动管理程序的工作运行示意图" src="http://acmerbar.com/wp-content/uploads/2015/11/loader.gif" alt="启动管理程序的工作运行示意图" border="0" />
图2.4.1、启动管理程序的工作运行示意图</center>在上图中我们可以发现，MBR的启动管理程序提供两个菜单，菜单一(M1)可以直接加载Windows的核心文件来启动； 菜单二(M2)则是将启动管理工作交给第二个分割槽的启动磁区(boot sector)。当使用者在启动的时候选择菜单二时， 那么整个启动管理工作就会交给第二分割槽的启动管理程序了。 当第二个启动管理程序启动后，该启动管理程序内(上图中)仅有一个启动菜单，因此就能够使用Linux的核心文件来启动。 这就是多重启动的工作情况，我们将上图作个总结：
<ul class="text_import2">
	<li>每个分割槽都拥有自己的启动磁区(boot sector)</li>
	<li>图中的系统槽为第一及第二分割槽，</li>
	<li>实际可启动的核心文件是放置到各分割槽内的！</li>
	<li>loader只会认识自己的系统槽内的可启动核心文件，以及其他loader而已；</li>
	<li>loader可直接指向或者是间接将管理权转交给另一个管理程序。</li>
</ul>
Linux安装模式下， 磁盘分区的选择(极重要)
<ul class="list1">
	<li class="text_import1">目录树结构(directory tree)</li>
</ul>
我们前面有谈过Linux内的所有数据都是以文件的形态来呈现的，所以，整个Linux系统最重要的地方就是在於目录树架构。 所谓的目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。 所以，<span class="text_import2">整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『<strong>/</strong>』</span>， 所有的文件都与目录树有关。目录树的呈现方式如下图所示：

<center><img title="目录树相关性示意图" src="http://acmerbar.com/wp-content/uploads/2015/11/dirtree.gif" alt="目录树相关性示意图" border="0" />
图2.5.1、目录树相关性示意图</center>如上图所示，所有的文件都是由根目录(/)衍生来的，而次目录之下还能够有其他的数据存在。上图中长方形为目录， 波浪形则为文件。那当我们想要取得mydata那个文件时，系统就得由根目录开始找，然后找到home接下来找到dmtsai， 最终的档名为：/home/dmtsai/mydata的意思。

我们现在知道整个Linux系统使用的是目录树架构，但是我们的文件数据其实是放置在磁盘分区槽当中的， 现在的问题是『<span class="text_import2">如何结合目录树的架构与磁碟内的数据</span>』呢？ 这个时候就牵扯到『挂载(mount)』的问题！

<hr />

<ul class="list1">
	<li class="text_import1">文件系统与目录树的关系(挂载)</li>
</ul>
<span class="text_import2">所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说，进入该目录就可以读取该分割槽</span>的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。 由於整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分割槽的。 至於其他的目录则可依使用者自己的需求来给予挂载到不同的分割槽。我们以下图来作为一个说明：

<center><img title="目录树与分割槽之间的相关性" src="http://acmerbar.com/wp-content/uploads/2015/11/dir_3.png" alt="目录树与分割槽之间的相关性" border="1" />
图2.5.2、目录树与分割槽之间的相关性</center>上图中假设我的硬盘分为两槽，partition 1是挂载到根目录，至於partition 2则是挂载到/home这个目录。 这也就是说，当我的数据放置在/home内的各次目录时，数据是放置到partition 2的，如果不是放在/home底下的目录， 那么数据就会被放置到partition 1了！

其实判断某个文件在那个partition底下是很简单的，透过反向追踪即可。以上图来说， 当我想要知道/home/vbird/test这个文件在那个partition时，由<span class="text_import2">test --&gt; vbird --&gt; home --&gt; /，看那个『进入点』先被查到那就是使用的进入点了</span>。 所以test使用的是/home这个进入点而不是/!

&nbsp;

<hr />

<ul class="list1">
	<li class="text_import1">distributions安装时，挂载点与磁盘分区的规划：</li>
</ul>
既然我们在Linux系统下使用的是目录树系统，所以安装的时候自然就得要规划磁盘分区与目录树的挂载了。 实际上，在Linux安装的时候已经提供了相当多的默认模式让你选择分割的方式了， 不过，无论如何，分割的结果可能都不是很能符合自己主机的样子！因为毕竟每个人的『想法』都不太一样！ 因此，<span class="text_import2">强烈建议使用『自订安装, Custom 』这个安装模式</span>！在某些Linux distribution中，会将这个模式写的很厉害，叫做是『Expert, 专家模式』。
<ul>
	<li><span class="text_import1">自订安装『Custom』：</span>
<div class="block2">
<ul class="list1">
	<li class="text_import2">A：初次接触Linux：只要分割『 / 』及『swap』即可：</li>
</ul>
通常初次安装Linux系统的朋友们，我们都会建议他直接以一个最大的分割槽『 / 』来安装系统。 这样作有个好处，就是不怕分割错误造成无法安装的困境！例如/usr是Linux的可运行程序及相关的文件摆放的目录， 所以他的容量需求蛮大的，万一你分割了一块分割槽给/usr，但是却给的不够大，那么就伤脑筋了！ 因为会造成无法将数据完全写入的问题，就有可能会无法安装，因此如果你是初次安装的话， 那么可以仅分割成两个分割槽『 / 与 Swap 』即可。
<ul class="list1">
	<li class="text_import2">B：建议分割的方法：预留一个备用的剩余磁碟容量！</li>
</ul>
在想要学习Linux的朋友中，最麻烦的可能就是得要常常处理分割的问题，因为分割是系统管理员很重要的一个任务。 但如果你将整个硬盘的容量都用光了，那么你要如何练习分割呢？^_^。就是可以特别预留一块不分割的磁碟容量，作为后续练习时可以用来分割之用！

此外，预留的分割槽也可以拿来做为备份之用。因为我们在实际操作Linux系统的过程中， 可能会发现某些script或者是重要的文件很值得备份时，就可以使用这个剩余的容量分割出新的分割槽， 并使用来备份重要的配置档或者是script。这有个最大的好处， 就是当我的Linux重新安装的时候，我的一些软件或工具程序马上就可以直接在硬盘当中找到！重新安装比较便利。 为什么要重新安装？因为没有安装过Linux十次以上，不要说你学会了Linux了啦！慢慢体会这句话吧！ ^_^

</div></li>
	<li><span class="text_import1">选择Linux安装程序提供的默认硬盘分割方式：</span>
<div class="block2">

对於首次接触Linux的朋友们，鸟哥通常不建议使用各个distribution所提供默认的Server安装方式， 因为会让你无法得知Linux在搞什么鬼，而且也不见得可以符合你的需求！而且要注意的是， 选择Server的时候，请『确定』你的硬盘数据是不再需要！因为Linux会自动的把你的硬盘里面旧有的数据全部杀掉！ 此外，硬盘至少需要2 GB以上才可以选择这一个模式！

</div></li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>28</wp:post_id>
		<wp:post_date><![CDATA[2015-11-08 12:08:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-08 04:08:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%b8%9f%e5%93%a5%e7%9a%84linux%e7%a7%81%e6%88%bf%e8%8f%9c-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-%e7%ac%ac%e4%b8%89%e7%ab%a0%e3%80%90%e4%b8%bb%e6%9c%ba%e8%a7%84%e5%88%92%e4%b8%8e%e7%a3%81%e7%9b%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>【12件小事改变你的生活】</title>
		<link>http://acmerbar.com/42.html</link>
		<pubDate>Mon, 09 Nov 2015 05:28:47 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=42</guid>
		<description></description>
		<content:encoded><![CDATA[【12件小事改变生活】

①早睡，摆脱“晚睡综合征”的困扰，让你醒来时精神满满；②暂离网络，工作和学习时，关掉不必要的网页，丢开不需要的电子设备，你的效率会大大提升；③打电话给妈妈，而不是匆忙寒暄。别把耐心留给外人，把坏脾气留给家人……坚持这些小事，一个月以后改变你的生活！

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp772zt6tj20c80c8myk.jpg"><img class="aligncenter size-full wp-image-43" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp772zt6tj20c80c8myk.jpg" alt="" width="440" height="440" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp773ndjsj20c80c63zr.jpg"><img class="aligncenter size-full wp-image-44" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp773ndjsj20c80c63zr.jpg" alt="" width="440" height="438" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp774wndij20c80c8my8.jpg"><img class="aligncenter size-full wp-image-45" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp774wndij20c80c8my8.jpg" alt="" width="440" height="440" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp775l1j4j20c80c8wfm.jpg"><img class="aligncenter size-full wp-image-46" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp775l1j4j20c80c8wfm.jpg" alt="" width="440" height="440" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp776ttnwj20c80fwdhd.jpg"><img class="aligncenter size-full wp-image-47" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp776ttnwj20c80fwdhd.jpg" alt="" width="440" height="572" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp777hpkqj20c80fwdho.jpg"><img class="aligncenter size-full wp-image-48" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp777hpkqj20c80fwdho.jpg" alt="" width="440" height="572" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp7749q2fj20c80c8q3y.jpg"><img class="aligncenter size-full wp-image-49" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp7749q2fj20c80c8q3y.jpg" alt="" width="440" height="440" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp7783tttj20c80fw764.jpg"><img class="aligncenter size-full wp-image-50" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp7783tttj20c80fw764.jpg" alt="" width="440" height="572" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp77689yjj20c80c6t9u.jpg"><img class="aligncenter size-full wp-image-51" src="http://acmerbar.com/wp-content/uploads/2015/11/9b84f62fjw1exp77689yjj20c80c6t9u.jpg" alt="" width="440" height="438" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>42</wp:post_id>
		<wp:post_date><![CDATA[2015-11-09 13:28:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-09 05:28:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%9012%e4%bb%b6%e5%b0%8f%e4%ba%8b%e6%94%b9%e5%8f%98%e4%bd%a0%e7%9a%84%e7%94%9f%e6%b4%bb%e3%80%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%84%9f%e6%82%9f%e4%bd%93%e4%bc%9a"><![CDATA[感悟体会]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《少年啊，前路漫漫》读书笔记I</title>
		<link>http://acmerbar.com/53.html</link>
		<pubDate>Mon, 09 Nov 2015 12:42:53 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=53</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>内容简介</strong>

1、在“知乎”，他的文章赢得150000人关注，400000次赞同和58000次感谢，

2、红遍知乎、豆瓣，微信朋友圈深受90后喜爱的励志写手GayScript全新作品

3、人生都有一些不能言说的迷茫、痛苦、孤单；感觉前面什么也看不见，前路漫漫，摸黑赶路。但相信只要走好脚下的路，就会有方向。GayScript愿作远方微弱的星光，或给一点温暖，或指引你前行。

愿我们虽摸黑赶路，但仍能发光如星。

红遍知乎、豆瓣，微信朋友圈；

深受90后喜爱的励志写手GayScript

真诚书写90后自己的故事和思考。

文章零星被贴在网络，却引发了同龄人集体点赞转发。

前路漫漫，愿作远方微弱的星光，或给一点温暖，或指引你前行。<sup>[1]</sup>
<h2>作者简介</h2>
红遍知乎、豆瓣的励志写手Gayscript，家境困苦，努力学习，后被保送上海交大；大学四年靠奖学金和助学贷款还有兼职，赚取大学学费，毕业三年存款15万；知乎成名，凭借其独特、幽默、犀利的答案，赢得150000人关注，400000次赞同和58000次感谢。人称“知乎励志一哥”。

一名“码农”却立志成为专业作家。他一直在路上，追寻真正的自己。<sup>[1]</sup>

<strong>不聪明怎么办？</strong>

<strong>已经够矮了，那就爬到一个高度</strong>

许多人都喜欢在遇到不公平的事情时抱怨，哀叹，不知道该怎么办，放佛抱怨完了，这事情就没了，可我总觉得，自己的现状你自己不改变，难道还指望别人来改变吗？你什么都不做。

抱怨完了这次，还会抱怨下次，抱怨总是无用的，也是无止尽的，只有真正去努力，才能改变现状，改变未来。

我们绝大数的人都是不那么聪明的，你只要多多努力，把那些同样平凡却只会抱怨，不够努力的人甩到后台就行了

成为更好的自己

与其想着怎么改变外貌让人喜欢，还不如努力成为一个更好的人，一个善良的，友好的，谦虚的，热情的人，

当你成为这种人的时候，就会成为大家的朋友，那些所谓的斑斑点点，也就都被大家爱屋及乌了。

一个人，想给自己找理由，总是可以找的，一个人，不想改变现状，你怎么鼓励他，他也不肯学习，不肯上进，只是没被逼上绝路，想你那样的人，不努力，还可以勉强的活着，像我这样的人，不努力，等死吗？

人活着，最怕一无所求，整日庸庸碌碌，那跟混吃混喝有什么区别？

趁着还活着，一定一定，要热烈的活着，不要在死掉的那一刻忽然觉得还有好多的遗憾，还有好多的不甘心。

如果只会抱怨，那当然一事无成。

如果安于现状，那自然回天乏术、

努力，才有希望。

不放弃，才可能成功。

自怨自艾，怨天尤人，那永远只能站在原地，裹足不前。

真正的兴趣是在钻研途中渐渐发展的，伴随着知识的累积和增长，渐渐发现这一事物的内在魅力，花了深刻的心思和长久的时间，需要付出代价，而不是门外汉只站在外头一下子就有的，少说大话，多做实事。

&nbsp;

要实现目标，无非就是：执行力高，想到了就立刻去做，绝不拖延，不说“明天”，不说“以后”，就“当下”，就“现在”；做了就坚持到底，绝不三分钟热度；遇到问题不害怕，不退缩，想办法解决，自己解决不了，求助别人，总之不放弃；有计划，有耐力，有自制力，能循序渐进的按着计划走，能持之以恒的慢慢来。

&nbsp;

人与人之间，一天两天的差距，你是看不到的，，等你看到差距了，绝不是一天两天，所有的好与坏，成功和失败，平凡和优秀，都是漫长时期积累的结果

这世界是好坏参半的，有光明也有黑暗，就算随波逐流，希望你也能选光明的那一面，就算生活在阴沟里，也可以仰望星空。要对生活执着，要始终相信未来，在任何苦难逆境中，也不能丧失对生活的期盼和热爱，即使在最残酷的现实面前，也不能觉得世事一无可取，总应该尽己所能，给这个世界增加一点美好的东西。

<u>你读什么书，无论是网络小说，还是文学名著，都会在潜意识里改变你的人生态度，当你在生活中遇到了什么的时候，你会因此做出不同的选择，聪明的人，懂得从书中挑选，择其善者而从之，则其不善者而改之。</u>

<u>我相信许多人都有过这样的经历，别人都说一本书很不错，自己看了却觉得一般，其实原因很简单，你还不到读这本书的时候，许多优秀的书，唯有等到你有所经历了或者阅历达到了一定程度了，再去看，才有惺惺相惜，感同身受的感觉。</u>

知识太容易获得，太容易沉溺，许多人边马不停蹄，辗转于各个好答案中，称赞别人，收藏表彰，却从不见用自己的语言来表达，纸上得来终觉浅，一味看，一味接受，不懂得取其精华，去其糟粕，也不输出，不总结，读万卷书，也只是个数字。

人生嘈杂，与其塞上耳朵，不如塞满心

<a href="http://acmerbar.com/wp-content/uploads/2015/11/m_b16d53763f4d000001576c6589aa.png"><img class="aligncenter size-full wp-image-55" src="http://acmerbar.com/wp-content/uploads/2015/11/m_b16d53763f4d000001576c6589aa.png" alt="" width="600" height="900" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>53</wp:post_id>
		<wp:post_date><![CDATA[2015-11-09 20:42:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-09 12:42:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e5%b0%91%e5%b9%b4%e5%95%8a%ef%bc%8c%e5%89%8d%e8%b7%af%e6%bc%ab%e6%bc%ab%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0i]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%84%9f%e6%82%9f%e4%bd%93%e4%bc%9a"><![CDATA[感悟体会]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Dilworth定理的应用(最少覆盖,最少链划分)</title>
		<link>http://acmerbar.com/?p=89</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=89</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>89</wp:post_id>
		<wp:post_date><![CDATA[2015-11-17 21:27:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《计算机网络--网络层》</title>
		<link>http://acmerbar.com/?p=177</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=177</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

<strong>1.频分复用 FDM(Frequency Division Multiplexing)</strong>

用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。
频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。

<strong>2.时分复用TDM(Time Division Multiplexing)</strong>

时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。
每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。
TDM 信号也称为等时(isochronous)信号。
时分复用的所有用户是在不同的时间占用同样的频带宽度。

<strong>3.   波分复用 WDM(Wavelength Division Multiplexing)  </strong>

波分复用就是光的频分复用。

<strong>4. 码分复用 CDM(Code Division Multiplexing)  </strong>

常用的名词是码分多址 CDMA
(Code Division Multiple Access)。
各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。
这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。
每一个比特时间划分为 m 个短的间隔，称为码片(chip)。

<strong>5.  宽带接入技术[ xDSL技术]</strong>

xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。
虽然标准模拟电话信号的频带被限制在 300~3400 kHz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。
xDSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。
DSL 就是数字用户线(Digital Subscriber Line)的缩写。而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。

几种类型：

ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线
HDSL (High speed DSL)：高速数字用户线
SDSL (Single-line DSL)：1 对线的数字用户线
VDSL (Very high speed DSL)：甚高速数字用户线
DSL ：ISDN 用户线。
RADSL (Rate-Adaptive DSL)：速率自适应  DSL，是 ADSL 的一个子集，可自动调节线路速率）。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>177</wp:post_id>
		<wp:post_date><![CDATA[2015-12-06 13:22:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>收集Linux 下一些有趣的命令</title>
		<link>http://acmerbar.com/?p=196</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=196</guid>
		<description></description>
		<content:encoded><![CDATA[【1】sl命令，会跑出来一辆咕咚咕咚的小火车，感觉很有意思

【2】fortune命令，随机输出一句话或短语或唐诗宋词，英文的安装fortune-mod，唐诗宋词安装fortune-zh,以后想背背古诗，就输这个命令好了

【3】xeyes命令，屏幕出来一个小眼睛，linux下的应用程序

【4】linuxlogo命令：打印linux的logo

【5】再试试下面这一串命令，也挺有意思的：

aptitude moo

aptitude -v moo

aptitude -vv moo

aptitude -vvv moo

aptitude -vvvv moo

aptitude -vvvvv moo

aptitude -vvvvvv moo

aptitude -vvvvvvv moo]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>196</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 14:07:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>wordpress支付宝捐赠功能的实现</title>
		<link>http://acmerbar.com/?p=206</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=206</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
<ol>
	<li>//彩色标签云</li>
	<li>function colorCloud($text) {</li>
	<li>$text = preg_replace_callback('|&lt;a (.+?)&gt;|i', 'colorCloudCallback', $text);</li>
	<li>return $text;</li>
	<li>}</li>
	<li>function colorCloudCallback($matches) {</li>
	<li>$text = $matches[1];</li>
	<li>$color = dechex(rand(0,16777215));</li>
	<li>$pattern = '/style=(\'|\")(.*)(\'|\")/i';</li>
	<li>$text = preg_replace($pattern, "style=\"color:#{$color};$2;\"", $text);</li>
	<li>return "&lt;a $text&gt;";</li>
	<li>}</li>
	<li>add_filter('wp_tag_cloud', 'colorCloud', 1);</li>
</ol>
</div>
wordpress支付宝捐赠功能的实现
在研究 wordpress 博客赢利模式时，发现不少的博主都挂上了“支付宝，捐赠本站”的支付宝个人及时到帐功能，在本站放怎么个捐赠本站，如果有好心人觉得站点不错，可以给捐赠一点 money，以便于本站的发展，其实跟目前最火热的打赏功能一样，当文章读者觉得这篇文章不错，就可以给文章的作者进行一定的打赏以给鼓励，捐赠过来的款项是直接转入到支付宝的，现在夏日博客就来教下大家如何实现这样的功能吧。

其实实现这样的功能很简单，支付宝已经提供了一组这样的转帐表单，我们只要放到站点上就可以了，代码如下:

&lt;form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="POST" target="_blank" accept-charset="GBK"&gt;
&lt;input name="optEmail" type="hidden" value="1952281585@qq.com" /&gt;
&lt;input name="payAmount" type="hidden" value="2" /&gt;
&lt;input id="title" name="title" type="hidden" value="支持原创" /&gt;
&lt;input name="memo" type="hidden" value="路过者" /&gt;
&lt;input name="pay" type="image" value="转账"src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" /&gt;&lt;/form&gt;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 21:21:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="wordpress"><![CDATA[WordPress]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>有趣的博客</title>
		<link>http://acmerbar.com/?p=233</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=233</guid>
		<description></description>
		<content:encoded><![CDATA[http://www.brand.site.co.il/riddles/usingyourhead.html

&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>233</wp:post_id>
		<wp:post_date><![CDATA[2015-12-17 14:15:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_oembed_d64acc185a58557caac2acab03ef905d]]></wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个linux命令-locate 命令(13)</title>
		<link>http://acmerbar.com/?p=241</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=241</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>241</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 21:35:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>&lt; 软件工程&gt;期末复习</title>
		<link>http://acmerbar.com/?p=245</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=245</guid>
		<description></description>
		<content:encoded><![CDATA[esdfdsf dsff]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>245</wp:post_id>
		<wp:post_date><![CDATA[2015-12-27 16:55:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>【第二章数组】之最大连续子数组和</title>
		<link>http://acmerbar.com/?p=266</link>
		<pubDate>Mon, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=266</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>最大连续子数组和</h1>
<h2><a id="user-content-题目描述" class="anchor" href="http://taop.marchtea.com/02.04.html#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"></a>题目描述</h2>
输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。

例如输入的数组为 <code> 1, -2, 3, 10, -4, 7, 2, -5 </code> ，和最大的子数组为 <code> 3, 10, -4, 7, 2 </code> ， 因此输出为该子数组的和18。
<h3>O (n)解法</h3>
事实上，当我们令currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，当我们往后扫描时，
<ul>
	<li>对第j+1个元素有两种选择：要么放入前面找到的子数组，要么做为新子数组的第一个元素；
<ul>
	<li>如果currSum加上当前元素a[j]后不小于a[j]，则令currSum加上a[j]，否则currSum重新赋值，置为下一个元素，即currSum = a[j]。</li>
</ul>
</li>
	<li>同时，当currSum &gt; maxSum，则更新maxSum = currSum，否则保持原值，不更新。</li>
</ul>
即
<pre><code>currSum = max(a[j], currSum + a[j])
maxSum = max(maxSum, currSum)
</code></pre>
举个例子，当输入数组是 <code> 1, -2, 3, 10, -4, 7, 2, -5 </code> ，那么，currSum和maxSum相应的变化为：
<ul>
	<li>currSum： 0 1 - 1 3 13 9 16 18 13</li>
	<li>maxSum ： 0 1 1 3 13 13 16 18 18</li>
</ul>
代码：
<pre class="lang:c++ decode:true">int MaxSubArray()
{
    int currSum=0;
    int maxSum=arr[0];
    for(int i=0; i&lt;n; ++i)
    {
        currSum=max(currSum+arr[i],arr[i]);
        maxSum=max(maxSum,currSum);
    }
    return maxSum;
}</pre>
例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4561" target="_blank">HDU 4561 连续最大乘积</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>266</wp:post_id>
		<wp:post_date><![CDATA[2016-01-21 18:27:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《少年啊，前路漫漫》读书笔记II</title>
		<link>http://acmerbar.com/56.html</link>
		<pubDate>Mon, 09 Nov 2015 12:49:13 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=56</guid>
		<description></description>
		<content:encoded><![CDATA[文章“七论”摘抄
<ul>
	<li>罗素在《如何避免愚蠢的见识》里说：“如果你一听到一种与你相左的意见就发怒，这就表明，你已经下意识地感觉到你那种看法没有充分理由。如果某个人硬要说二加二等于五，或者说冰岛位于赤道，你就只会感到怜悯而不是愤怒，除非你自己对数学和地理也是这样无知，因而他的看法竟然动摇了你的相反的见解。所以，不论什么时候，只要发现自己对不同的意见发起火来，你就要小心，因为一经检查，你大概就会发现，你的信念并没有充分证据。”
罗素的这段文字让我反思，是否真有必要跟别人理论。
<u>《相对论》提出的时候，那么多人质疑爱因斯坦，爱因斯坦有一个个跟他们理论吗？达芬奇会给看不懂他画的人讲色彩吗。毕加索会给看不懂他画的人讲线条吗。贝多芬也不会因为你弹不了他的曲就来指导你。</u>
一个人站在山顶，描绘自己所看到的一切，山腰的人说：“你瞎说，我根本就没看到，这世界不是你所说的那样的。”山顶的人再怎么解释对方也不能接受。除非他们自己爬到山顶。爬山的人，不该把时间浪费在跟后面的人争执，自顾自往上爬就是了。有人能跟上你的节奏，就跟，跟不上，你不必把心思浪费在他们身上。</li>
</ul>
有些风景，你爬到一定的高度才看得到，有些道理，你有过一定的阅历、经历才能明白。对方阅历不够，智商太低，你不必弯下腰与对方纠缠。

比如，很多人喜欢讲：“不是一直这样吗？”稍微用心看一下鲁迅先生的作品就会记得，《狂人日记》里有一句：“从来如此，便对吗？”或者稍微研读一下《苏菲的世界》就知道，真理也具有客观性，很容易被当下的历史局限。很多答案都在书里讲得很明白，大家懒得去看而已。或者更惨，看了，却不知道思考。
<ul>
	<li>《苏菲的世界》里几次提到歌德的一句话：“不能汲取三千年历史经验的人没有未来可言。”所谓汲取，不仅仅是阅读，更是思考。许多人都说，他们看了很多书，却没用。这个问题孔圣人早在《论语》里就讲过了：“学而不思则罔，思而不学则殆。”</li>
</ul>
有些人，一天到晚想得太多，不看书，心浮气躁，自以为很懂，其实逻辑错误一大堆，看看书就明白自己有多鼠目寸光。有些人，看了很多书，一天到晚都在看书，却不晓得思考、对比、提炼，看了也是白费，充数字罢了。
要知道，这世上有一群人，他们痴迷于求知，却从无创作。而创作，正是整理思考的最佳途径。许多人懒于思考，只喜欢阅读，跟着作者的思想走。我喜欢博览群书，对比思考，然后整理写下自己的看法，让别人跟着我的思想走。

社交网络是很恐怖的事。大家只在网上发自己的美照、值得炫耀的东西，却从来不揭自己的伤疤。于是很多人觉得，大家都这么好，只有我是不好的，心浮气躁，要跟人家比。更有的，心生嫉妒。
有句话说得好，眼不见为净。心静下来了，才好用心读书，用心写作，用心，往前走。别人的事，我不在乎。我只在乎自己。
社交网络的另一处恐怖在于，从前你只看到你喜欢的东西，现在因为社交分享，你会看到你的朋友可能分享了一些你不喜欢，甚至讨厌的东西。
同样，你所写的东西也有可能被不喜欢这个话题或者不懂这个话题的人看到。于是就发生了些不愉快的事。比如，不专业的疑问、低水准的质疑、不加思考的反诘、自以为是的讽刺、狂妄自大的论断、不切实际的妄想。

&nbsp;
<ul>
	<li>叔本华有一篇文章《要么庸俗，要么孤独》里面说了这么一个意思：你可以选择在原处不停地跟周遭不解的人解释你为何这么做，让他们理解你，你可以选择什么都不讲，自顾自往前走。
生活上，我觉得人人平等，谁都可以做朋友。但思想上，我不需要任何一个朋友来扯我的后腿。我所要学习的，书上都有。几十年前几百年前人们讲得很清楚。死后不足三十年写的东西，无论作品，还是评价，包括我自己的，我都不会看。
你要全天下的人都理解你，赞同你，支持你，我不反对。我不想成为一个庸俗的人。十年百年后，当我们死去，质疑我们的人同样死去，后人看到的是裹足不前、原地打转的你，还是一直奔跑、走到远方的我？
我宁愿孤独。我享受一个人的孤独的状态。一个人的状态永远是最好的。没人打搅，心无旁骛，才好安心做自己真正想做的事。
有时我甚至懒得跟身边的人说话。我不需要与人讨论，我想知道的，我所疑惑的，书里都告诉我了。书看多了，自然明辨是非，知晓对错。有些道理我自己懂就好，不必强行让别人接受，别人不懂没关系，我没必要一个个去说服。</li>
	<li>《白鹿原》里朱先生说：“世间一切佳果珍馐都经不得牙齿的反复咀嚼，咀嚼到后来就连什么味儿也没有了。只有圣贤的书是最耐得咀嚼的，同样一句话，咀嚼一次就有一回新的体味和新的领悟，不仅不觉得味尝已尽反而觉得味道深远。好饭耐不得三顿吃，好衣架不住半月穿，好书却经得住一辈子诵读。”</li>
</ul>
有些书，我看不到一遍就不想再看。有些书，我看了第一遍还看第二遍。

我跟自己说，千万不要追求数量。一本好书，值得看十遍都不为过。要用心看，而不是为了看完赶紧看。里面的句子要用心体味。用心写读书笔记。但凡让我有所思考的，都要记下来，甚至背下来。

人，是越闲越懒的。脑子，是越用越灵活的。

&nbsp;
<ul>
	<li>莫言在《蛙》里说：“写作时要触及心中最痛的地方，要写人生中最不堪回首的记忆，最尴尬的事，最狼狈的境地。要把自己放在解剖台上，放在聚光镜下。”
我对自己说，写吧。过去的事，一字一句写下来，自我解剖。只有敢于面对过去，才能坦然面对未来。十年前有趣的东西，跟十年后有趣的东西完全不同。但坦诚精炼的笔触永不过时。因为它们不是有趣，而是有意义，经得住时间的考验。
毛姆在《月亮和六便士》里说：“作者应该从写作的乐趣中，从那积累在他心里的思想的发泄中取得写书的酬报；对于其他一切都不应该介意，作品成功或失败，受到称誉或是诋毁，他都应该淡然处之。”
从前有人不喜欢我写的东西，指摘我，我就要跳出来反驳。现在我明白了，实在不必介意别人的指责。我写的不好，是水平有限，还在成长，不管这是不是理由，我都无需跟别人解释。我自己知道，以后会努力改善就好。</li>
</ul>
人贵自知。
很多事自己知道就好。不要浪费时间跟别人辩驳。有这时间，去做真正有成效的事。

我知道有人会说《大明宫词》不符合历史。但这正是我喜欢它的原因。在我看来，除了纪实文学，一切照搬历史的文学，都不配称之为创作。好的文学创作，不是单调的现实重构，更是赋予自己的价值观。

&nbsp;

<em><strong>读书感言：</strong></em>
<ul>
	<li>
<blockquote>要健康：早起早睡，多喝水，多吃蔬菜水果，少油腻，少辛辣刺激，不抽烟，少喝酒，保持运动。</blockquote>
</li>
	<li>
<blockquote>要赚钱：钱，从来都不是人的最高追求，但是，无论追求什么，都少不了钱，今早保障稳定的收入来源，今早经济独立，学会理财。</blockquote>
</li>
	<li>
<blockquote>要多读书：大多数人对生活有疑虑，想不通，遇事没主张，总是向别人讨教，犹豫不决，性格懦弱…无非是因为人生历练少，阅历又少，脑子空空，自然六神无主，只有思想更自由更开拓，人生当中，才敢做许多看是不容易的决策。当然，也要时刻记住“学而不思则罔，思而不学则殆”。</blockquote>
</li>
	<li>
<blockquote>要有执行力，自制力，不懒惰，不拖延，三分钟热度的人，等于自欺欺人，永远成不了大事。</blockquote>
</li>
	<li>
<blockquote>遇上喜欢的人，就要勇敢的去追求，大不了被拒绝，别怕；遇不上，也别太寂寞，有时间让自己更优秀。</blockquote>
</li>
	<li>
<blockquote>不要惧怕失败，学会反思，学会反省，从失败中吸取教训和经验。</blockquote>
</li>
	<li>
<blockquote>无论如何，让自己更优秀：想要未来更自由，多读书，多健身，内外兼修，为的是让自己更优秀，提升自身能力，让未来的自己有更多的选择性，不要抱怨，既然知晓自己有不足，就要改进改善，不要懒散，不要混日子，想要未来更好，成为一个更优秀的人。</blockquote>
</li>
	<li>
<blockquote>要对自己的人生负责：成长这一路，不犯错是不可能的，想要少犯错：一：谨言慎行，三思而后行；二：要多读书，脑子里要有思想。</blockquote>
</li>
	<li>
<blockquote>要有自己的生活：人活着，要有自己的生活空间。一天24个小时，总要有完完全全属于自己的时间，做你想做的事。</blockquote>
</li>
	<li>
<blockquote>联系朋友感情</blockquote>
</li>
	<li>
<blockquote>对于那些单纯只给你快感，没有一丝思考价值的东西，都不要上瘾，娱乐至死。</blockquote>
</li>
</ul>
【12】

人与人之间有很多感情。
有些感情会淡掉，
有些感情却永远根深蒂固。
你喜欢一个人，
也许会跟这个人分手，
喜欢上另一个人。
这世上离婚的那么多，
保不准将来你也会碰上。
但生你养你的人，
你的爸爸妈妈，爷爷奶奶，外公外婆。
永远不会变，
他们永远都是生你养你照顾你疼爱你的人。
也许你是领养的，
这不重要，重要的是，
他们的存在与你息息相关。
你一辈子都跟他们脱不了干系。
这是植入骨血的亲密。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>56</wp:post_id>
		<wp:post_date><![CDATA[2015-11-09 20:49:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-09 12:49:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e5%b0%91%e5%b9%b4%e5%95%8a%ef%bc%8c%e5%89%8d%e8%b7%af%e6%bc%ab%e6%bc%ab%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0ii]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<category domain="category" nicename="%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>c语言基于Linux下用libpcap实现抓包程序</title>
		<link>http://acmerbar.com/61.html</link>
		<pubDate>Tue, 10 Nov 2015 03:41:37 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=61</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;
<pre class="font:consolas lang:c++ range:1-125 decode:true ">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pcap.h&gt;
#include &lt;netinet/if_ether.h&gt;
#define IP 2048
#define TCP 6
typedef unsigned char  uint_char;
typedef unsigned short uint_short;
typedef unsigned int   uint_int;
typedef struct ether
{
    uint_char dest[6];//目的地址
    uint_char src[6];//源地址
    uint_short proto;//协议
    uint_char data[0];
} tEther;
typedef struct ip
{
    uint_char hlen;//首部长度+版本
    uint_char tos;//服务
    uint_short len;//总长度
    uint_short ipid;//标示
    uint_short flagoff;//标示加偏移
    uint_char time;//生存时间
    uint_char proto;//协议
    uint_short cksum;//首部检验和
    uint_int src;//源地址
    uint_int dest;//目的地址
    uint_char data[0];//
} tIp;
typedef struct tcp
{
    uint_short sport;
    uint_short dport;
    uint_int seq;
    uint_int ack;
    uint_char hlen;
    uint_char code;
    uint_short window;
    uint_short chsum;
    uint_short urg;
    char data[0];

} tTcp;
void proc_pkt (u_char * user,const struct pcap_pkthdr *hp,const u_char * packet)
{
    tEther *pEther;
    tIp *pIp;
    pEther = (tEther *) packet;
    if(ntohs(pEther-&gt;proto)==IP) //网络层的报头为IP
    {
        pIp = (tIp *) pEther -&gt;data;
        if(pIp -&gt; proto == TCP)    //传输层的报头为tcp
        {
            tTcp *pTcp;
            pTcp= (tTcp *) pIp-&gt; data;
            printf("dest mac address:");
            for(i=0; i&lt;6; ++i)
            {
                if(pEther-&gt;dest[i]&lt;16) printf("0");
                printf("%x ",pEther -&gt;dest[i]);

            }
            printf("\n");
            printf("src  mac address:");
            for(i=0; i&lt;6; ++i)
            {
                if(pEther-&gt;src[i]&lt;16) printf("0");
                printf("%x ",pEther -&gt;src[i]);

            }
            printf("\n");
            printf("src ip address:");
            net_host(pIp-&gt;src);

            printf("dest ip address");
            net_host(pIp-&gt;dest);

            printf("src port address: %hu\n", ntohs(pTcp-&gt;sport));
            printf("dest port address: %hu\n",ntohs(pTcp-&gt;dport));
        }
    }
    return ;
}
void net_host (uint_int ip_mask)//将网络字节的ip 地址以及网络掩码转化

{
    uint_int one,two,three,four;
    one = ip_mask;
    one&gt;&gt;=24;
    two = ip_mask;
    two = (two&gt;&gt;16)&amp;0xff;
    three = ip_mask;
    three=(three&gt;&gt;8)&amp;0xff;
    four = ip_mask;
    four&amp;=0xff;
    printf ("%u. %u. %u. %u\n",four,three,two,one);

}
int main()
{
    char *dev = NULL;
    pcap_t *descr;
    struct pcap_pkthdr hdr;
    u_char *packet;
    char errbuf[PCAP_ERRBUF_SIZE];
    int promisc = 0,cnt = 5;
    int pcap_time_out = 100;
    struct tEther *pEpkt;
    uint_int net,mask;
    dev = pcap_lookupdev(errbuf);
    pcap_lookupnet (dev,&amp;net,&amp;mask,errbuf);
    descr = pcap_open_live(dev,BUFSIZ,promisc,pcap_time_out,errbuf);
    printf("net is :");
    net_host(net);
    printf("mask is :");
    net_host(mask);
    printf("\n");
    pcap_loop (descr,-1,proc_pkt,NULL);
    printf("%s\n",dev);
    return 0;
}</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>61</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 11:41:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 03:41:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[c%e8%af%ad%e8%a8%80%e5%9f%ba%e4%ba%8elinux%e4%b8%8b%e7%94%a8libpcap%e5%ae%9e%e7%8e%b0%e6%8a%93%e5%8c%85%e7%a8%8b%e5%ba%8f-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[17]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>wordpress代码高亮插件Crayon Syntax Highlighter使用教程</title>
		<link>http://acmerbar.com/63.html</link>
		<pubDate>Tue, 10 Nov 2015 04:30:03 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=63</guid>
		<description></description>
		<content:encoded><![CDATA[必须给赞啊。插件效果太强了，推荐使用！

如何安装？

在wp后台安装插件处，搜索Crayon Syntax Highlighter插件，你会看到一个满分的该插件，直接安装即可，wp会帮你下载并解压安装的。

如何设置？

在wp后台右边菜单栏 设置-&gt;Crayon 中，又该插件的详细设置选项。不懂的选项大家可以多试试。

如何使用？

使用方法与SyntaxHighlighter 类似，同样是在html编辑模式下，使用该类语言的标签，比如你的代码是C++，

[C++]

your code

[/C++]（只是个例子）

代码效果：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/33333333333.png"><img class="aligncenter size-medium wp-image-64" src="http://acmerbar.com/wp-content/uploads/2015/11/33333333333-300x168.png" alt="" width="300" height="168" /></a>

使用可视化模式下的工具吧，安装完Crayon后，可视化编辑第一行菜单最后一个是该插件的选项，你可以点击它，直接拷贝你想高亮的代码进入就可以了，效果如下图所示，可视化编辑，更方便了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>63</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 12:30:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 04:30:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[wordpress%e4%bb%a3%e7%a0%81%e9%ab%98%e4%ba%ae%e6%8f%92%e4%bb%b6crayon-syntax-highlighter%e4%bd%bf%e7%94%a8%e6%95%99%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<category domain="category" nicename="programming-language"><![CDATA[编程语言]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux &quot;echo&quot;命令</title>
		<link>http://acmerbar.com/67.html</link>
		<pubDate>Tue, 10 Nov 2015 05:21:26 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=67</guid>
		<description></description>
		<content:encoded><![CDATA[<h2 class="aTitle">Linux中的15个‘echo’ 命令实例：<a href="http://www.linuxidc.com/Linux/2014-10/107550.htm" target="_blank">click here~~</a></h2>
<div>

echo命令的语法是：
<ol class="linenums">
	<li class="L0"><span class="pln">echo </span><span class="pun">[选项]</span><span class="pun">[字符串]</span></li>
</ol>
<h4 id="toc_1"><strong>1.</strong> 输入一行文本并显示在标准输出上</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span></li>
</ol>
会输出下面的文本:
<ol class="linenums">
	<li class="L0"><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span></li>
</ol>
<h4 id="toc_2"><strong>2.</strong> 输出一个声明的变量值</h4>
比如，声明变量<strong>x</strong>并给它赋值为<strong>10</strong>。
<ol class="linenums">
	<li class="L0"><span class="pln">$ x</span><span class="pun">=</span><span class="lit">10</span></li>
</ol>
会输出它的值：
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="typ">The</span><span class="pln"> value of variable x </span><span class="pun">=</span><span class="pln"> $x</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">The</span><span class="pln"> value of variable x </span><span class="pun">=</span><span class="lit">10</span></li>
</ol>
<h4 id="toc_3"><strong>3.</strong> 使用‘<strong>\b</strong>‘选项</h4>
‘<strong>-e</strong>‘后带上'\b'会删除字符间的所有空格。

<strong>注意：</strong> Linux中的选项‘<strong>-e</strong>‘扮演了转义字符反斜线的翻译器。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint \bis \ba \bcommunity \bof \bLinux \bNerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">TecmintisacommunityofLinuxNerds</span></li>
</ol>
<h4 id="toc_4"><strong>4.</strong> 使用‘<strong>\n</strong>‘选项</h4>
‘<strong>-e</strong>‘后面的带上‘\n’行会在遇到的地方作为新的一行
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint \nis \na \ncommunity \nof \nLinux \nNerds"</span></li>
</ol>
</div>
&nbsp;

<span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span>
<div>
<h4 id="toc_5"><strong>5.</strong> 使用‘<strong>\t</strong>‘选项</h4>
‘<strong>-e</strong>‘后面跟上‘\t’会在空格间加上水平制表符。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint \tis \ta \tcommunity \tof \tLinux \tNerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span></li>
</ol>
<h4 id="toc_6"><strong>6.</strong> 也可以同时使用换行‘<strong>\n</strong>‘与水平制表符‘<strong>\t</strong>‘</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"\n\tTecmint \n\tis \n\ta \n\tcommunity \n\tof \n\tLinux \n\tNerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">Tecmint</span></li>
	<li class="L3"><span class="kwd">is</span></li>
	<li class="L4"><span class="pln">a</span></li>
	<li class="L5"><span class="pln">community</span></li>
	<li class="L6"><span class="pln">of</span></li>
	<li class="L7"><span class="typ">Linux</span></li>
	<li class="L8"><span class="typ">Nerds</span></li>
</ol>
<h4 id="toc_7"><strong>7.</strong> 使用‘<strong>\v</strong>‘选项</h4>
‘<strong>-e</strong>‘后面跟上‘\v’会加上垂直制表符。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"\vTecmint \vis \va \vcommunity \vof \vLinux \vNerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">Tecmint</span></li>
	<li class="L3"><span class="kwd">is</span></li>
	<li class="L4"><span class="pln">a</span></li>
	<li class="L5"><span class="pln">community</span></li>
	<li class="L6"><span class="pln">of</span></li>
	<li class="L7"><span class="typ">Linux</span></li>
	<li class="L8"><span class="typ">Nerds</span></li>
</ol>
<h4 id="toc_8"><strong>8.</strong> 也可以同时使用换行‘<strong>\n</strong>‘与垂直制表符‘<strong>\v</strong>‘</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"\n\vTecmint \n\vis \n\va \n\vcommunity \n\vof \n\vLinux \n\vNerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="pln"> </span></li>
	<li class="L3"><span class="typ">Tecmint</span></li>
	<li class="L4"><span class="pln"> </span></li>
	<li class="L5"><span class="kwd">is</span></li>
	<li class="L6"><span class="pln"> </span></li>
	<li class="L7"><span class="pln">a</span></li>
	<li class="L8"><span class="pln"> </span></li>
	<li class="L9"><span class="pln">community</span></li>
	<li class="L0"><span class="pln"> </span></li>
	<li class="L1"><span class="pln">of</span></li>
	<li class="L2"><span class="pln"> </span></li>
	<li class="L3"><span class="typ">Linux</span></li>
	<li class="L4"><span class="pln"> </span></li>
	<li class="L5"><span class="typ">Nerds</span></li>
</ol>
<strong>注意：</strong> 你可以按照你的需求连续使用两个或者多个垂直制表符，水平制表符与换行符。
<h4 id="toc_9"><strong>9.</strong> 使用‘<strong>\r</strong>‘选项</h4>
‘<strong>-e</strong>‘后面跟上‘\r’来指定输出中的回车符。（LCTT 译注：会覆写行开头的字符）
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint \ris a community of Linux Nerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span></li>
</ol>
<h4 id="toc_10"><strong>10.</strong> 使用‘<strong>\c</strong>‘选项</h4>
‘<strong>-e</strong>‘后面跟上‘\c’会抑制输出后面的字符并且最后不会换新行。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint is a community \cof Linux Nerds"</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community </span><span class="lit">@tecmint</span><span class="pun">:~</span><span class="pln">$</span></li>
</ol>
<h4 id="toc_11"><strong>11.</strong> ‘<strong>-n</strong>‘会在echo完后不会输出新行</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">n </span><span class="str">"Tecmint is a community of Linux Nerds"</span></li>
	<li class="L1"><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds@tecmint</span><span class="pun">:~/</span><span class="typ">Documents$</span></li>
</ol>
<h4 id="toc_12"><strong>12.</strong> 使用‘<strong>\a</strong>‘选项</h4>
‘<strong>-e</strong>‘后面跟上‘\a’选项会听到声音警告。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"Tecmint is a community of \aLinux Nerds"</span></li>
	<li class="L1"><span class="typ">Tecmint</span><span class="kwd">is</span><span class="pln"> a community of </span><span class="typ">Linux</span><span class="typ">Nerds</span></li>
</ol>
<strong>注意：</strong> 在你开始前，请先检查你的音量设置。
<h4 id="toc_13"><strong>13.</strong> 使用echo命令打印所有的文件和文件夹（ls命令的替代）</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">*</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="lit">103.odt</span><span class="lit">103.pdf</span><span class="lit">104.odt</span><span class="lit">104.pdf</span><span class="lit">105.odt</span><span class="lit">105.pdf</span><span class="lit">106.odt</span><span class="lit">106.pdf</span><span class="lit">107.odt</span><span class="lit">107.pdf</span><span class="lit">108a</span><span class="pun">.</span><span class="pln">odt </span><span class="lit">108.odt</span><span class="lit">108.pdf</span><span class="lit">109.odt</span><span class="lit">109.pdf</span><span class="lit">110b</span><span class="pun">.</span><span class="pln">odt </span><span class="lit">110.odt</span><span class="lit">110.pdf</span><span class="lit">111.odt</span><span class="lit">111.pdf</span><span class="lit">112.odt</span><span class="lit">112.pdf</span><span class="lit">113.odt</span><span class="pln"> linux</span><span class="pun">-</span><span class="pln">headers</span><span class="pun">-</span><span class="lit">3.16</span><span class="pun">.</span><span class="lit">0</span><span class="pun">-</span><span class="pln">customkernel_1_amd64</span><span class="pun">.</span><span class="pln">deb linux</span><span class="pun">-</span><span class="pln">image</span><span class="pun">-</span><span class="lit">3.16</span><span class="pun">.</span><span class="lit">0</span><span class="pun">-</span><span class="pln">customkernel_1_amd64</span><span class="pun">.</span><span class="pln">deb network</span><span class="pun">.</span><span class="pln">jpeg</span></li>
</ol>
<h4 id="toc_14"><strong>14.</strong> 打印制定的文件类型</h4>
比如，让我们假设你想要打印所有的‘<strong>.jpeg</strong>‘文件，使用下面的命令。
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="pun">*.</span><span class="pln">jpeg</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="pln">network</span><span class="pun">.</span><span class="pln">jpeg</span></li>
</ol>
<h4 id="toc_15"><strong>15.</strong> echo可以使用重定向符来输出到一个文件而不是标准输出</h4>
<ol class="linenums">
	<li class="L0"><span class="pln">$ echo </span><span class="str">"Test Page"</span><span class="pun">&gt;</span><span class="pln"> testpage</span></li>
	<li class="L1"><span class="pln"> </span></li>
	<li class="L2"><span class="com">## Check Content</span></li>
	<li class="L3"><span class="pln">avi@tecmint</span><span class="pun">:~</span><span class="pln">$ cat testpage</span></li>
	<li class="L4"><span class="typ">Test</span><span class="typ">Page</span></li>
</ol>
<h4 id="toc_16">echo 选项列表</h4>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td align="left" height="16"><strong>选项</strong></td>
<td align="left"><strong>描述</strong></td>
</tr>
<tr>
<td align="left" height="16"><strong>-n</strong></td>
<td align="left">不输出末尾的换行符。</td>
</tr>
<tr>
<td align="left" height="16"><strong>-e</strong></td>
<td align="left">启用反斜线转义。</td>
</tr>
<tr>
<td align="left" height="16"><strong>\b</strong></td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left" height="16"><strong>\\</strong></td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left" height="16"><strong>\n</strong></td>
<td align="left">新行</td>
</tr>
<tr>
<td align="left" height="16"><strong>\r</strong></td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left" height="16"><strong>\t</strong></td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left" height="16"><strong>\v</strong></td>
<td align="left">垂直制表符</td>
</tr>
</tbody>
</table>
<h2 class="aTitle">Echo命令实例：<a href="http://www.linuxidc.com/Linux/2014-08/105548.htm" target="_blank">click here~~</a></h2>
<div><strong>值得记录的是改变字体颜色：</strong></div>
<div>
<h4 id="toc_9">样例： 设置echo命令彩色输出</h4>
echo命令可以修改字体类型，字体背景色以及字体颜色，转义序列\033可以用于改变字体属性。要使转义序列生效，必须使用-e选项。下面列出了部分转义代码：
<ul>
	<li>[0m: 正常</li>
	<li>[1m: 粗体</li>
	<li>[4m: 字体加上下划线</li>
	<li>[7m: 逆转前景和背景色</li>
	<li>[8m: 不可见字符</li>
	<li>[9m: 跨行字体</li>
	<li>[30m: 灰色字体</li>
	<li>[31m: 红色字体</li>
	<li>[32m: 绿色字体</li>
	<li>[33m: 棕色字体</li>
	<li>[34m: 蓝色字体</li>
	<li>[35m: 紫色字体</li>
	<li>[36m: 浅蓝色字体</li>
	<li>[37m: 浅灰字体</li>
	<li>[38m: 黑色字体</li>
	<li>[40m: 黑色背景</li>
	<li>[41m: 红色背景</li>
	<li>[42m: 绿色背景</li>
	<li>[43m: 棕色背景</li>
	<li>[44m: 蓝色背景</li>
	<li>[45m: 紫色背景</li>
	<li>[46m: 浅蓝色背景</li>
	<li>[47m: 浅灰色背景</li>
</ul>
下面的命令将用红色打印输出。
<ol class="linenums">
	<li class="L0"><span class="pln">jack@nextstep4it</span><span class="pun">:~</span><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"\033[31mMagic of Linux\033[0m"</span></li>
	<li class="L1"><span class="typ">Magic</span><span class="pln"> of </span><span class="typ">Linux</span></li>
</ol>
下面的命令将以粗体以及红色背景打印出“Magic of Linux”。
<ol class="linenums">
	<li class="L0"><span class="pln">nextstep4it@nextstep4it</span><span class="pun">:~</span><span class="pln">$ echo </span><span class="pun">-</span><span class="pln">e </span><span class="str">"\033[1m\033[41mMagic of Linux\033[0m"</span></li>
	<li class="L1"><span class="typ">Magic</span><span class="pln"> of </span><span class="typ">Linux</span></li>
</ol>
</div>
实例：<img src="http://img.blog.csdn.net/20150713163237074" alt="" />
<h2 class="aTitle">shell 下使用 echo 打印彩色字体及彩色背景：<a href="http://www.linuxidc.com/Linux/2014-07/104776.htm" target="_blank">click here~~</a></h2>
<div>

首先知道shell中终端打印有echo printf一般常用的就是echo咯；

注：字体颜色 重置=0，黑色=30，红色=31，绿色=32， ***=33，蓝色=34， 洋红=35， 青色=36， 白色=37.

背景颜色 重置=0，黑色=40，红色=41，绿色=42， ***=43，蓝色=44， 洋红=45， 青色=46， 白色=47.

要打印彩色文本，可输入如下命令：

# echo -e "\e[1;36m \e[0m"

\e[1;36 将颜色设置为青色 \e[0将颜色重新置回。4如果想要别的颜色只需要把36替换成其他颜色对应的数字就行；

要设置彩色背景，可输入如下命令：

# echo -e "\e[1;41m \e[0m"

剩下的自己去研究吧！

<a title="Ubuntu" href="http://www.linuxidc.com/topicnews.aspx?tid=2" target="_blank">Ubuntu</a> 14.04右键终端的设置 <a href="http://www.linuxidc.com/Linux/2014-04/100498.htm" target="_blank">http://www.linuxidc.com/Linux/2014-04/100498.htm</a>

Linux下多窗口分屏式终端--Terminator <a href="http://www.linuxidc.com/Linux/2014-03/98484.htm" target="_blank">http://www.linuxidc.com/Linux/2014-03/98484.htm</a>

如何修改ssh命令行下登录时的颜色 <a href="http://www.linuxidc.com/Linux/2013-06/86066.htm" target="_blank">http://www.linuxidc.com/Linux/2013-06/86066.htm</a>

Ubuntu下使用ls命令显示文件颜色相关内容及修改 <a href="http://www.linuxidc.com/Linux/2013-03/81033.htm" target="_blank">http://www.linuxidc.com/Linux/2013-03/81033.htm</a>

<a href="http://acmerbar.com/wp-content/uploads/2015/11/3086823431.jpg"><img class="aligncenter size-full wp-image-68" src="http://acmerbar.com/wp-content/uploads/2015/11/3086823431.jpg" alt="" width="468" height="279" /></a>

</div>
</div>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>67</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 13:21:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 05:21:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux-echo%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令(1)：ls命令</title>
		<link>http://acmerbar.com/70.html</link>
		<pubDate>Tue, 10 Nov 2015 09:46:18 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=70</guid>
		<description></description>
		<content:encoded><![CDATA[每天一个linux命令(1)：ls命令 -

文章链接：<a href="http://acmerbar.com/70.html" target="_blank">http://acmerbar.com/70.html</a>

原文转载：<a href="http://www.cnblogs.com/peida/archive/2012/10/23/2734829.html" target="_blank">http://www.cnblogs.com/peida/archive/2012/10/23/2734829.html</a>

ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!
<ol>
	<li><b></b><b>命令格式：</b></li>
</ol>
ls [选项] [目录名]
<ol start="2">
	<li><b></b><b>命令功能：</b></li>
</ol>
列出目标目录中所有的子目录和文件。
<ol start="3">
	<li><b></b><b>常用参数：</b></li>
</ol>
-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件

-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。

-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序

-C 每栏由上至下列出项目

–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一

-d, –directory 将目录象文件一样显示，而不是显示其下的文件。

-D, –dired 产生适合 Emacs 的 dired 模式使用的结果

-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效

-g 类似 -l,但不列出所有者

-G, –no-group 不列出任何有关组的信息

-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)

–si 类似 -h,但文件大小取 1000 的次方而不是 1024

-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地

–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)

-i, –inode 印出每个文件的 inode 号

-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目

-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。

-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。

-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息

-m 所有项目以逗号分隔，并填满整行行宽

-o 类似 -l,显示文件的除组信息外的详细信息。

-r, –reverse 依相反次序排列

-R, –recursive 同时列出所有子目录层

-s, –size 以块大小为单位列出所有文件的大小

-S 根据文件大小排序

–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：

extension -X status -c

none -U time -t

size -S atime -u

time -t access -u

version -v use -u

-t 以文件修改时间排序

-u 配合 -lt:显示访问时间而且依访问时间排序

配合 -l:显示访问时间但根据名称排序

否则：根据访问时间排序

-U 不进行排序;依文件系统原有的次序列出项目

-v 根据版本进行排序

-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值

-x 逐行列出项目而不是逐栏列出

-X 根据扩展名排序

-1 每行只列出一个文件

–help 显示此帮助信息并离开

–version 显示版本信息并离开
<ol start="4">
	<li><b></b><b>常用范例：</b></li>
</ol>
<b>例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料</b>

<b>命令</b>：ls -l -R /home/peidachang

在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/peidachang”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/peidachang”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示：

<b>命令</b>：ls -lR /home/peidachang

这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是peidachang文件夹，我想对home文件夹下的peidachang文件进行操作，我可以直接输入 ls -lR peidachang，也可以用 ls -lR /home/peidachang。

<b>例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</b>

<b>命令</b>：ls -l t*

可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。

<b>例三：</b><b>只列出</b><b>文件下的</b><b>子目录</b>

<b>命令：</b>ls -F /opt/soft |grep /$

列出 /opt/soft 文件下面的子目录

<b>输出</b>：

[root@localhost opt]# ls -F /opt/soft |grep /$

jdk1.6.0_16/

subversion-1.6.1/

tomcat6.0.32/

<strong>命令</strong>：ls -l /opt/soft | grep "^d"

列出 /opt/soft 文件下面的子目录详细情况

<strong>输出</strong>：

[root@localhost opt]#  ls -l /opt/soft | grep "^d"

drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16

drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1

drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32

<b>例四</b>：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：

<b>命令</b>：ls -ltr s*

<strong>输出</strong>：

[root@localhost opt]# ls -ltr s*

src:

总计 0

script:

总计 0

soft:

总计 350644

drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32

-rwxr-xr-x  1 root root  81871260 09-17 18:15 jdk-6u16-linux-x64.bin

drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16

-rw-r--r--  1 root root 205831281 09-17 18:33 apache-tomcat-6.0.32.tar.gz

-rw-r--r--  1 root root   5457684 09-21 00:23 tomcat6.0.32.tar.gz

-rw-r--r--  1 root root   4726179 10-10 11:08 subversion-deps-1.6.1.tar.gz

-rw-r--r--  1 root root   7501026 10-10 11:08 subversion-1.6.1.tar.gz

drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1

<strong>例五：列出目前工作目录下所有档案及目录;目录于名称后加"/", 可执行档于名称后加"*" </strong>

<strong>命令</strong>：ls -AF

<strong>输出</strong>：

[root@localhost opt]# ls -AF

log/  script/  soft/  src/  svndata/  web/

<b>例六：</b><b>计算当前目录下的文件数和目录数</b>

<b>命令：</b>

ls -l * |grep "^-"|wc -l ---文件个数

ls -l * |grep "^d"|wc -l    ---目录个数

<b>例七: 在ls中列出文件的绝对路径</b>

<b>命令</b>：ls | sed "s:^:`pwd`/:"

<strong>输出</strong>：

[root@localhost opt]# ls | sed "s:^:`pwd`/:"

/opt/log

/opt/script

/opt/soft

/opt/src

/opt/svndata

/opt/web

<b>例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</b>

<b>命令</b>：find $PWD -maxdepth 1 | xargs ls -ld

<b>输出</b>：

[root@localhost opt]# find $PWD -maxdepth 1 | xargs ls -ld

drwxr-xr-x 8 root root 4096 10-11 03:43 /opt

drwxr-xr-x 2 root root 4096 2012-03-08 /opt/log

drwxr-xr-x 2 root root 4096 2012-03-08 /opt/script

drwxr-xr-x 5 root root 4096 10-11 03:21 /opt/soft

drwxr-xr-x 2 root root 4096 2012-03-08 /opt/src

drwxr-xr-x 4 root root 4096 10-11 05:22 /opt/svndata

drwxr-xr-x 4 root root 4096 10-09 00:45 /opt/web

<b>例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径</b>

<b>命令</b>： find $PWD | xargs ls -ld

<b>例十一：指定文件时间输出格式</b>

<b>命令：</b>

<b>ls -tl --time-style=full-iso</b>

<b>输出：</b>

[root@localhost soft]# ls -tl --time-style=full-iso

总计 350644

drwxr-xr-x 16 1016 1016 4096 2012-10-11 03:25:58.000000000 +0800 subversion-1.6.1

<b>ls -ctl --time-style=long-iso</b>

<b>输出</b>：

[root@localhost soft]# ls -ctl --time-style=long-iso

总计 350644

drwxr-xr-x 16 1016 1016      4096 2012-10-11 03:25 subversion-1.6.1

<b>扩展：</b>
<ol>
	<li><b>显示彩色目录列表</b></li>
</ol>
打开/etc/bashrc, 加入如下一行:

alias ls="ls --color"

下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:
<ol>
	<li>蓝色--&gt;目录</li>
	<li>绿色--&gt;可执行文件</li>
	<li>红色--&gt;压缩文件</li>
	<li>浅蓝色--&gt;链接文件</li>
	<li>灰色--&gt;其他文件</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>70</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 17:46:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 09:46:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a41%ef%bc%9als%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令(2)：cd命令</title>
		<link>http://acmerbar.com/71.html</link>
		<pubDate>Tue, 10 Nov 2015 09:53:48 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=71</guid>
		<description></description>
		<content:encoded><![CDATA[每天一个linux命令(2)：cd命令 -

文章链接：<a href="http://acmerbar.com/71.html" target="_blank">http://acmerbar.com/71.html</a>

原文转载：<a href="http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html" target="_blank">http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html</a>

Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。

所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。
<ol>
	<li>命令格式：</li>
</ol>
cd [目录名]
<ol start="2">
	<li>命令功能：</li>
</ol>
切换当前目录至dirName
<ol start="3">
	<li>常用范例</li>
</ol>
3.1 例一：进入系统根目录

命令：

cd /

输出：

[root@localhost ~]# cd /

说明：进入系统根目录,上面命令执行完后拿ls命令看一下，当前目录已经到系统根目录了

命令：

cd .. 或者 cd .. //

输出:
<div id="home">
<div id="main">
<div id="mainContent">
<div class="forFlow">
<div id="post_detail">
<div id="topics">
<div class="post">
<div class="postBody">
<div id="cnblogs_post_body">
<div class="cnblogs_code">1 [root@localhost soft]# pwd
2 /opt/soft
3 [root@localhost soft]# cd ..
4 [root@localhost opt]# cd ..//
5 [root@localhost /]# pwd
6 /
说明：

进入系统根目录可以使用“ cd .. ”一直退，就可以到达根目录

命令：

cd ../.. //

输出：
<div id="home">
<div id="main">
<div id="mainContent">
<div class="forFlow">
<div id="post_detail">
<div id="topics">
<div class="post">
<div class="postBody">
<div id="cnblogs_post_body">
<div class="cnblogs_code">
<div>[root@localhost soft]# pwd
2 /opt/soft
3 [root@localhost soft]# cd ../.. //
4 [root@localhost /]# pwd
5 /
6 [root@localhost /]#</div>
</div>
</div>
</div>
</div>
</div>
<div></div>
<div id="topics">
<div class="post">

说明：使用cd 命令实现进入当前目录的父目录的父目录。

例2：使用 cd 命令进入当前用户主目录

“当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。

命令1：

cd

输出：
<div id="home">
<div id="main">
<div id="mainContent">
<div class="forFlow">
<div id="post_detail">
<div id="topics">
<div class="post">
<div class="postBody">
<div id="cnblogs_post_body">
<div class="cnblogs_code">[root@localhost soft]# pwd
2 /opt/soft
3 [root@localhost soft]# cd
4 [root@localhost ~]# pwd
5 /root</div>
</div>
<div class="cnblogs_code"></div>
</div>
</div>
</div>
<div class="cnblogs_code">命令： cd ~</div>
<div class="cnblogs_code"><script src="http://common.cnblogs.com/script/encoder.js" type="text/javascript"></script><script src="http://pagead2.googlesyndication.com/pub-config/ca-pub-4210569241504288.js" async="" type="text/javascript"></script><script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script><script type="text/javascript">// <![CDATA[
var currentBlogApp = 'peida', cb_enable_mathjax=false;
// ]]]]><![CDATA[></script><script src="/bundles/blog-common.js?v=PlJ9KQtkGa_ccgZxU9Fon-EDNUyrm0y3GKrHRkjy4p81" type="text/javascript"></script>
<div id="home">
<div id="main">
<div id="mainContent">
<div class="forFlow">
<div id="post_detail">
<div id="topics">
<div class="post">
<div class="postBody">
<div id="cnblogs_post_body">
<div class="cnblogs_code">　[root@localhost ~]# cd /opt/soft/
2 　　[root@localhost soft]# pwd
3 　　/opt/soft
4 　　[root@localhost soft]# cd ~
5 　　[root@localhost ~]# pwd
6 　　/root</div>
</div>
<div class="cnblogs_code">

例3：跳转到指定目录

命令：

cd /opt/soft

输出：

1 [root@localhost ~]# cd /opt/soft
2 [root@localhost soft]# pwd
3 /opt/soft
4 [root@localhost soft]# cd jdk1.6.0_16/
5 [root@localhost jdk1.6.0_16]# pwd
6 /opt/soft/jdk1.6.0_16
7 [root@localhost jdk1.6.0_16]#

说明：

跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可

例四：返回进入此目录之前所在的目录

命令：

cd -

输出：

1 [root@localhost soft]# pwd
2 /opt/soft
3 [root@localhost soft]# cd -
4 /root
5 [root@localhost ~]# pwd
6 /root
7 [root@localhost ~]# cd -
8 /opt/soft
9 [root@localhost soft]#

例五：把上个命令的参数作为cd参数使用。

命令：

cd !$

输出：

1 [root@localhost soft]# cd !$
2 cd -
3 /root
4 [root@localhost ~]# cd !$
5 cd -
6 /opt/soft
7 [root@localhost soft]#

</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>71</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 17:53:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 09:53:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a42%ef%bc%9acd%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[15]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令（3）：pwd命令</title>
		<link>http://acmerbar.com/72.html</link>
		<pubDate>Tue, 10 Nov 2015 09:56:37 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=72</guid>
		<description></description>
		<content:encoded><![CDATA[每天一个linux命令（3）：pwd命令 -

文章链接：<a href="http://acmerbar.com/72.html" target="_blank">http://acmerbar.com/72.html </a>

原文转载：<a href="http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html" target="_blank">http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html</a>

Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。

在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。

每天一个linux命令（3）：pwd命令 - peida - 博客园

<b>1．</b><b>命令格式：</b>

pwd [选项]

<b>2．</b><b>命令功能：</b>

查看”当前工作目录“的完整路径

<b>3．</b><b>常用参数：</b>

一般情况下不带任何参数

如果目录是链接时：

格式：pwd -P  显示出实际路径，而非使用连接（link）路径。

<b>4．</b><b>常用实例：</b>

<b>       实例</b><b>1：</b><b>用 pwd 命令查看默认工作目录的完整路径</b>

命令：

pwd

输出：

[root@localhost ~]# pwd

/root

[root@localhost ~]#

&nbsp;

<b>实例2：</b><b>使用 pwd 命令查看指定文件夹</b>

<b>命令：</b>

pwd

<b>输出：</b>

[root@localhost ~]# cd /opt/soft/

[root@localhost soft]# pwd

/opt/soft

[root@localhost soft]#

&nbsp;

<b> 实例三：</b>目录连接链接时，pwd -P  显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径

<b>命令：</b>

pwd -P

<b>输出：</b>

[root@localhost soft]# cd /etc/init.d

[root@localhost init.d]# pwd

/etc/init.d

[root@localhost init.d]# pwd -P

/etc/rc.d/init.d

[root@localhost init.d]#

<b> 实例</b>4：/bin/pwd

<b>命令：</b>

/bin/pwd [选项]

选项：

-L 目录连接链接时，输出连接路径

-P 输出物理路径

<b>输出：</b>

[root@localhost init.d]# /bin/pwd

/etc/rc.d/init.d

[root@localhost init.d]# /bin/pwd --help

[root@localhost init.d]# /bin/pwd -P

/etc/rc.d/init.d

[root@localhost init.d]# /bin/pwd -L

/etc/init.d

[root@localhost init.d]#

<b> 实例五：当前目录被删除了，而</b>pwd命令仍然显示那个目录

<b> 输出：</b>

[root@localhost init.d]# cd /opt/soft

[root@localhost soft]# mkdir removed

[root@localhost soft]# cd removed/

[root@localhost removed]# pwd

/opt/soft/removed

[root@localhost removed]# rm ../removed -rf

[root@localhost removed]# pwd

/opt/soft/removed

[root@localhost removed]# /bin/pwd

/bin/pwd: couldn't find directory entry in “..” with matching i-node

[root@localhost removed]# cd

[root@localhost ~]# pwd

/root

[root@localhost ~]#]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 17:56:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 09:56:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4%ef%bc%883%ef%bc%89%ef%bc%9apwd%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令（4）：mkdir命令</title>
		<link>http://acmerbar.com/73.html</link>
		<pubDate>Tue, 10 Nov 2015 10:00:09 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=73</guid>
		<description></description>
		<content:encoded><![CDATA[每天一个linux命令（4）：mkdir命令 -

文章链接：<a href="http://acmerbar.com/73.html" target="_blank">http://acmerbar.com/73.html</a>

原文转载：<a href="http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html" target="_blank">http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html</a>

linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。

<b>1．</b><b>命令格式：</b>

mkdir [选项] 目录...

<b>2．</b><b>命令功能：</b>

通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。

<b>3．</b><b>命令参数：</b>

-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask

-p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;

-v, --verbose  每次创建新目录都显示信息

--help   显示此帮助信息并退出

--version  输出版本信息并退出

每天一个linux命令（4）：mkdir命令 - peida - 博客园

<b>4．</b><b>命令实例：</b>

实例1：创建一个空目录

命令：

mkdir test1

输出：

[root@localhost soft]# cd test

[root@localhost test]# mkdir test1

[root@localhost test]# ll

总计 4drwxr-xr-x 2 root root 4096 10-25 17:42 test1

[root@localhost test]#

实例2：递归创建多个目录

命令：

mkdir -p test2/test22

输出：

[root@localhost test]# mkdir -p test2/test22

[root@localhost test]# ll

总计 8drwxr-xr-x 2 root root 4096 10-25 17:42 test1

drwxr-xr-x 3 root root 4096 10-25 17:44 test2

[root@localhost test]# cd test2/

[root@localhost test2]# ll

总计 4drwxr-xr-x 2 root root 4096 10-25 17:44 test22

[root@localhost test2]#

实例3：创建权限为777的目录

命令：

mkdir -m 777 test3

输出：

[root@localhost test]# mkdir -m 777 test3

[root@localhost test]# ll

总计 12drwxr-xr-x 2 root root 4096 10-25 17:42 test1

drwxr-xr-x 3 root root 4096 10-25 17:44 test2

drwxrwxrwx 2 root root 4096 10-25 17:46 test3

[root@localhost test]#

说明：

test3 的权限为rwxrwxrwx

实例4：创建新目录都显示信息

命令：

mkdir -v test4

输出：

[root@localhost test]# mkdir -v test4

mkdir: 已创建目录 “test4”

[root@localhost test]# mkdir -vp test5/test5-1

mkdir: 已创建目录 “test5”

mkdir: 已创建目录 “test5/test5-1”

[root@localhost test]#

实例五：一个命令创建项目的目录结构

参考：http://www.ibm.com/developerworks/cn/aix/library/au-badunixhabits.html

命令：

mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}}

输出：

[root@localhost test]# mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}}

mkdir: 已创建目录 “scf”

mkdir: 已创建目录 “scf/lib”

mkdir: 已创建目录 “scf/bin”

mkdir: 已创建目录 “scf/doc”

mkdir: 已创建目录 “scf/doc/info”

mkdir: 已创建目录 “scf/doc/product”

mkdir: 已创建目录 “scf/logs”

mkdir: 已创建目录 “scf/logs/info”

mkdir: 已创建目录 “scf/logs/product”

mkdir: 已创建目录 “scf/service”

mkdir: 已创建目录 “scf/service/deploy”

mkdir: 已创建目录 “scf/service/deploy/info”

mkdir: 已创建目录 “scf/service/deploy/product”

[root@localhost test]# tree scf/

scf/

|-- bin

|-- doc

|   |-- info

|   `-- product

|-- lib

|-- logs

|   |-- info

|   `-- product

`-- service

`-- deploy

|-- info

`-- product

12 directories, 0 files

[root@localhost test]#]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>73</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 18:00:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 10:00:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4%ef%bc%884%ef%bc%89%ef%bc%9amkdir%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>【Linux学习笔记】之常用操作命令</title>
		<link>http://acmerbar.com/74.html</link>
		<pubDate>Tue, 10 Nov 2015 11:57:40 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=74</guid>
		<description></description>
		<content:encoded><![CDATA[Linux常用操作命令：

在Linux操作系统下文本显示处理的命令主要有
<blockquote>cat,more，less,head,tail,sort,uniq,cut,comm,diff</blockquote>
文本和命令查找：
<blockquote>grep,find ,locate, whereis ,file ,whatis which</blockquote>
显示系统信息：
<blockquote>unnamed, hostname,dmesg ,cal,date</blockquote>
信息交流命令：
<blockquote>echo,mesg wall, write</blockquote>
&nbsp;

&nbsp;

<span style="color: #ff0000;"><strong>文本显示和处理</strong></span>

【1】cat命令：显示文本文件

【2】more命令：分页显示文本文件

【3】less：回卷显示文本文件

【4】head:显示指定文件前若干行

【5】tail:查看文件末尾数据

【6】sort：对文件中的数据进行排序

【7】uniq:将<u>重复行</u>从输出文件中删除

【8】cut：从文件每行中显示出选定的字节，字符或字段

【9】comm：比较两个已经排过序的文件

【10】diff：逐行比较两个文本文件，列出不同之处

&nbsp;

<span style="color: #ff0000;"><strong>文件和命令查找</strong></span>

【11】grep：查找文件中符合条件的字符串

【12】find:列出文件系统中符合条件的文件或目录

【13】locate:在数据库中查找文件

【14】whereis:查找指定文件，命令和手册页位置

【15】file：查询文件类型

【16】whatis:查询命令功能

【17】which:显示可执行命令的路径

&nbsp;

<span style="color: #ff0000;"><strong>系统显示信息</strong></span>

【18】uname:显示计算机及操作系统及相关信息

【19】hostname:显示或计算机主机名

【20】dmesg:显示计算机开机信息

【21】cal:显示日历信息

【22】date:显示和设置系统日期和时间

&nbsp;

<span style="color: #ff0000;"><strong>信息交流</strong></span>

【23】echo:在显示器上显示文本

【24】mesg:设置其他用户发送信息的权限

【25】wall:对全部已登录的用户发送信息

【26】write:向用户发送信息

&nbsp;

<span style="color: #ff0000;"><strong>其他命令</strong></span>

【27】clear:清除计算机屏幕上信息

【28】sync:将缓冲区内的文件写到硬盘中

【29】uptime:显示系统已经运行的时间

【30】last:显示近期用户登录情况

<strong> </strong>

<span style="color: #ff0000;"><strong>用户组群账户管理命令：</strong></span>

在linux中，主要有root,虚拟用户，普通用户三种。

【31】useradd：在linux系统下创建和修改用户账户

【32】groupadd：创建组群账户

【33】groupmod:修改组群账户

【34】groupdel:删除组群账户

【35】passwd：设置或修改用户的命令

【36】gpasswd:设置一个组群的组群密码，或是在组群中添加，删除用户

【37】chfn：更改用户全名，办公室地址，电话等信息

【38】chsh:更改用户的shell类型

【39】su:切换到其他用户登入

【40】pwck:校验用户配置文件 /etc/passwd 和/etc/shadow 文件内容是否合法和完整

【41】newgrp:让用户账户以另一个组群账户的身份登入

<span style="color: #ff0000;"><strong>账户信息显示</strong></span>

【42】finger:显示账户的信息

【43】groups：显示指定用户账户的组群成员身份

【44】id:显示用户的ID和所属组群GID

【45】w || who:查询已经登入计算机的用户

<span style="color: #ff0000;"><strong>实现账户安全</strong></span>

【46】chage:管理用户口令时效。

&nbsp;

<a href="http://acmerbar.com/wp-content/uploads/2015/11/30868234312.jpg"><img class="aligncenter size-full wp-image-76" src="http://acmerbar.com/wp-content/uploads/2015/11/30868234312.jpg" alt="" width="468" height="279" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>74</wp:post_id>
		<wp:post_date><![CDATA[2015-11-10 19:57:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-10 11:57:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%90linux%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e3%80%91%e4%b9%8b%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Prim&amp;&amp;Kruskal(最小生成树)</title>
		<link>http://acmerbar.com/80.html</link>
		<pubDate>Thu, 12 Nov 2015 08:42:14 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=80</guid>
		<description></description>
		<content:encoded><![CDATA[Prim&amp;&amp;Kruskal(最小生成树)的代码实现

Prim :
<h2 class="para-title level-2"><span class="title-text">算法描述</span></h2>
<div class="para">1).输入：一个加权连通图，其中顶点集合为V，边集合为E；</div>
<div class="para">2).初始化：V<sub>new</sub> = {x}，其中x为集合V中的任一节点（起始点），E<sub>new</sub> = {},为空；</div>
<div class="para">3).重复下列操作，直到V<sub>new</sub> = V：</div>
<div class="para">a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合V<sub>new</sub>中的元素，而v不在V<sub>new</sub><a href="http://baike.baidu.com/subview/15216/10703234.htm" target="_blank">集合</a>当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</div>
<div class="para">b.将v加入集合V<sub>new</sub>中，将&lt;u, v&gt;边加入集合E<sub>new</sub>中；</div>
<div class="para">4).输出：使用集合V<sub>new</sub>和E<sub>new</sub>来描述所得到的<a href="http://baike.baidu.com/view/288214.htm" target="_blank">最小生成树</a>。</div>
<div class="para">
<h2 class="para-title level-2"><span class="title-text">时间复杂度</span></h2>
<table class="wikitable">
<tbody>
<tr>
<th>最小边、权的数据结构</th>
<th>时间复杂度（总计）</th>
</tr>
<tr>
<td><a href="http://baike.baidu.com/view/549589.htm" target="_blank">邻接矩阵</a>、搜索</td>
<td>O(V^2)</td>
</tr>
<tr>
<td><a href="http://baike.baidu.com/view/668854.htm" target="_blank">二叉堆</a>（后文伪代码中使用的数据结构）、<a href="http://baike.baidu.com/view/549594.htm" target="_blank">邻接表</a></td>
<td>O((V + E) log(V)) = O(E log(V))</td>
</tr>
<tr>
<td><a href="http://baike.baidu.com/view/2185995.htm" target="_blank">斐波那契堆</a>、<a href="http://baike.baidu.com/view/549594.htm" target="_blank">邻接表</a></td>
<td>O(E + V log(V))</td>
</tr>
</tbody>
</table>
</div>
Kruskal

算法描述：
<div class="para">克鲁斯卡尔算法</div>
<div class="para">假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造<a href="http://baike.baidu.com/view/288214.htm" target="_blank">最小生成树</a>的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。</div>
<div class="para"></div>
<div class="para">复杂度：</div>
<div class="para">Find函数由边数n决定，加上一个for循环，故复杂度为O(nlogn)。</div>
<div class="para"></div>
<pre class="font:consolas lang:default decode:true">/*prim算法构造最小生成树*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using  namespace std;
const int maxn=1e4;
bool vis[maxn];

int arc[maxn][maxn];
int numvertex,numline;/*顶点，边数*/
const int inf=0x3f3f3f3f;
int adjvex[maxn];/*顶点*/
int lowcost[maxn];/*权值*/
int sum;
void prim()
{
    scanf("%d%d",&amp;numvertex,&amp;numline);
    memset(arc,inf,sizeof(arc));
    for(int i=0; i&lt;numline; ++i)
    {
        int s,u,val;
        scanf("%d%d%d",&amp;s,&amp;u,&amp;val);
        arc[s][u]=arc[u][s]=val;
    }
    memset(vis,0,sizeof(vis));
    sum=0;
    int min,i,j,k;
    adjvex[0]=0;    /*初始化第一个顶点下标为0*/
    for(int i=0; i&lt;numvertex; ++i)
    {
        lowcost[i]=arc[0][i]; /*将v0顶点与之有边的权值存入数组*/
    }
    vis[0]=1;
    for(int i=1; i&lt;numvertex; ++i)
    {
        min=inf;
        k=0;
        for(int j=0; j&lt;numvertex; ++j)   /*循环全部顶点，找最小权值*/
        {
            if(!vis[j]&amp;&amp;lowcost[j]&lt;min)
            {
                min=lowcost[j];
                k=j;
            }
        }
        vis[k]=1;
       // printf("%d %d",adjvex[k],k); /*最小顶点，权值最小边*/
        if(min!=inf) sum+=min;
        for(int j=0; j&lt;numvertex; ++j)/*循环全部顶点*/
        {
            if(!vis[j]&amp;&amp;arc[k][j]&lt;lowcost[j])/*更新下标为k的各边权值*/
            {
                lowcost[j]=arc[k][j];
            }
        }
    }
    printf("%d\n",sum);
}
int main()
{
    freopen("1.txt","r",stdin);
    prim();
    return 0;
}
/*
input
9 15
0 1 10
0 5 11
1 6 16
5 6 17
1 8 12
1 2 18
2 8 8
2 3 22
8 3 21
6 3 24
6 7 19
7 3 16
7 4 7
3 4 20
5 4 26
ouput
99
*/

</pre>
<pre class="font:consolas lang:default decode:true ">/*Kruskal算法构造最小生成树*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn=1e4;
const int inf=0x3f3f3f3f;
bool vis[maxn];

int father[maxn];
int numvertex,numline;/*顶点，边数*/
int adjvex[maxn];/*顶点*/
int lowcost[maxn];/*权值*/
int sum;
struct node{
   int begin;
   int end;
   int weigth;
   bool operator &lt; (const node&amp; t)const{
   return weigth &lt; t.weigth;
   }
}arc[maxn];

int Find(int x){
    if(x==father[x]) return x;
    return Find(father[x]);
}

int Kruskal(){
    for(int i=0; i&lt;maxn; ++i)
        father[i]=i;
    scanf("%d%d",&amp;numvertex,&amp;numline);
    for(int i=0; i&lt;numline; ++i){
        scanf("%d%d%d",&amp;arc[i].begin,&amp;arc[i].end,&amp;arc[i].weigth);
    }
    sort(arc,arc+numline);
    int sum=0;
    for(int i=0; i&lt;numline; ++i){
        int Begin=Find(arc[i].begin);
        int End=Find(arc[i].end);
        if(Begin!=End)//如果两点不在同一连通分量里，则将两点连接，并存储该边
        {
            sum+=arc[i].weigth;
            father[Begin]=End;
        }
    }
    printf("%d\n",sum);
}
int main()
{
    freopen("1.txt","r",stdin);
    Kruskal();
    return 0;
}
/*
input
9 15
0 1 10
0 5 11
1 6 16
5 6 17
1 8 12
1 2 18
2 8 8
2 3 22
8 3 21
6 3 24
6 7 19
7 3 16
7 4 7
3 4 20
5 4 26
ouput
99
*/</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>80</wp:post_id>
		<wp:post_date><![CDATA[2015-11-12 16:42:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-12 08:42:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[primkruskal%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 2544 最短路 (Kruskal&amp;&amp;Floyd&amp;&amp;SPFA)</title>
		<link>http://acmerbar.com/81.html</link>
		<pubDate>Thu, 12 Nov 2015 13:38:25 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=81</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

ddf

&nbsp;
<pre class="font:consolas lang:default decode:true ">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn=233;
const int inf=0x3f3f3f3f;
int mat[maxn][maxn];  //存图
int path[maxn][maxn];//记录路径数组
int dis[maxn];      //从s出发的最短路径
bool vis[maxn];//标记已经使用过的图
int k,numvex,numline;

void dijkstra()
{
    int cur,MIN;
    memset(vis,false,sizeof(vis));
    for(int i=1; i&lt;=numvex; ++i) dis[i]=inf;
    dis[1]=0;
    for(int i=1; i&lt;=numvex; ++i){
        MIN=inf;
        for(int j=1; j&lt;=numvex; ++j){
            if(!vis[j]&amp;&amp;dis[j]&lt;=MIN){
                MIN=dis[cur=j];
            }
        }
        if(MIN==inf) break;
        vis[cur]=true;
        for(int j=1; j&lt;=numvex ; ++j){
            if(!vis[j]&amp;&amp;dis[j]&gt;(dis[cur]+mat[cur][j]))
                dis[j]=dis[cur]+mat[cur][j];
        }
    }
}

void floyd(){
    for(int i=1; i&lt;=numvex; ++i){
        for(int j=1; j&lt;=numvex; ++j){
            path[i][j]=j;
        }
    }
     for(int k=1; k&lt;=numvex; ++k){
         for(int i=1; i&lt;=numvex; ++i){
             for(int j=1; j&lt;=numvex; ++j){
                 if(mat[i][k]+mat[k][j]&lt;mat[i][j])
                    mat[i][j]=mat[i][k]+mat[k][j],path[i][j]=path[i][k];
             }
         }
     }
}

void spfa(){
    int now;
    memset(vis,false,sizeof(vis));
    for(int i=1; i&lt;=numvex; ++i) dis[i]=inf;
    dis[1]=0;
    queue&lt;int &gt;que;
    que.push(1);
    vis[1]=true;
    while(!que.empty()){
        now=que.front();
        que.pop();
        vis[now]=false;      // 注意是false
        for(int i=1; i&lt;=numvex; ++i){
            if(dis[i]&gt;(dis[now]+mat[now][i])){
                dis[i]=(dis[now]+mat[now][i]);
                if(!vis[i]){
                    que.push(i);
                    vis[i]=true;
                }
            }
        }
    }
}

void init(){
   for(int i=1; i&lt;maxn; ++i){
       for(int j=1; j&lt;maxn; ++j){
           if(i==j) mat[i][j]=0;
           else mat[i][j]=mat[j][i]=inf;
       }
   }
}
void input(){
    while(numline--){
        int u,v,w;
        scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        if(mat[u][v]&gt;w)
            mat[u][v]=mat[v][u]=w;
    }
}
int main(){
   freopen("1.txt","r",stdin);
    while(~scanf("%d%d",&amp;numvex,&amp;numline),numvex+numline){
        init();
        input();
        /*
        dijkstra();
        printf("%d\n",dis[numvex]);
        */

        floyd();
        printf("%d\n",mat[1][numvex]); /*最短路径*/
        for(int i=1; i&lt;=numvex; ++i)  /*输出路径*/
        {
            for(int j=i+1; j&lt;=numvex; ++j)
            {
                printf("v%d-&gt;v%d weigth: %d\n",i,j,mat[i][j]);
                k=path[i][j];
                printf(" path : %d",i);
                while(k!=j)
                {
                    printf(" -&gt; %d",k);
                    k=path[k][j];
                }
                printf("% -&gt; %d\n",j);
            }
        }
        puts("");

        /*
        spfa();
        printf("%d\n",dis[numvex]);
        */
    }
    return 0;
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>81</wp:post_id>
		<wp:post_date><![CDATA[2015-11-12 21:38:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-12 13:38:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2544-%e6%9c%80%e7%9f%ad%e8%b7%af-kruskalfloydspfa]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《绝望锻炼了我：朴槿惠自传》读书笔记</title>
		<link>http://acmerbar.com/82.html</link>
		<pubDate>Fri, 13 Nov 2015 09:38:09 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=82</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>作者简介</strong>：

朴槿惠：生于1952年，韩国首位女总统，前总统朴正熙长女。

毕业于韩国西江大学电子工程系，曾短暂留学于法国。母亲遇刺后，年仅二十二岁肩负起代理“第一夫人”的角色。父亲也遭暗杀后，退隐近二十年。1997年韩国经济危机时重返政坛。2012年12月，在韩国总统大选中获胜，成为韩国有史以来首位女性国家元首。

<strong>全章目录：</strong>

<strong>序言</strong>：重新开始的第二段人生
<ul>
	<li>住在有大庭院房子里的孩子</li>
	<li>二十二岁的第一夫人</li>
	<li>孤单又漫长的航海</li>
	<li>大国家党代表朴槿惠</li>
	<li>我的信念将在世界舞台持续</li>
</ul>
<strong>后记</strong>：为我们的将来，许下承诺

<strong>二十二岁的第一夫人</strong>

<u>“早起的鸟儿有虫吃”，是母亲对我的教诲。</u>

<u>作为第一夫人，我一直比“比别人还要勤奋”的原则来要求自己，这样才能在最短时间内有效地完成更多事情。</u>

<u>我相信只要多处理一件民怨，就能让国民过得更好一些。</u>

<u>“虽然当时忙到十个分身都不够用，但是每当看到努力过日子的人民，我就会打起精神振作起来。--</u><u>在韩百训练院”</u>

<u>“为了和国民分享心情，也想替国民尽一份力，义务工作从没有间断过。--</u><u>在红十字会工会”</u>

<u>“我认为照顾国民的健康是政府的义务，所以一直致力于医疗事业。--</u><u>在夜间免费诊疗所”</u>

<u>“帮孩子们建立健康又快乐的未来，也是我的重要任务之一。”</u>

<u>“经过这次的契机，我明白了其实国家间的外交也是由人来进行的，为了守护自己国家的利益，一个领导者的外交能力是多么重要，我坚信只要给对方信赖感，找出适当的说话方式，又有无限可能来创造出令人满意的结果。”</u>

<u>“外交训练并不是短时间内可以练成的，就像需要长时间发酵才能酿出陶醉人心的红酒一样，它需要时间和真诚的磨练。虽然当时我并没有发现，但现在回想我在第一夫人的位置，不断透过反复地预习和复习，的确培养了外交的敏感度。”</u>

<u>“怀念父母亲的追思事业是我需要亲自负责的事情，父亲留下来的画更是重要的资料。”</u>

<strong>孤单又漫长的航海</strong>

<u>“在青瓦台生活的十五年期间，毫无选择地我也成了爱国者，当对父亲的毁谤与流言传的沸沸扬扬的时候，有人劝我暂时离开韩国过段时间。</u>

<u>但是我做不到，这里是我出生长大的国家，是我的土地，不管去到哪个国家生活，都比不上在自己国家理直气壮又幸福啊。就算在痛苦在疲惫，</u>

<u>我都会在我的国家完成我的人生并长眠在这片土地。”</u>

<u>“就像珍珠要是埋在泥土里就会失去它的光泽一样，是朴总统让我们国人知道了历史的真相，只有真正爱国的人才会明白为国家牺牲的祖先是抱着何等的忠诚。”</u>

<u>“权利是把刀，当权力越大时，这把刀也越锋利，轻轻一碰就会伤人，因此权力使人惧怕，但真正需要惧怕的人反而是手持那把刀的人，若不是怀有笃定哲学信念及修养并受到上天的保佑，任何人都无法正确地运用那强大的权力，倘若任意挥舞那把利刀，到头来累积的恨意，愤怒与报复欲，将会反过来使其窒息。”</u>

<u>“多年来我忍受了无数的出卖，简直就像是站在山崖的边缘般岌岌可危，被曾经信赖的人背叛，让我看清了人类于欲望和权力的执著，那是一段非常苦涩的经验，但也是人生中最宝贵的教训。”</u>

<strong>我的信念将在世界舞台持续</strong>

“写下这本书，感觉就像重新活过一次那样，我的人生迄今为止，受到许多人的帮助，也因为许多人的协助，才得以出版此书，无论如何，我的人生能够走到现在，主要还是国民给予我的莫大精神支柱，再次深表感谢，并将此书献给全国国民。”

<strong> </strong>

<u>“是我能默默熬过这一切并最终站起来的，正是在乡村中，在集市上遇到的哪些质朴的人们。他们用温暖的双手给了我勇气和力量，正是这份无名的爱让我度过了那段黑暗时光。”</u>

-----写给中国读者的信

<u>“</u><u>我选择了希望。我的人生能够走到现在绝不是光凭自己的力量。能够强韧绝望以及常人无法承担的悲伤，全都是因为我的人生不仅仅属于自己。现在，我的人生正开启另一条命运路程，我不会逃避。无论任何事情，我都会坦然接受并想办法克服。因为上天给我的使命，正是创新的希望。”</u>

-----关于使命

“<u>在经历过这么多变化之后，自始至终从未变过的只有当初决定从政时，决定未来人生不再属于自己而是属于国民的决心，以及未来只专注于国民与国家的意志。带着当时的初衷以及不变的约定，我终于完成此书，这本书是我的过去也是现在，更是我对未来不变的承诺。</u>”                                                                                                                         -----关于本书]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>82</wp:post_id>
		<wp:post_date><![CDATA[2015-11-13 17:38:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-13 09:38:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e7%bb%9d%e6%9c%9b%e9%94%bb%e7%82%bc%e4%ba%86%e6%88%91%ef%bc%9a%e6%9c%b4%e6%a7%bf%e6%83%a0%e8%87%aa%e4%bc%a0%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ACM-ICPC北京赛区2015网络同步赛解题报告</title>
		<link>http://acmerbar.com/86.html</link>
		<pubDate>Sun, 15 Nov 2015 08:29:45 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=86</guid>
		<description></description>
		<content:encoded><![CDATA[Problem J.Osu! Master
[题意]:给你几个元素，要组成一首歌，需要一定的顺序，求能获得的最大“Shock marks”
[分析]:其实题意也没怎么看清楚，推数据做出来，如果碰到“S”，则label为1，然后判断即可。

Problem G.Mysterious Antiques in Sackler
[题意]:在四个矩形里面任意选取3个矩形，求是否能组成新的矩形，新的矩形面积等于选取的三个矩形面积之和
[分析]:判断判断加判断，先判断能否无缝对接，再依次判断宽高的关系。

Problem A.Xiongnu's Land
[题意]:在一个大矩形里面放置几个小矩形，求一条直线x方程，把大矩形分成左右两块，满足左边的小矩形面积大于等于
右边里面的小矩形面积且两者之差尽量小，然后再满足左边面积比右边面积尽可能大
[分析]:先二分第一种，再二分第二种。

代码：

PS:今天刚试了一发A题，代码，发现交上去是WA的，还以为思路不对，然后发现R的范围【0，1,000,000】，高和宽相乘是会爆int的，于是加了LL，于是过了，已经更正代码。
<pre class="font:consolas lang:c++ decode:true">/*
* Problem: J
* Running time: 7MS
* Complier: G++
* Author: javaherongwei
* Create Time: 12:27 2015/11/15 星期日
*/

#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+10;
char s[5];
int st[maxn];
int main()
{
   // freopen("1.txt","r",stdin);
    int n;
    while(scanf("%d",&amp;n)!=EOF){
        if(!n){
            puts("0");
            continue;
        }
        for(int i=0; i&lt;n; ++i){
            scanf("%s",s);
            if(s[0]=='S'){
                st[i]=1;
                continue;
            }
            scanf("%d",&amp;st[i]);
        }
        int ans=1;
        for(int i=1; i&lt;n; ++i){
            if(st[i]&lt;=st[i-1]) ans++;
        }
        printf("%d\n",ans);
    }
    return 0;
}</pre>
<pre class="font:consolas lang:c++ decode:true  ">/*
* Problem: G
* Running time: 0MS
* Complier: G++
* Author: javaherongwei
* Create Time:14:07 2015/11/15 星期日
*/
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e3+10;
char s[5];
int st[maxn];
struct node
{
    int x,y; //宽，高
} p[6];
bool f1(int a,int b,int c)   //判断三个能否无缝对接
{
    int aa=p[a].x;
    if((p[b].x==aa||p[b].y==aa)&amp;&amp;(p[c].x==aa||p[c].y==aa))  return true;
    int bb=p[a].y;
    if((p[b].x==bb||p[b].y==bb)&amp;&amp;(p[c].x==bb||p[c].y==bb))  return true;
    return false;
}
bool f2(int a,int b,int c)
{
    if(((p[a].x+p[b].x==p[c].x)||(p[a].x+p[b].x==p[c].y))&amp;&amp;(p[a].y==p[b].y))    return true; //a,b高相等，计算宽之和
    if(((p[a].y+p[b].y==p[c].x)||(p[a].y+p[b].y==p[c].y))&amp;&amp;(p[a].x==p[b].x))    return true; //a.b宽相等，计算高之和
    if(((p[a].x+p[b].y==p[c].x)||(p[a].x+p[b].y==p[c].y))&amp;&amp;(p[a].y==p[b].x))    return true; //剩下两种情况计算不相等的和
    if(((p[a].y+p[b].x==p[c].x)||(p[a].y+p[b].x==p[c].y))&amp;&amp;(p[a].x==p[b].y))    return true;
    return false;
}
bool f3(int a,int b,int c)
{
    if(f2(a,b,c)||f2(a,c,b)||f2(b,c,a)) return true;
    return false;
}
int main()
{
    //freopen("1.txt","r",stdin);
    int n;
    scanf("%d",&amp;n);
    while(n--)
    {
        for(int i=0; i&lt;4; i++)  scanf("%d%d",&amp;p[i].x,&amp;p[i].y);
        int xx,yy;
        bool ok=false,okk=false;
        for(int i=0; i&lt;4; ++i)
        {
            for(int j=i+1; j&lt;4; ++j)
            {
                for(int k=j+1; k&lt;4; ++k)
                {
                    if(f1(i,j,k)||f3(i,j,k))
                    {
                        ok=true;
                        break;
                    }
                }
                if(ok) break;
            }
            if(ok) break;
        }
        if(ok) puts("Yes");
        else puts("No");
    }
    return 0;
}
</pre>
<pre class="font:consolas lang:c++ decode:true">/*
* Problem: A
* Running time: 0MS
* Complier: G++
* Author: javaherongwei
* Create Time: 15:00 2015/11/15 星期日
*/
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+10;
const int inf=0x3f3f3f3f;
typedef long long LL;
int r,n;
struct node
{
    int lx,ly,w,h;
}mat[maxn];
LL calc2(int x) //直线左边的绿洲面积
{
    LL res=0;
    for(int i=0; i&lt;n; ++i){
        res+=(LL)max(0,min(x-mat[i].lx,mat[i].w))*mat[i].h;
    }
    return res;
}
int main()
{
   // freopen("1.txt","r",stdin);
    int t;scanf("%d",&amp;t);
    while(t--){
        scanf("%d",&amp;r);
        scanf("%d",&amp;n);
        LL sum=0;
        for(int i=0; i&lt;n; ++i){
            scanf("%d%d%d%d",&amp;mat[i].lx,&amp;mat[i].ly,&amp;mat[i].w,&amp;mat[i].h);
            sum+=(LL)mat[i].h*mat[i].w; //绿洲总的面积,注意LL！！！
        }
        int ll=0,rr=r;
        for(; ll&lt;rr; ){ //第一次二分【方程直线】满足绿洲面积左边大于等于右边
            int mid=(ll+rr)&gt;&gt;1;
            if(calc2(mid)&gt;=sum-calc2(mid)) rr=mid;
            else ll=mid+1;
        }
      //  printf("--&gt;%d\n",ll);
        LL ans=calc2(ll);
        rr=r;
        for(; ll&lt;rr; )//第二次二分【方程直线】满足陆地面积左边不小于右边
        {
            int mid=((ll+rr)&gt;&gt;1)+1;
            if(calc2(mid)==ans) ll=mid;
            else rr=mid-1;
        }
        printf("%d\n",ll);
    }
    return 0;
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>86</wp:post_id>
		<wp:post_date><![CDATA[2015-11-15 16:29:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-15 08:29:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[acm-icpc%e5%8c%97%e4%ba%ac%e8%b5%9b%e5%8c%ba2015%e7%bd%91%e7%bb%9c%e5%90%8c%e6%ad%a5%e8%b5%9b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="2015acm-regional"><![CDATA[2015ACM-Regional]]></category>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[94]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[40]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[Robin]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[Robin@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[101.226.61.186]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-16 20:59:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-16 12:59:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[赞！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1447678751.2956469058990478515625;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1447822827.2422850131988525390625;s:5:"event";s:15:"status-approved";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[jiabei]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[admin@acmerbar.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[120.194.101.83]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-18 13:01:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-18 05:01:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Thank you]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>5</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1447822862.8167650699615478515625;s:5:"event";s:9:"check-ham";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Dilworth定理的应用(最少覆盖,最少链划分)</title>
		<link>http://acmerbar.com/97.html</link>
		<pubDate>Tue, 17 Nov 2015 13:37:46 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=97</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>Dilworth定理的应用</strong>

&nbsp;

<strong>题目：<a href="http://poj.org/problem?id=1065" target="_blank">http://poj.org/problem?id=1065</a></strong>

&nbsp;

<strong>题意：给定n个二元组，设第一个元素为a[],第二个元素为b[]，求最少的划分数使得每一种划分中a[]和b[]不是下降序列。</strong>

<strong>分析：这个问题是二元组的最少链划分，那么我们以a[]为关键字进行从小到大排序，如果a[]中相同就按照b[]排序，根据</strong><strong>Dilworth定理，然后题目就变成了求b[]序列中最长严格下降子序列长度了。</strong>

代码：

其实此题数据不大，有一种直接的方法见代码2：
<pre class="font:consolas lang:default decode:true ">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+10;
const int inf=0x3f3f3f3f;
int arr[maxn];
struct node
{
    int l,w;
    bool operator &lt; (const node &amp;t)const{
        return (l&lt;t.l||(l==t.l&amp;&amp;w&lt;t.w));
    }
} st[maxn],sb[maxn];
int dp[maxn];
int LIS[maxn];
int Binary_search(int l,int r,int x)
{
    while(l&lt;r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(dp[mid]==x) return mid;
       else if(dp[mid]&lt;=x) l=mid+1;
       else r=mid;
    }
    return l;
}
int main()
{
    //freopen("1.txt","r",stdin);
    int t;
    scanf("%d",&amp;t);
    while(t--)
    {
        int n;
        scanf("%d",&amp;n);
        for(int i=0; i&lt;n; ++i){
            scanf("%d%d",&amp;st[i].l,&amp;st[i].w);
        }
        sort(st,st+n);
        for(int i=0; i&lt;n; ++i) sb[n-i-1]=st[i];
        int len=1;
        memset(dp,inf,sizeof(dp));
        for(int i=0; i&lt;n; ++i)
        {
            int ck=Binary_search(0,len,sb[i].w);
            if(ck==len) len++;
            dp[ck]=sb[i].w;
        }
        printf("%d\n",len);
    }
    return 0;
}
/*
3
5
4 9 5 2 2 1 3 5 1 4
3
2 2 1 1 2 2
3
1 3 2 2 3 1
2
1
3
*/</pre>
<pre class="font:consolas lang:default decode:true ">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+10;
int arr[maxn];
struct node
{
    int l,w;
    bool vis;
    bool operator &lt; (const node &amp;t)const{
    return (l&lt;t.l||(l==t.l&amp;&amp;w&lt;t.w));
    }
}st[maxn];
int dp[maxn];
int LIS[maxn];
int main()
{
   // freopen("1.txt","r",stdin);
    int t;scanf("%d",&amp;t);
    while(t--){
        int n;scanf("%d",&amp;n);
        memset(dp,0,sizeof(dp));
        memset(LIS,0,sizeof(LIS));
        for(int i=0; i&lt;n; ++i){
            scanf("%d%d",&amp;st[i].l,&amp;st[i].w);
            st[i].vis=false;
        }
        sort(st,st+n);
        int sum=0;
        for(int i=0; i&lt;n; ++i)
        {
            if(st[i].vis) continue;
            int minn=st[i].w;
            for(int j=i+1; j&lt;n; ++j)
            {
                if(st[j].w&gt;=minn&amp;&amp;!st[j].vis)
                {
                    minn=st[j].w;
                    st[j].vis=true;
                }
            }
            sum++;
        }
        printf("%d\n",sum);
    }
    return 0;
}</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>97</wp:post_id>
		<wp:post_date><![CDATA[2015-11-17 21:37:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-17 13:37:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dilworth%e5%ae%9a%e7%90%86%e7%9a%84%e5%ba%94%e7%94%a8%e6%9c%80%e5%b0%91%e8%a6%86%e7%9b%96%e6%9c%80%e5%b0%91%e9%93%be%e5%88%92%e5%88%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>拓扑排序（topsort）</title>
		<link>http://acmerbar.com/100.html</link>
		<pubDate>Wed, 18 Nov 2015 12:46:55 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=100</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>【拓扑排序问题】</strong>

解决方法：

1. 计算每一个点的入度值deg[i]，这一步需要扫描所有点和边，复杂度O(N+M)。

2. 把入度为0的点加入队列Q中，当然有可能存在多个入度为0的点，同时它们之间也不会存在连接关系，所以按照任意顺序加入Q都是可以的。

3. 从Q中取出一个点p。对于每一个未删除且与p相连的点q，deg[q] = deg[q] - 1；如果deg[q]==0，把q加入Q。

代码：复杂度：O(V+E)

如果用邻接表的话拓扑排序的时间复杂度是O(N*E)，邻接矩阵是O（N^2），N表示顶点数，E表示边数，Floyd时间复杂度是O(N^3)。

性质
1、 拓扑排序在有向无环图中才能排出有效的序列，否则能判断该有向图有环。
2、如果输入的有向图中的点,不存在入度为0的点,则该有向图存在回路
3、如果存在的入度为0的点大于一个,则该有向图肯定不存在一个可以确定的拓扑序列但并不妨碍拓扑排序

实际上，可以看成把一个图的所有结点排序，使得每一条有向边《u,v》对应的u都排在v的前面
不难发现，如果图中存在有向环，则不存在拓扑排序，反之存在，我们把不包含有向环的有向图
称为有向无环图
采用dfs完成拓扑排序

例题：<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246" target="_blank">UVA 10305</a>

例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank">HDU 1285 确定比赛名次</a>
<pre class="font:consolas lang:default decode:true ">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn=5*1e5+10;
int indegree[maxn];
vector &lt;int &gt;vec[maxn];
int n,m;
void topsort()
{
    queue&lt;int &gt;q;
    while(!q.empty()) q.pop();
    for(int i=1; i&lt;=n; i++)
        if(!indegree[i]) q.push(i);
    int sum=0;
    bool flag=false;
    while(!q.empty())
    {
        int u=q.front();
        // 输出路径
        if(!flag) printf("%d",u),flag=true;
        else printf(" %d",u);
        q.pop();
        sum++;
        for(int i=0; i&lt;vec[u].size(); i++)
        {
            if(--indegree[vec[u][i]]==0) q.push(vec[u][i]);
        }
    }
    puts("");
    /*
    if(sum&lt;n) return false;//判断拓扑排序
    return true;
    */
}
int main()
{
    int t,u,v,a;
    while(~scanf("%d%d",&amp;n,&amp;m),n+m)
    {
        for(int i=0; i&lt;maxn; i++)
        {
            indegree[i]=0;
            vec[i].clear();
        }
        while(m--)
        {
            scanf("%d%d",&amp;v,&amp;u);
            vec[v].push_back(u);
            indegree[u]++;
        }
        topsort();
    }
    return 0;
}

/*
Sample Input
5 4
1 2
2 3
1 3
1 5
0 0
Sample Output
1 4 2 5 3
*/</pre>
<pre class="font:consolas lang:default decode:true ">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn=1e5+10;
const int inf =0x3f3f3f3f;
int vis[maxn];
vector &lt;int &gt;G[maxn];
int arc[maxn],t,n,m;
bool dfs(int u)
{
    vis[u]=-1;
    // 邻接表
    for(int i=0; i&lt;G[u].size(); ++i){
        int v=G[u][i];
        if(vis[v]&lt;0) return false;
        else if(!vis[v]&amp;&amp;!dfs(v)) return false;
    }
    /*
    邻接矩阵
     for(int i=1; i&lt;=n; ++i) if(G[u][i]){
        if(c[i]&lt;0) return false;
        else if(!c[i]&amp;&amp;!dfs(i)) return false;
    }
    */
    vis[u]=1;
    arc[--t]=u;
    return true;
}
bool topsort()
{
    t=n;
    for(int i=1; i&lt;=n; ++i)
        if(!vis[i]&amp;&amp;!dfs(i)) return false;
    return true;
}
int main()
{
    //freopen("1.txt","r",stdin);
    while(~scanf("%d%d",&amp;n,&amp;m),n+m){
        int u,v;
        for(int i=0; i&lt;maxn; ++i){
            G[i].clear();
            arc[i]=0;
            vis[i]=0;
        }
        for(int i=0; i&lt;m; ++i){
            scanf("%d%d",&amp;u,&amp;v);
            G[u].push_back(v);
        }
        if(topsort()){
           // puts("YES");
           for(int i=0; i&lt;n; ++i)
            printf("%d%c",arc[i],i==n-1?'\n':' ');
        }
    }
    return 0;
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>100</wp:post_id>
		<wp:post_date><![CDATA[2015-11-18 20:46:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-18 12:46:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f%ef%bc%88topsort%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f"><![CDATA[拓扑排序]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[DP经典]之数塔问题</title>
		<link>http://acmerbar.com/101.html</link>
		<pubDate>Thu, 19 Nov 2015 03:22:08 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=101</guid>
		<description></description>
		<content:encoded><![CDATA[【问题描述】
在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？

【分析】
这道题如果用枚举法，在数塔层数稍大的情况下（如40），则需要列举出的路径条数将是一个非常庞大的数目。
如果用贪心法又往往得不到最优解。
在用动态规划考虑数塔问题时可以自顶向下的分析，自底向上的计算。
从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值，
只要左右两道路径上的最大值求出来了才能作出决策。
同样的道理下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。
这样一层一层推下去，直到倒数第二层时就非常明了。
状态：dp[i][j]+=max(dp[i+1][j],dp[i+1][j+1])
所以实际求解时，可从底层开始，层层递进，最后得到最大值。
总结：此题是最为基础的动态规划题目，阶段、状态的划分一目了然。

代码：

例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084" target="_blank">HDU 2084 数塔</a> <a href="http://poj.org/problem?id=1163" target="_blank">POJ 1163</a>
<pre class="font:consolas minimize:true lang:default decode:true">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn=1e2+10;
const int inf =0x3f3f3f3f;
int dp[maxn][maxn];
int main(){
   int t;scanf("%d",&amp;t);
   while(t--){
       int n;scanf("%d",&amp;n);
       for(int i=1; i&lt;=n; ++i){
           for(int j=1; j&lt;=i; ++j){
               scanf("%d",&amp;dp[i][j]);
           }
       }
       for(int i=n-1; i&gt;=1; --i){//从底层往上推
           for(int j=1; j&lt;=i; ++j){
               dp[i][j]+=max(dp[i+1][j],dp[i+1][j+1]);//左右相邻取最大
           }
       }
       printf("%d\n",dp[1][1]);
   }
   return 0;
}

/*
Sample Input
1
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
Sample Output
30
*/
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>101</wp:post_id>
		<wp:post_date><![CDATA[2015-11-19 11:22:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-19 03:22:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dp%e7%bb%8f%e5%85%b8%e4%b9%8b%e6%95%b0%e5%a1%94%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[DP经典]之最长上升子序列（LIS）问题</title>
		<link>http://acmerbar.com/102.html</link>
		<pubDate>Thu, 19 Nov 2015 04:04:19 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=102</guid>
		<description></description>
		<content:encoded><![CDATA[最长上升子序列问题

有一个长为n的数列请求出这个序列中最长的上升子序列的长度，上升子序列值的是对于任意的,都满足的子序列。

N的范围决定与算法的选择

1&lt;=N&lt;=10000

这个问题也被称为最长递增子序列（LIS）

首先建立递推关系：

定义

<em>dp[i]:=以为末尾的最长递增子序列的长度</em>

以结尾的上升子序列是：

<em>只包含的子序列</em>

<em>在满足并且的以为结尾的上升序列末尾，追加后得到的子序列</em>

这二者之一，就能得到如下的递推公式：

<img src="http://img.blog.csdn.net/20150929141014859" alt="" />

代码：
<pre class="font:consolas minimize:true lang:default decode:true">int n;  
int a[N];  
int dp[N];  
  
void solve()  
{  
    int res=0;  
    for(int i=0; i&lt;n; ++i)  
    {  
        dp[i]=1;  
        for(int j=0; j&lt;i; ++j) if(a[j]&lt;a[i])  
        {  
            dp[i]=max(dp[i],dp[j]+1);  
        }  
        res=max(res,dp[i]);  
    }  
    printf("%d\n",res);  
}</pre>
普通的O(n^2)

代码：
<pre class="font:consolas minimize:true lang:c++ decode:true">#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  
#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
using namespace std;  
int dp[105];//用dp[i]保存长度为i的单调子序列的末尾元素的值，用len保存单调子序列的最大长度。  
int arr[105];  
int main()  
{  
    int _,n,m;  
    scanf("%d",&amp;_);  
    while(_--)  
    {  
        memset(dp,0,sizeof(dp));  
        scanf("%d",&amp;n);  
        for(int i=0; i&lt;n; ++i)  
            scanf("%d",&amp;arr[i]);  
        int len=1;  
        dp[1]=arr[0];  
        for(int i=1; i&lt;n; ++i)  
        {  
            if(arr[i]&gt;dp[len])  
            {  
                dp[++len]=arr[i];  
            }  
            else{  
                int j;  
                for(j=len-1; j&gt;=1; --j)  
                    if(arr[i]&gt;dp[j])  
                        break;  
                    dp[j+1]=arr[i];  
            }  
        }  
        printf("%d\n",len);  
    }  
    return 0;  
}</pre>
此外还可以定义其他递推关系，前面我们利用DP求取针对最末位的元素的最长递增子序列，如果子序列的长度相同

那么最末位的元素较小的在之后会更有优势，所以可以考虑反过来用DP针对相同长度情况下最小的末位元素进行求解

<em>dp[i]:=长度为的上升序列中末位元素的最小值（不存在的话为INF）</em>

<em> </em> 用DP来更新这个数组：

最开始全部DP数组赋值INF ,然后由前到后逐个考虑数列的元素，对于每个,如果i==0,或者

的话，就用dp[i]=min(dp[i],)进行更新，最终找出使得dp[i]&lt;INF的最大的i+1

就是结果，此方法为考虑进一步优化，首先dp数组中除INF之外是单调递增的，所以对于每个最多需要更新1次，对于更新位置可以进行二分搜索进行加速，复杂度O(nlogn)。

代码：
<pre class="font:consolas minimize:true lang:c++ decode:true">#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  
#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
using namespace std;  

const int inf=0x3f3f3f3f;  
inline int max(int a,int b){return a&gt;b?a:b;}  
inline int min(int a,int b){return a&lt;b?a:b;}  
int dp[100005];  
int arr[100005];  
int LIS[100005];//记录路径  
int Binary_search(int l,int r,int x)  
{  
    while(l&lt;=r){  
        int mid=(l+r)&gt;&gt;1;  
        if(dp[mid]==x)  
            return mid;  
        else if(dp[mid]&lt;=x)  
            l=mid+1;  
        else r=mid-1;  
    }  
    return l;  
}  
void init()  
{  
    memset(dp,inf,sizeof(dp));  
    memset(arr,0,sizeof(arr));  
    memset(LIS,0,sizeof(LIS));  
}  
int main()  
{  
    int n;  
    while(~scanf("%d",&amp;n))  
    {  
        init();  
        for(int i=1; i&lt;=n; ++i)  
            scanf("%d",&amp;arr[i]);  
        int len=1;  
      for(int i=1; i&lt;=n; ++i)
     {
      int ck=Binary_search(1,len,arr[i]); //lower_bound(dp+1,dp+1+n,arr[i])-dp;
      if(ck==len) len++;
      dp[ck]=arr[i];
      LIS[i]=ck;
     }
     printf("%d\n",len);
    } return 0;  
}</pre>
例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1025" target="_blank">HDU 1025 （稍微变形）</a>，

<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1087" target="_blank">HDU 1087（上升和最大）</a>

<span style="text-decoration: underline;">注意本题是求上升的和最大值，那么可以类比。我们知道在最长上升子序列中的状态转移方程是：dp[i] = max(dp[i],f[j] + 1),0&lt;=j&lt;i,a[j]&lt;a[i]。那么对于和同样的思路得到：dp[i] = max(dp[i],dp[j] + a[i]),0&lt;=j&lt;i,a[j]&lt;a[i]。</span>

代码：
<pre class="font:consolas minimize:true lang:c++ decode:true">#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 1e5+10;
int a[maxn];
int n,dp[maxn];
int main()
{
    int n;
    while(~scanf("%d",&amp;n),n)
    {
        for(int i=0; i&lt;n; ++i)
            scanf("%d",&amp;a[i]);
        int ans=-1;
        for(int i=0; i&lt;n; ++i) dp[i]=a[i];
        for(int i=0; i&lt;n; ++i)
        {
            for(int j=0; j&lt;i; ++j)
            {
                if(a[i]&gt;a[j])
                    dp[i]=max(dp[i],dp[j]+a[i]);
            }
            ans=max(ans,dp[i]);
        }
       printf("%d\n",ans);
    }
    return 0;
}
</pre>
&nbsp;

还有 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1950" target="_blank">HDU 1950</a>，<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1134" target="_blank">51nod 1134</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>102</wp:post_id>
		<wp:post_date><![CDATA[2015-11-19 12:04:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-19 04:04:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dp%e7%bb%8f%e5%85%b8%e4%b9%8b%e6%9c%80%e9%95%bf%e4%b8%8a%e5%8d%87%e5%ad%90%e5%ba%8f%e5%88%97%ef%bc%88lis%ef%bc%89%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>【UML建模】UML时序图的人形图添加</title>
		<link>http://acmerbar.com/103.html</link>
		<pubDate>Sat, 21 Nov 2015 06:38:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=103</guid>
		<description></description>
		<content:encoded><![CDATA[今天画《软件工程》作业，需要用Startuml 做时序图，在看时序图的例子的时候，发现有些的时序图上有小人的图标，可是一些UML工具却没有找到小人的图标，百度找到解决办法 ，终于把小人(角色)给添加上了。

步骤如下所示：

1、首先建立一个空项目，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/1.jpg"><img class="aligncenter size-medium wp-image-104" src="http://acmerbar.com/wp-content/uploads/2015/11/1-300x214.jpg" alt="" width="300" height="214" /></a>

2、然后在右面的Model Explorer窗口中新建立一个Model，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/2s.jpg"><img class="aligncenter size-medium wp-image-105" src="http://acmerbar.com/wp-content/uploads/2015/11/2s-300x158.jpg" alt="" width="300" height="158" /></a>

3、在新建的Model1上，添加时序图，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/3.jpg"><img class="aligncenter size-medium wp-image-106" src="http://acmerbar.com/wp-content/uploads/2015/11/3-300x138.jpg" alt="" width="300" height="138" /></a>

4、然后在Model1上选择Add下的Actor(角色)，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/4.jpg"><img class="aligncenter size-medium wp-image-107" src="http://acmerbar.com/wp-content/uploads/2015/11/4-300x199.jpg" alt="" width="300" height="199" /></a>

5、然后按照下图的设置将小人添加到时序图中，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/5.jpg"><img class="aligncenter size-medium wp-image-108" src="http://acmerbar.com/wp-content/uploads/2015/11/5-300x279.jpg" alt="" width="300" height="279" /></a>

6、如果想要重命名角色的话，不要在时序图中双击重命名，要在刚才添加小人那重命名，如图所示：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/6.jpg"><img class="aligncenter size-medium wp-image-109" src="http://acmerbar.com/wp-content/uploads/2015/11/6-133x300.jpg" alt="" width="133" height="300" /></a>

这样就把小人(角色)添加到了时序图中，希望对需要的人有所帮助。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date><![CDATA[2015-11-21 14:38:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-21 06:38:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%90uml%e5%bb%ba%e6%a8%a1%e3%80%91uml%e6%97%b6%e5%ba%8f%e5%9b%be%e7%9a%84%e4%ba%ba%e5%bd%a2%e5%9b%be%e6%b7%bb%e5%8a%a0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uml%e5%bb%ba%e6%a8%a1"><![CDATA[UML建模]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[组合数学]之Catalan数</title>
		<link>http://acmerbar.com/114.html</link>
		<pubDate>Sat, 21 Nov 2015 09:04:53 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=114</guid>
		<description></description>
		<content:encoded><![CDATA[附上证明：

学习自：<a href="http://blog.csdn.net/acdreamers/article/details/7628667" target="_blank">ACdreamer Blog</a>

<em><strong>Catalan数的定义：</strong></em>

设<img src="http://img.blog.csdn.net/20130814140118890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />表示用下面的方法把凸多边形区域分成三角形区域的方法数：在有n+1条边的凸多边形区域内通过插入在其中不相交的对角线而把它分成三角形区域。定义<img src="http://img.blog.csdn.net/20130814140426171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />。则<img src="http://img.blog.csdn.net/20130814140443656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />满足递推关系

<img src="http://img.blog.csdn.net/20130814140701078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />   <img src="http://img.blog.csdn.net/20130814140832578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

这个递推关系的解是：<img src="http://img.blog.csdn.net/20130814141030828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，这里的<img src="http://img.blog.csdn.net/20130814141323546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />叫做<strong>Catalan数</strong>。

或者这样理解：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/QQ截图201511211655441.png"><img class="aligncenter size-medium wp-image-116" src="http://acmerbar.com/wp-content/uploads/2015/11/QQ截图201511211655441-300x103.png" alt="" width="300" height="103" /></a>

&nbsp;

前十一项：

C0=1; C5=42;
C1=1; C6=132;
C2=2; C7=429;
C3=5; C8=1430;
C4=14 C9=4862;C10=16796;

那么上面的递推式的正确性我们可以简单描述一下即可：

<strong>证明：</strong>这里因为<img src="http://img.blog.csdn.net/20130814141453218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />表示按照上述规则划分的三角形区域个数，那么我们随便选一条多边形的一条边作为基边，那么

再在剩余的n-1个点中选一个点，我们把所选的一条边的两点分别与所选的那一点连接起来，那么多边形被划

分成3部分，一部分有k+1条边，一部分有3条边，另一部分有n-k+1条边，那么这样就划分成了子问题了，所

以按照这个思路可以证明递推式成立。

那么根据递推式是如何推出Catalan数的通项公式呢？

这里用到了生成函数：我们很容易写出<img src="http://img.blog.csdn.net/20130814142426796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />的生成函数<img src="http://img.blog.csdn.net/20130814142720437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

我们进一步计算

<img src="http://img.blog.csdn.net/20130814143308031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

因为有：<img src="http://img.blog.csdn.net/20130814143419125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，所以进一步得到：

<img src="http://img.blog.csdn.net/20130814143612562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，由于<img src="http://img.blog.csdn.net/20130814143735421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

所以有：<img src="http://img.blog.csdn.net/20130814143851625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，解之得到：

<img src="http://img.blog.csdn.net/20130814144108156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，另一个解不符合，舍去。

那么根据牛顿二项式有：

<img src="http://img.blog.csdn.net/20130814144535640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

&nbsp;

那么带入化简得到：

<img src="http://img.blog.csdn.net/20130814144733187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

那么我们最终得到：<img src="http://img.blog.csdn.net/20130814144903687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />

所以：<img src="http://img.blog.csdn.net/20130814145026812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，这就是<strong>Catalan的推导过程</strong>。

&nbsp;

卡特兰数的应用

<strong>1、括号化问题</strong>

矩阵连乘：<img src="http://img.blog.csdn.net/20130814145516312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，问有几种括号化的方案？
<span style="text-decoration: underline;">思路</span>：可以这样考虑，首先通过括号化，将P分成两个部分，然后分别对两个部分进行括号化。比如分成(a1)×(a2×a3.....×an)，然后再对(a1)和(a2×a3.....×an)分别括号化；又如分成(a1×a2)×(a3.....×an)，然后再对(a1×a2)和(a3.....×an)括号化。
设n个矩阵的括号化方案的种数为f(n)，那么问题的解为
f(n) = f(1)*f(n-1) + f(2)*f(n-2) + f(3)*f(n-3) + f(n-1)*f(1)。f(1)*f(n-1)表示分成(a1)×(a2×a3.....×an)两部分，然后分别括号化。
计算开始几项，f(1) = 1, f(2) = 1, f(3) = 2, f(4) = 5。结合递归式，不难发现f(n)等于h(n-1)。

<strong>2、出栈次序问题</strong>

一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?
<span style="text-decoration: underline;">思路</span>：这个与加括号的很相似，进栈操作相当于是左括号，而出栈操作相当于右括号。n个数的进栈次序和出栈次序构成了一个含2n个数字的序列。第0个数字肯定是进栈的数，这个数相应的出栈的数一定是第2i+1个数。因为如果是2i，那么中间包含了奇数个数，这奇数个肯定无法构成进栈出栈序列。
设问题的解为f(2n)， 那么f(2n) = f(0)*f(2n-2) + f(2)*f(2n-4) + f(2n-2)*f(0)。f(0) * f(2n-2)表示第0个数字进栈后立即出栈，此时这个数字的进栈与出栈间包含的数字个数为0，剩余为2n-2个数。f(2)*f(2n-4)表示第0个数字进栈与出栈间包含了2个数字，相当于1 2 2 1，剩余为2n-4个数字。依次类推。
假设f(0) = 1，计算一下开始几项，f(2) = 1, f(4) = 2, f(6) = 5。结合递归式，不难发现f(2n) 等于h(n)。

<strong>类似问题</strong>

a、有2n个人排成一行进入剧场，入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈)

<span style="text-decoration: underline;"> 思路</span>：可以将持5元买票视为进栈，那么持10元买票视为5元的出栈。这个问题就转化成了栈的出栈次序数。由应用三的分析直接得到结果，f(2n) 等于h(n)。

b、n个1和n个0组成一个2n位的二进制数，要求从左到右扫描，0的累计数不小于1的累计数，求满足条件的的数。

c、12个人排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？

我们先把这12个人从低到高排列,然后,选择6个人排在第一排,那么剩下的6个肯定是在第二排.用0表示对应的人在第一排,用1表示对应的人在第二排,那么含有6个0,6个1的序列,就对应一种方案.

比如000000111111就对应着
第一排：0 1 2 3 4 5
第二排：6 7 8 9 10 11
010101010101就对应着
第一排：0 2 4 6 8 10
第二排：1 3 5 7 9 11问题转换为，这样的满足条件的01序列有多少个。与情况b一样。

<strong>3、给定节点组成二叉树的问题</strong>

给定N个节点，能构成多少种形状不同的二叉树？

<span style="text-decoration: underline;">思路</span>：可以这样考虑，根肯定会占用一个结点，那么剩余的n-1个结点可以有如下的分配方式，T(0, n-1),T(1, n-2),...T(n-1, 0)，设T(i, j)表示根的左子树含i个结点，右子树含j个结点。
设问题的解为f(n)，那么f(n) = f(0)*f(n-1) + f(1)*f(n-2) + .......+ f(n-2)*f(1) + f(n-1)*f(0)。假设f(0) = 1，那么f(1) = 1, f(2) = 2, f(3) = 5。结合递推式，不难发现f(n)等于h(n)。

<strong>4.n*n棋盘从左下角走到右上角而不穿过主对角线的走法</strong>

<strong>5.n个+1和n个-1构成的2n项序列，其部分和总满足：<img src="http://img.blog.csdn.net/20130814151440546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" />的序列的个数。</strong>

Catalan数的高精度处理：利用递归式： h(n)=((4*n-2)/(n+1))*h(n-1)

例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1023" target="_blank">HDU 1023</a>

代码：
<pre class="lang:c++ decode:true">#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 1e2+10;
int a[maxn][maxn];
/*
a[n][0]:表示长度
a[n][1]:个位数
C0=1;  C5=42;
C1=1;  C6=132;
C2=2;  C7=429;
C3=5;  C8=1430;
C4=14  C9=4862;
C10=16796;
*/
void catalan()
{
    int i,j,yu,len;
    a[1][1]=a[1][0]=a[2][0]=1;
    a[2][1]=2;
    len=1;
    for(i=3; i&lt;maxn; ++i)
    {
        yu=0;
        for(j=1; j&lt;=len; ++j) //乘法
        {
            int t=(a[i-1][j])*(4*i-2)+yu;
            yu=t/10;
            a[i][j]=t%10;
        }
        while(yu) //进位
        {
            a[i][++len]=yu%10;
            yu/=10;
        }
        for(j=len; j&gt;=1; --j)//除法
        {
            int t=(a[i][j])+yu*10;
            a[i][j]=t/(i+1);
            yu=t%(i+1);
        }
        while(!a[i][len]) len--; // //高位零处理  
        a[i][0]=len;
    }
}
int main()
{
    catalan();
    int n;
    while(~scanf("%d",&amp;n))
    {
         for(int i=a[n][0]; i&gt;0; --i)
         {
             printf("%d",a[n][i]);
         }
         puts("");
    }
    return 0;
}
</pre>
大数处理；
<pre class="lang:java decode:true">/*大数计算卡特兰数*/

import java.io.*;
import java.util.*;
import java.math.BigInteger;//声明BigInteger大数类

public class Main
{
    public static long  catalan(int n)  // MAX n=33
    {
        if(n==0)  return 1;
        else return (4*n-2)*catalan(n-1)/(n+1);
    }

    /*h(0)*h(n-1) + h(2)*h(n-2) + ... + h(n-1)h(0)=h(n))
     * h(n)=((4*n-2)/(n+1))*h(n-1)
     */
    public static BigInteger cat(int n)
    {
        if (n==1||n==0)  return BigInteger.ONE;
        BigInteger catt=new BigInteger(Integer.toString(2*n));//toString()方法就是把对象转换成String类型
        BigInteger twice=new BigInteger(Integer.toString(2*n));
        BigInteger i =new BigInteger("1");
        BigInteger one = new BigInteger("1");
        for (int j=1; j&lt;n; j++, i=i.add(one))
            catt=catt.multiply(twice.subtract(i));
        i=i.add(one);  // i=n+1;
        for (int j=n+1; j&gt;=1; i=i.subtract(one),j--)
            catt=catt.divide(i);
        return catt;
    }

    public static void main(String[] args) throws Exception
    {
        Scanner cin=new Scanner(System.in);
        while(cin.hasNextInt())
        {
            int k=cin.nextInt();
            BigInteger s=cat(k);
            System.out.println(s);
        }
    }
}
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>114</wp:post_id>
		<wp:post_date><![CDATA[2015-11-21 17:04:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-21 09:04:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6%e4%b9%8bcatalan%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>[字符串]之KMP字符串匹配</title>
		<link>http://acmerbar.com/118.html</link>
		<pubDate>Sun, 22 Nov 2015 08:04:38 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=118</guid>
		<description></description>
		<content:encoded><![CDATA[推荐July博文：<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank">从头到尾彻底理解KMP</a>

我们把匹配串T串各个位置的j值的变化定义为一个数组next，那么next数组的长度就是T串的长度，于是我们可以得到下面函数的定义：

<a href="http://acmerbar.com/wp-content/uploads/2015/11/QQ截图20151121213220.png"><img class="aligncenter size-medium wp-image-119" src="http://acmerbar.com/wp-content/uploads/2015/11/QQ截图20151121213220-300x83.png" alt="" width="300" height="83" /></a>

<strong>Next</strong><strong>数组推导：</strong>

具体如何推导一个串的next数组？，我们来看一下例子

<strong>1</strong>
<ul>
	<li>T=”abcdex”</li>
</ul>
<table>
<tbody>
<tr>
<td width="76">j</td>
<td width="76">123456</td>
</tr>
<tr>
<td width="76">T</td>
<td width="76">abcdex</td>
</tr>
<tr>
<td width="76">  Next[j]</td>
<td width="76">011111</td>
</tr>
</tbody>
</table>
<ul>
	<li>当j=1时，next[1]=0;</li>
	<li>J=2,j由1到j-1就只有字符’a’,属于其他情况，next[2]=1;</li>
	<li>J=3,由1到j-1串是’ab’,显然’a’与’b’不相等，属于其他情况，next[3]=1</li>
	<li>一直到末尾，所有最终此串的next[j]为011111。</li>
</ul>
&nbsp;

<strong>2</strong>

【1】T = “abcabx”

&nbsp;
<table>
<tbody>
<tr>
<td width="76">j</td>
<td width="76">123456</td>
</tr>
<tr>
<td width="76">T</td>
<td width="76">abcabx</td>
</tr>
<tr>
<td width="76">  Next[j]</td>
<td width="76">011123</td>
</tr>
</tbody>
</table>
【2】j=1,next[1]=0;

【3】j=2,3,4同上，next[j]=1;

【4】j=5,此时j由1到j-1的串是”abca”,前缀’a’和后缀’a’相等，，因此next[5]=2;
<ul>
	<li>j=6,此时j由1到j-1的串是”abcab”,前缀”ab”和后缀”ab”相等，因此next[6]=3;</li>
</ul>
得到规律：如果前后缀n个字符相等，next[]值为n+1

其实后面发现这样的计算还是有缺陷的，如果按以上的next数组推导，比如对于主串S=’aaaabcde’，子串T =’aaaaax’,next数组分别是012345，会还四部计算是重复的，由于T的第二，三，四，五，位置的字符都与首位的’a’相等，那么可以用首位next[1]的值去取代与它相等的字符后续next[j]的值，因此对next数组改变为nextval数组。

同理

对于T=”aaaaa”

Next[j]=01234

<strong>Nextval</strong><strong>数组推导</strong>

1 T=’ababaaaba’

[1]
<table>
<tbody>
<tr>
<td width="76">j</td>
<td width="78">123456789</td>
</tr>
<tr>
<td width="76">T</td>
<td width="78">ababaaaba</td>
</tr>
<tr>
<td width="76">  Next[j]</td>
<td width="78">011234223</td>
</tr>
<tr>
<td width="76">Nextval[j]</td>
<td width="78">010104210</td>
</tr>
</tbody>
</table>
[2]先计算next数组，当j=1,nextval[1]=0;

[3]j=2,因为第二位字符b的next是1，而第一位是a，不相等，所以nextval[2]=next[2]=1;

[4]j=3,因为第三位字符a的next值为1，所以与第一位的a比较得知相等，所以nextval[3]=next[1]=0;(即T[3]=T[1])

[5]j=4,同上，nextval[4]=next[2]=1;(即T[4]=T[2])

[6]j=5,同上，nextval[5]=next[3]=0;

[7]j=6,next[6]=4,而T[4]!=T[6]所以nextval[6]=4;

[8]同上；

[9]同上；

最后得到nextval数组：010104210

next数组的应用：

POJ2406，给一个长度为1000000的字符串，求它由多少个最小的循环节组成，例如：ababab，它由3个ab组成，所以答案

是3，再比如abcdabcdab，它只能由一个abcdabcdab组成，所以答案是1.

关于最小的循环节，有一个重要的性质：<span style="text-decoration: underline;">tmp = len-next[len]为字符串str的最小循环节，且有：</span>

<span style="text-decoration: underline;">IF len MOD tmp == 0 最小循环周期 ans = len MOD tmp;</span>

<span style="text-decoration: underline;">ELSE 最小循环周期ans = 1;</span>

注意在求循环节问题时的next数组不要优化，在做匹配时才优化。

那么POJ1961就很好做了，也是一样的求最小循环周期，题意是给一个长度为1000000的字符串，然后求它所有前缀的不为1的最小循环周期。

POJ2752，题意：给一个字符串S，输出该字符串中既是前缀又是后缀的所有子串的长度，按照从小到大输出。
当然，我们用KMP可以这样做，先求next数组，然后next[len]就是除了S本身外满足条件的最长子串长度，然后我们按照它的
next数组递归就行了]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>118</wp:post_id>
		<wp:post_date><![CDATA[2015-11-22 16:04:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-22 08:04:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b9%8bkmp%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>POJ 2752 (KMP 输出字符串中既是前缀又是后缀的所有子串的长度)</title>
		<link>http://acmerbar.com/126.html</link>
		<pubDate>Sun, 22 Nov 2015 08:06:29 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=126</guid>
		<description></description>
		<content:encoded><![CDATA[POJ2752，题意：给一个字符串S，输出该字符串中既是前缀又是后缀的所有子串的长度，按照从小到大输出。
当然，我们用KMP可以这样做，先求next数组，然后next[len]就是除了S本身外满足条件的最长子串长度，然后我们按照它的
next数组递归就行了
T[]="aaaaa"
i= 1 2 3 4 5
nextv[]=0 1 2 3 4

代码：
<pre class="lang:c++ decode:true  ">/*
* Problem: POJ No.2752
* Running time: 452MS
* Complier: G++
* Author: herongwei
* Create Time: 15:56 2015/11/22 星期日
*/
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn=1e6+10;
const int MOD=1e9+7;
typedef long long LL;
char S[maxn],T[maxn];
int nextv[maxn];
int Tlen,Slen;
void GetNext(char *T)
{
    int i=0,j=-1;
    nextv[0]=-1;
    while(i&lt;Tlen)
    {
        if(j==-1||T[i]==T[j]) ///T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
        {
            ++i;
            ++j;
            nextv[i]=j;
//            if(T[i]!=T[j])///如果当前字符和前缀字符不同，则当前的j为nextv在i位置的值
//                nextv[i]=j;
//            else
//                nextv[i]=nextv[j];///如果相等，将前缀字符的nextv值赋给nextv在i位置的值
        }
        else j=nextv[j];   ///若字符不相等，则j值回溯
    }
}
int ans[maxn];
int main()
{
    //freopen("1.txt","r",stdin);
    while(scanf("%s",T)!=EOF)
    {
        Tlen=strlen(T);
        GetNext(T);
        int k=0,i = Tlen;
        ans[0] = Tlen;
        while(nextv[i] &gt; 0)
        {
            i=nextv[i];
            ans[++k] = i;
        }
        for(int i=k; i&gt;0; i--)
            printf("%d ",ans[i]);
        printf("%d\n",ans[0]);
    }
    return 0;
}
/*
ababcababababcabab
aaaaa

2 4 9 18
1 2 3 4 5

*/</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>126</wp:post_id>
		<wp:post_date><![CDATA[2015-11-22 16:06:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-22 08:06:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-2752-kmp-%e8%be%93%e5%87%ba%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%97%a2%e6%98%af%e5%89%8d%e7%bc%80%e5%8f%88%e6%98%af%e5%90%8e%e7%bc%80%e7%9a%84%e6%89%80%e6%9c%89%e5%ad%90%e4%b8%b2%e7%9a%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="kmp"><![CDATA[KMP]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《你只是看起来很努力》读书笔记</title>
		<link>http://acmerbar.com/130.html</link>
		<pubDate>Mon, 23 Nov 2015 13:36:05 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=130</guid>
		<description></description>
		<content:encoded><![CDATA[作者简介：

李尚龙

2008年，以优异成绩考上重点军校。

2010年，荣获<a href="http://baike.baidu.com/subview/5580/5263051.htm">CCTV</a>“希望英语”英语演讲风采大赛全国季军。

2010年  同年荣获全军二等功。

2011年，纵是万般阻碍也毅然退学，后加入“新东方”。

2015年，他写的文章《你只是看起来很努力》等被《人民日报》刊登，网络转载千万次；他越来越多的文章在微信、微博、知乎等平台被热传，影响着无数怀揣梦想的年轻人；

&nbsp;

&nbsp;

<strong>“看起来每天熬夜，却只是拿着手机点了无数个赞；</strong>

<strong>看起来起那么早去上课，却只是在课堂里补昨天晚上的觉；</strong>

<strong>看起来在图书馆坐了一天，却真的只是坐了一天；</strong>

<strong>看起来去了健身房，却只是在和帅哥，美女聊天搭讪。”</strong>

<strong>第一篇，直接来四个排比句，“看起来”，看起来，描述的是一种你在别人眼中的客观状态</strong>

<strong>你在干什么？，“熬夜”，“起得很早去上课”，“去图书馆”，“去健身房锻炼”</strong>

<strong>这些看起来的表象下面你真的在干什么？ “却只是…”哦，原来你只是看起来</strong>

<strong>很直接！，也很现实！，很打脸！</strong>

目录：

【1】“梦想和奋斗-你只是看起来很努力”

【2】“爱情和承诺-不后悔，就值得”

【3】“亲情和友情-下次告别，就在用心一点吧”

【4】“读书-那些毁掉我的书”

&nbsp;

读书摘抄：

&nbsp;

<u>“这种感觉你不一定要让别人知道，有时候你也在深夜去痛斥这个世界的不公平，你说自己这么努力，为什么那个谁看起来一点也不用心，最后却而有了很好的成绩，可是，他们背后和你的背后，究竟做了一些什么？你的生活和别人看到的你的生活，是不是一样呢？因此，你知道，哪些所谓的努力时光，真的的头脑风暴过了吗？真的问心无愧了吗？，或者，它只是看起来很努力而已。”</u>

&nbsp;

<u>“寝室，是堕落的开始，合群，是淘汰的起点。”</u>

<u> </u>

<u>“以赚钱为目的的兼职，是最愚蠢的投资。”</u>

<u> </u>

<u>“没有什么路是白走的，没有什么事情是白做的，这些看起来无意义的事情，都是成长的基石。在我们的生命中的每个插曲都有着自己改有的意义，所以不要抱怨为什么不早点做，跟不用后悔要是做了什么就好了，你有后悔，抱怨的时间，不如整装待发前进起来。有时候只要走错了路，才逐渐明白自己要的未来，只有交错了朋友，才逐渐知道什么事患难见真情，只有爱错过人，才逐渐懂得真爱是什么。”</u>

<u> </u>

<u>“别和负能量的人在一起”</u>

<u> </u>

<u>“过好每一天，过明白每一天，每一天细化成几个阶段，列下优先级，一点点地做：行走，记录，总结。大理想是要以天为单位的。”</u>

<u> </u>

<u>关于读书：</u>

<u> </u>

<u>“书不会让我们暴富，不能让我们出名，但是能让我们内心深处充满安静，读完一本书，写写笔记，思考这本书给我带来了什么，得到了什么，一些好的文字，去看第二遍，你会明白，内心的宁静和充实才是你最重要的东西。”</u>

<strong><u> </u></strong>

<strong><u>“你总是要度过生存期，才能适合谈梦想” </u></strong><strong><u>，加油吧，少年！</u></strong>

<strong><u> </u></strong>

<u>11/23/2015 20:35</u>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>130</wp:post_id>
		<wp:post_date><![CDATA[2015-11-23 21:36:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-23 13:36:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e4%bd%a0%e5%8f%aa%e6%98%af%e7%9c%8b%e8%b5%b7%e6%9d%a5%e5%be%88%e5%8a%aa%e5%8a%9b%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[38]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[如何做好每天的计划? | 加贝木苇的理想国]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://acmerbar.com/217.html</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[96.44.157.19]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-12-13 18:04:02]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-12-13 10:04:02]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] ps:这个无为该怎么来衡量？也许在别人看起来你表面上做了很多事情，也许在你自己看起来也做了不少事情，但是实际效率并不高，你真的以为自己很努力，还是你只是看起来很努力   Task：当天或短期任务。这个很容易理解，就是你每天都可以采取的行动。然后工作中每完成一项就把它划掉（这个是很有成就感的）。   Think：当天的思考、心得、体会。一个人工作要创新，能力要提升，修养要提高，就得时时思考（包括反思）。思考记 录下来很有用。比如公司实施创新平台计划，我看书，看到某个公司的好的做法，就记录下来，有空去翻翻，思考公司能不能这样做。很多好的idea就是这样产 生的。还有公司的周报的一栏是工作心得，但是工作心得不能靠你写周报才去思考，那样强迫思考的心得不能打动人，也不能给人以启迪和思考。这个也不需要写很 多字，就当微博去写就行。  Question：当天工作和生活遇到的问题。问题需要你去解决，但现实情况是问题一多人靠脑袋就记不住了。遇到问题一时解决不了的，记下来，有空翻翻想想，就等于延长了脑袋的思考时间，一些问题就是这样解决的。另外问题也是创新的一个源头。 Record：杂事记录。比如开会、收到包裹或者汇款记之类的杂事，就是所有你认为记录都记录下来作为备忘录。  转载自强哥博客：如何做好每天的计划   此条目发表在学习笔记/总结分类目录。将固定链接加入收藏夹。    &larr; POJ 3013 Big Christmas Tree(最短路Dijkstra+优先队列优化||SPFA) [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1450001042.7690899372100830078125;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1450001788.6812670230865478515625;s:5:"event";s:15:"status-approved";s:4:"user";s:6:"jiabei";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>《大学启示录I》</title>
		<link>http://acmerbar.com/131.html</link>
		<pubDate>Thu, 26 Nov 2015 05:00:37 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=131</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="article_content" class="article_content">

最近看了一些书，有了一些思考，如有雷同，纯属巧合。。
<blockquote>现实总是令人遗憾的，我们当中太多人已经习惯于沿着那一成不变的“典型成功道路”前进：中考，高考，考研，出国。。。数不清的人们在埋头赶路，走在前面的已然迷失，跟在后面的却还未开始思考，这不应该是一个国家，一个是时代的精神。</blockquote>
每个大学生都应该有自己的独立思考，并形成一种习惯，在大学里，不仅仅只是为了那单薄的一纸分数，而是要有勇气，有智慧，去发现并挑战那些比上课更重要的追求！
<blockquote>在网上看到这样的评论：国内绝大部分大学的本科教学，不是濒临崩溃，而是已经崩溃！</blockquote>
可见中国大学的教学是到了一种怎样的地步啊！

在当今流水线式的教育体制模式下，回头看看，我们就好像廉价的产品一样被一件件的生产出来，因为学生数目大，可以说没人对每一个人的教育质量负责，每个院 系有成百上千的学生，在这成百上千的学生中，每个人有不同的思想，有不同的知识背景，有不同的目标，不同的性格，不同的接受知识的能力，试想如何能用一个 所谓的统一的“教学培养计划”强制应用在每个人的身上呢？试想这样又能产生怎样的“教学”效果？

<strong>失败的思维方式</strong>

我们从小学，中学到大学一路教育过来，内心中本来就少得可怜的那种独立思考，批判精神，怀疑精神早就被消耗殆尽，失败的思维方式有无数种，在这仅列举博主目前所了解的几种：

<em>1.1  高考思维</em>

我们的体制总倾向于用一个量化的分数来衡量一个人，这一体制在高考中尤为突出，可以说是是达到了登峰造极的高度，高考“黑色六月”想必是中国每个大学生 心里难以磨灭的记忆，在大学里，以为“一考”定终身的时代已经结束，殊不知，扑向我们的是依然是无数的评分制度：从各科考试，总和测评，到毕业出国，读研 究生，留校保研，工作都少不了和分数打交道，面对这些分数，我们应该时刻保持大脑清醒：
<blockquote><em><strong>如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲者！</strong></em></blockquote>
无数过来人的经验：大学四年留给你的是你的人生，在你毕业之时，那一串苍白 的分数已经作废了！

<em>2.2 被动的思维</em>

人，迷茫的原因，在我看来，无非三个原因：看到太近，想到太多，做的太少。--<em>罗曼·罗兰</em>

无论做什么，我们都需要给自己找个理由，每天迫于生活压力，像个机器人的( ⊙ o ⊙ )似的的生活，忙碌，没有一点自己的主见，这不得不说是人生的一大悲哀！

每当开学季，在迈进大学校门的时候，我们面临的最大问题是：为什么要上课？或许我是问了一个脑残的问题异或问题本身很浅显，以至于我们懒得去真正思考我们为什么要上课？

“老师会点名” “学习啊” “为了记重点和难点” “ 为了抄笔记，作业”。。这些充其量只是我们被迫上课的借口，却不能成为我们真正要去上课的理由！
<blockquote><strong><em>真正能成为我们上课理由的，只有我们对科学文化知识的强烈渴望</em></strong></blockquote>
听起来是这么一回事，但是真正的带这种理由去上课的大学生又有多少呢？

如果上课对于你来说只是玩玩手机，只是抄抄作业，只是看看小说，只是打磨时间

如果你真正感兴趣的东西不在课堂，或者课堂上获得的知识你觉得已经落后。

如果上课学习的效果足够差，效率足够低，以至于通过自己自习，能够在更短的时间掌握知识

那么，你还需要去上课吗？

<em>3.3 无形的思维压力</em>

有形：日常生活中看到见的事情，通过考试，考驾照。。

无形：一些习惯养成，思维养成，“贫穷的思维”。。
<blockquote>有形的困难贯穿我们日常的始终，可以说日子就是解决一个个有形困难的线性序列，它繁琐，无孔不入，但易被识破进而攻破，我有一个观点：当一个人开始树立起 无形的敌人时，就是他成熟的起点，解决有形困难，有有形敌人抗争，似乎是我们趋利避害的本能，但是无形敌人的树立，则是智慧和经验积累的结果，很多人终其 一生，都是在有形的苦难中斗得你死我活，而真正伟大的人则是把无形的敌人放在首位</blockquote>
对于当今的大学生来说，这种无形的敌人意识树立非常重要，甚至可以说这是奋斗的本质，永不停歇，永远奔跑！

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date><![CDATA[2015-11-26 13:00:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 05:00:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e5%a4%a7%e5%ad%a6%e5%90%af%e7%a4%ba%e5%bd%95i%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e6%84%9f%e6%82%9f%e4%bd%93%e4%bc%9a"><![CDATA[感悟体会]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>浅谈C/C++的time_t函数</title>
		<link>http://acmerbar.com/132.html</link>
		<pubDate>Thu, 26 Nov 2015 05:27:44 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=132</guid>
		<description></description>
		<content:encoded><![CDATA[最近翻到《C专家编程》前言看到time_t函数，竟然一时之间全无概念，只是约莫知道是个有关时间的函数，这对已经学了C/C++的博主来说，简直是个嘲讽，本机测试了一下，大概是下面这个样子：
<pre class="lang:c++ decode:true">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;time.h&gt;
using namespace std;
/*常用的时间函数： */
///将结构中的信息转换为真实世界的时间，以字符串的形式显示
char *asctime(const struct tm* timeptr);

///将timep转换为真实世界的时间，以字符串的形式显示,和asctime传入参数不一样
char *ctime(const time_t *timep);

///返回两个时间差的秒数
double difftime(time_t time1, time_t time2);

///返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用
int get_time_of_day(struct timeval *tv,struct timezone *tz);

///将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针
struct tm* gmtime(const time_t *timep);

///和gmtime类似，但是它是经过时区转换的时间。
struct tm* localtime(const time_t *timpe);

///将struct tm 结构的时间转换为从1970年至今的秒数
time_t mktime(struct tm* timeptr);

///取得从1970年1月1日至今的秒数。
time_t time(time_t *t);

int main()
{
    /*运行程序用系统命令date显示本机时间为： Thu Nov 26 12:53:13 2015*/

    time_t biggest= 0x7fffffff; /// time_t所能表示的最大值
    printf("biggest= %s \n", ctime(&amp;biggest));
    printf("biggest= %s \n", asctime(gmtime(&amp;biggest)));

   /* 输出：
        biggest= Tue Jan 19 11:14:07 2038
        biggest= Tue Jan 19 03:14:07 2038
    我们发现整整差了8个小时，这是因为ctime()函数把参数转换为当地时间，跟世界统一时间UTC（格林尼治时间）并不一样
    取决于所在的时区，参照上面函数说明可以知道：
    gmtime()函数是将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针
    */
  /*可以测试一下下面两个例子*/
    time_t timep;
    time(&amp;timep);  ///获取time_t类型的当前时间
    printf("%s\n", asctime( gmtime(&amp;timep)));
    /// 输出： Thu Nov 26 04:44:40 2015 ///没有经过时区转换的UTC时间

   time_t timep;
   time(&amp;timep);
   printf("%s\n", ctime(&amp;timep));
   ///输出： Thu Nov 26 12:53:13 2015   ///经过时区转换的UTC时间
    return 0;
}</pre>
经过其他测试，我们可以总结：
time，gmtime，asctime 所表示的时间都是UTC时间，只是数据类型不一样；
而localtime，ctime 所表示的时间都是经过时区转换后的时间，它和你用系统命令date所表示的CST时间应该保持一致。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>132</wp:post_id>
		<wp:post_date><![CDATA[2015-11-26 13:27:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 05:27:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b5%85%e8%b0%88cc%e7%9a%84time_t%e5%87%bd%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[74]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>旋转字符串</title>
		<link>http://acmerbar.com/133.html</link>
		<pubDate>Thu, 26 Nov 2015 11:04:17 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=133</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>Problem 1 旋转字符串</h2>
<h3><a id="user-content-题目描述" class="anchor" href="http://taop.marchtea.com/01.01.html#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"> </a> 题目描述</h3>
给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原 字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。
<pre class="lang:c++ decode:true">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;time.h&gt;
using namespace std;

const int maxn=1e5+10;
typedef long long LL;
int vol[maxn],wei[maxn],dp[maxn];
char str[maxn];
int n,m,len;
/*
旋转字符串
题目描述
给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，
如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，
使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，
要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。
*/
void str_reverse(char str[],int n)
{
    char t=str[0];
    for(int i=1; i&lt;n; ++i)
    {
        str[i-1]=str[i];
    }
    str[n-1]=t;
}
void solve1()
{
    while(m--) str_reverse(str,n);
}

void str_reverse2(char str[],int from,int to)
{
    while(from&lt;to)
    {
        char t=str[from];
        str[from++]=str[to];
        str[to--]=t;
    }
}
void solve2()
{
    m%=n;
    str_reverse2(str,0,m-1);
    str_reverse2(str,m,n-1);
    str_reverse2(str,0,n-1);
}

int main()
{
    freopen("1.txt","r",stdin);
    while(~scanf("%s%d",str,&amp;m))
    {
        n=strlen(str);
        cout&lt;&lt;"pre str is"&lt;&lt;" "&lt;&lt;str&lt;&lt;" m="&lt;&lt;m&lt;&lt;endl;
        solve2();
        cout&lt;&lt;"last str is"&lt;&lt;" "&lt;&lt;str&lt;&lt;endl;
    }
    return 0;
}

</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>133</wp:post_id>
		<wp:post_date><![CDATA[2015-11-26 19:04:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 11:04:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%97%8b%e8%bd%ac%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>字符串包含</title>
		<link>http://acmerbar.com/134.html</link>
		<pubDate>Thu, 26 Nov 2015 11:05:06 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=134</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>Problem 2 字符串包含</h1>
<h2><a id="user-content-题目描述" class="anchor" href="http://taop.marchtea.com/01.02.html#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"> </a> 题目描述</h2>
给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？

为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &amp;A, string &amp;B)

比如，如果是下面两个字符串：

String 1：ABCD

String 2：BAD

答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。

如果是下面两个字符串：

String 1：ABCD

String 2：BCE

答案是false，因为字符串String2里的E字母不在字符串String1里。

同时，如果string1：ABCD，string 2：AA，同样返回true。
<pre class="lang:c++ decode:true ">/*
Problem 2
题目描述
给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，
如何最快地判断字符串B中所有字母是否都在字符串A里？
为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数
bool StringContains(string &amp;A, string &amp;B)
比如，如果是下面两个字符串：
String 1：ABCD
String 2：BAD
答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。
如果是下面两个字符串：
String 1：ABCD
String 2：BCE
答案是false，因为字符串String2里的E字母不在字符串String1里。
同时，如果string1：ABCD，string 2：AA，同样返回true。
*/
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;time.h&gt;
using namespace std;

const int maxn=1e5+10;
char str[maxn];
int n,m,len;
int ans[maxn];
/*
先把长字符串a中的所有字符都放入一个ans里，然后轮询短字符串b，看短字符串b的每个字符是否都在Hans里，
如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。
时间复杂度O(n + m)，空间复杂度O(1)
*/
string a,b;
bool StringContains1(string &amp;a,string &amp;b)
{
    memset(ans,0,sizeof(ans));
    int alen=a.length();
    int blen=b.length();
    bool ok=0;
    for(int i=0; i&lt;alen; ++i){
        ans[a[i]-'a']++;
    }
    for(int i=0; i&lt;blen; ++i){
        if(ans[b[i]-'a']) continue;
        else  { ok=1; break;}
    }
    if(ok) puts("false");
    else puts("true");
}
/*对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。
时间复杂度O(n + m)，空间复杂度O(1)
*/
bool StringContains2(string a,string b)
{
    int alen=a.length();
    int blen=b.length();
    int hash=0;
    bool ok=0;
    for(int i=0; i&lt;alen; ++i){ /// '|' 按位或 只要对应的二个二进位有一个为1时，结果位就为1
            int t=(1&lt;&lt;a[i]-'a');cout&lt;&lt;"t= "&lt;&lt;t&lt;&lt;endl;
            hash |= (1&lt;&lt;(a[i]-'a')),cout&lt;&lt;"hash= "&lt;&lt;hash&lt;&lt;endl;
    }
    for(int i=0; i&lt;blen; ++i){
        if((hash &amp; (1&lt;&lt;(b[i]-'a')))==0){ /// '&amp;' 按位与，只有两个二进制同为1才为1
            ok=1;break;
        }
    }
    if(ok) puts("false");
    else puts("true");
}

int main()
{
    freopen("1.txt","r",stdin);
    while(cin&gt;&gt;a&gt;&gt;b){
        StringContains2(a,b);
    }
    return 0;
}
/*
example input
abcdefg abcde
abcdefg achj
abcd bcee

example output
true
false
false
*/
</pre>
【拓展】如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，问如何在迅速匹配兄弟字符串（如，bad和adb就是兄弟字符串）。

<strong>思路一：用计数排序</strong>
设计一个数组，对单词每个字母计数加1，对兄弟单词每个字母计数减去1，如果最后这个数组的计数是0，那么就为兄弟单词。

<strong>思路二：哈希表</strong>
①先创建哈希表，统计字符串1中出现的次数；
②将哈希表扫描第二个字符串时，扫描到每个字符时候，为哈希表减去1，
③如果最后哈希表所有的值都为0，则为变位词，否则不是变位词

<strong>思路三：使用哈希表和链表</strong>
①将每个字母对应一个质数，之后让对应的质数相乘（有溢出风险），将得到的值放入哈希表中作为key
②使用链表将所有兄弟单词串在一起
③用户输入单词，我们之间遍历哈希表，将链表遍历输出得到所有的兄弟单词。

<strong>思路四：使用trie树</strong>

效率应该是最高的，请读者自行思考如何实现。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>134</wp:post_id>
		<wp:post_date><![CDATA[2015-11-26 19:05:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 11:05:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%85%e5%90%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e3%80%8a%e7%a8%8b%e5%ba%8f%e5%91%98%e7%bc%96%e7%a8%8b%e8%89%ba%e6%9c%af%e3%80%8b"><![CDATA[《程序员编程艺术》]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Head</title>
		<link>http://acmerbar.com/136.html</link>
		<pubDate>Fri, 27 Nov 2015 03:32:36 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=136</guid>
		<description></description>
		<content:encoded><![CDATA[学而不思则罔，思而不学则殆。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>136</wp:post_id>
		<wp:post_date><![CDATA[2015-11-27 11:32:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-27 03:32:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%94%9f%e5%91%bd%e4%b8%8d%e6%81%af%e5%a5%8b%e6%96%97%e4%b8%8d%e6%ad%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[14]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU (杭电) 计算机学院大学生程序设计竞赛（2015’11）</title>
		<link>http://acmerbar.com/144.html</link>
		<pubDate>Sun, 29 Nov 2015 08:24:24 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=144</guid>
		<description></description>
		<content:encoded><![CDATA[比赛链接：<a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=638" target="_blank">http://acm.hdu.edu.cn/contests/contest_show.php?cid=638</a>

赛后几题代码参考：<a href="http://blog.csdn.net/u013050857/article/details/50097027" target="_blank">加贝木苇的BLOG</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>144</wp:post_id>
		<wp:post_date><![CDATA[2015-11-29 16:24:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-29 08:24:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-%e6%9d%ad%e7%94%b5-%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%ad%a6%e9%99%a2%e5%a4%a7%e5%ad%a6%e7%94%9f%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%ab%9e%e8%b5%9b%ef%bc%88201511%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%9d%ad%e7%94%b5%e6%a0%a1%e8%b5%9b%ef%bc%88201511%ef%bc%89"><![CDATA[杭电校赛（2015/11）]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《计算机网络--传输层》</title>
		<link>http://acmerbar.com/146.html</link>
		<pubDate>Wed, 02 Dec 2015 02:58:37 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=146</guid>
		<description></description>
		<content:encoded><![CDATA[<strong><span style="text-decoration: underline;">TCP/IP 的传输层有两个不同的协议：</span></strong>
(1) 用户数据报协议 UDP (User Datagram Protocol)
(2) 传输控制协议 TCP    (Transmission Control Protocol)

当传输层采用<span style="text-decoration: underline;">无连接</span>的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。
UDP 在传送数据之前不需要先建立连接。对方的传输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP <span style="text-decoration: underline;">不提供可靠交付</span>，但在某些情况下 UDP 是一种最有效的工作方式。

当传输层采用<span style="text-decoration: underline;">面向连接</span>的 TCP 协议时，尽管下面的网络层是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<span style="text-decoration: underline;">全双工的可靠信道</span>。
由于 TCP 要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。

图示：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/2015-12-02-102736屏幕截图.png"><img class="aligncenter size-large wp-image-148" src="http://acmerbar.com/wp-content/uploads/2015/12/2015-12-02-102736屏幕截图-1024x640.png" alt="" width="640" height="400" /></a><strong>UDP和TCP的区别：</strong>

【1】UDP 是无连接的，即发送数据之前不需要建立连接，因而减少了开销和发送数据之前的时延。
【2】UDP没有拥塞控制，也不保证可靠交付，因此主机不需要维持具有许多参数的、复杂的连接状态表。
【3】网络出现的拥塞不会使源主机的发送速率降低。这对传输实时数据是很重要的。
【4】UDP 支持一对一、一对多、多对一和多对多的交互通信。
【5】UDP 的首部开销小，只有 8 个字节。
【6】UDP 是面向报文的。

UDP首部格式图示：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/udp截图.png"><img class="aligncenter size-large wp-image-149" src="http://acmerbar.com/wp-content/uploads/2015/12/udp截图-1024x640.png" alt="" width="640" height="400" /></a>而TCP 是面向连接的传输层协议。
由于TCP 连接只能有两个端点(endpoint)，因此TCP 连接只能是点对点的（一对一）。TCP 不能用于多播和广播。
【1】TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达。
【2】TCP 提供全双工通信，面向字节流。

TCP首部格式图示：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/TCP.png"><img class="aligncenter size-large wp-image-150" src="http://acmerbar.com/wp-content/uploads/2015/12/TCP-1024x640.png" alt="" width="640" height="400" /></a>其中：最重要的一个选项是允许主机说明自己可以接受的最大TCP载荷，即最大报文段长度 MSS，MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”

<strong>1.TCP传输包括：</strong>

【1】TCP可靠性保证：

1.  TCP 服务器和客户端在传输之前先建立起连接。
2.  TCP发出报文后启动重传计时器。如果在计时器未超时的时间内收到确认报文，表明该数据成功发送到了接收方。如果计时器超时后还没收到确认报文，则重发该报文。
3.  接收端收到正确报文后会在合适的时间向发送端发送该报文的确认。如果收到的是不正确的报文，则不发送确认报文，而是等待发送端重新发送该报文。一般情况下，该确认报文是和其他的数据报文一同发送的（捎带确认）。
4.  报文的正确与否是通过TCP 报文的检验和字段来检查的。
5.  TCP 传输的可靠性还包括报文的顺序，TCP会排列报文的顺序。
6.  TCP协议会丢弃重复的报文。

【2】TCP流量控制：

流量控制(flow control)的目的：
就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
流量控制定义了发送方在收到从接收方发来的确认之前可以发送的数据量。
TCP协议使用缓存和滑动窗口协议进行流量控制。

缓存和滑动窗口协议。

【3】 TCP的拥塞控制

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。
出现网络拥塞的条件：
<span style="color: #ff0000;">   对资源需求的总和 &gt; 可用资源</span>
若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

<strong>2.拥塞控制与流量控制的关系：</strong>

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。
流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。
流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

下面介绍四种常见拥塞控制的方法：
<span style="text-decoration: underline;">慢开始（slow-start）：逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </span>
<span style="text-decoration: underline;">拥塞避免（congestion avoidance）：拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</span>

发现这种拥塞控制算法还需要改进，因为有时一条TCP连接会因等待重传计时器的超时而空闲较长的时间。为此以后又增加了两个新的拥塞控制算法。这就是<span style="text-decoration: underline;">快重传和快恢复。</span>
<span style="text-decoration: underline;">快重传（fast retransmit）：快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。
发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。
不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 </span>
<span style="text-decoration: underline;">快恢复（fast recovery）：(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 变为当前拥塞窗口 cwnd 的一半。但接下去不执行慢开始算法。
(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为新的慢开始门限 ssthresh 的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 </span>

我们假定：
数据是单方向传送，而另一个方向只传送确认。
接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。

<strong>3.发送窗口的上限值</strong>

在实际情况中，接收方的接收缓存总是有限的，因此发送方的发送窗口就不能直接取为拥塞窗口的大小。
发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：
发送窗口的上限值  Min [rwnd, cwnd]
当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。
当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。

<strong>4.熟知端口：</strong>

熟知端口又成为保留端口，由 IANA（互联网地址指派机构）以全局方式进行统一分配并公之于众。
熟知端口分配给服务器进程使用，每一种标准的服务器都分配有一个全局公认的端口号。
熟知端口只占一小部分， TCP 和 UDP 均规定，号码为0~1023的端口才能作为熟知端口

<span style="text-decoration: underline;">常见的熟知端口：</span>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/2015-12-02-102158屏幕截图.png"><img class="aligncenter wp-image-147 size-large" src="http://acmerbar.com/wp-content/uploads/2015/12/2015-12-02-102158屏幕截图-1024x640.png" alt="" width="640" height="400" /></a>

&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>146</wp:post_id>
		<wp:post_date><![CDATA[2015-12-02 10:58:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-02 02:58:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-%e4%bc%a0%e8%be%93%e5%b1%82%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c"><![CDATA[计算机网络]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《计算机网络--TCP的三次握手》</title>
		<link>http://acmerbar.com/151.html</link>
		<pubDate>Wed, 02 Dec 2015 03:25:13 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=151</guid>
		<description></description>
		<content:encoded><![CDATA[TCP 的运输连接管理

严格来说其实是四次传输过程。

下面给出图示，希望能详细的解释其中的原理：

首先，我们知道，运输连接有三个阶段，即：连接建立、数据传送和连接释放。
连接建立过程中要解决以下三个问题：
【1】要使每一方能够确知对方的存在。
【2】要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。
[3】能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。

其次，弄清连接方式

TCP 连接的建立都是采用客户服务器方式（简称CS）。
主动发起连接建立的应用进程叫做客户(client)。
被动等待连接建立的应用进程叫做服务器(server)。

连接图示：

其中：SYN：同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。

ACK：确认 ACK —— 只有当 ACK 为1 时确认号字段才有效。当 ACK 为 0 时，确认号无效，TCP规定，在连接建立后所有传送的报文都必须把 ACK 置1。

当SYN与ACK同为1时，表示请求连接。

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp01.png"><img class="aligncenter size-large wp-image-152" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp01-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp02.png"><img class="aligncenter size-large wp-image-153" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp02-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp03.png"><img class="aligncenter size-large wp-image-154" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp03-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp04.png"><img class="aligncenter size-large wp-image-155" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp04-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp05.png"><img class="aligncenter size-large wp-image-156" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp05-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp06.png"><img class="aligncenter size-large wp-image-157" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp06-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp07.png"><img class="aligncenter size-large wp-image-158" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp07-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp08.png"><img class="aligncenter size-large wp-image-159" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp08-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp09.png"><img class="aligncenter size-large wp-image-160" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp09-1024x640.png" alt="" width="640" height="400" /></a>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/tcp10.png"><img class="aligncenter size-large wp-image-161" src="http://acmerbar.com/wp-content/uploads/2015/12/tcp10-1024x640.png" alt="" width="640" height="400" /></a>

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>151</wp:post_id>
		<wp:post_date><![CDATA[2015-12-02 11:25:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-02 03:25:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-tcp%e7%9a%84%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c"><![CDATA[计算机网络]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《计算机网络--网络层》</title>
		<link>http://acmerbar.com/163.html</link>
		<pubDate>Wed, 02 Dec 2015 12:04:26 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=163</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>网络层的重点概念</strong>

1 网络层概述

2 IPv4协议（重点）

3 网络层的协议（重点）

4 路由算法和路由协议（重点、难点）

5 IPv6 协议（了解）

6 网络层设备（了解）

<strong>【1】网络层概述</strong>

网络层的功能

网络层是<span style="text-decoration: underline;">解决网络与网络之间，即网际的通信问题，将分布在不同地理位置、相同或不同类型的计算机网络连成一个网，进行高速数据通信，实现资源共享和分布式处理。</span>

网络层的主要功能：
<ol>
	<li>提供路由，选择到达目标主机的最佳路径，并沿该路径传送数据包。</li>
	<li>消除网络拥挤，具有流量控制和拥挤控制的能力。</li>
	<li>建立和拆除网络连接，网络连接多路复用，分段和组块，服务选择和传输。</li>
</ol>
网络层位于数据链路层之上，传输层之下。网络层向下使用了数据链路层所提供的相邻节点之间的数据传输服务，向上为传输层提供了从源到目标的数据传输服务。

网络层是处理端到端（end to end）数据传输的最低层，同时又是通信子网的最高层。

开放互联网模型：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/开放互联网模型.png"><img class="aligncenter size-medium wp-image-164" src="http://acmerbar.com/wp-content/uploads/2015/12/开放互联网模型-300x219.png" alt="" width="300" height="219" /></a>

&nbsp;

网络层只向上层提供简单灵活的、无连接的、尽最大努力交付的数据报服务。

优点：

由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，运行方式灵活，能够适应多种应用而且价格低廉。

如果用户主机（即端系统）中的进程之间的通信需要是可靠的，那么就由主机中的传输层负责（包括差错处理、流量控制等）。

<strong>【2】IPv4协议</strong>

IP （Internet Protocol，互联网协议）是TCP/IP协议族中网络层的协议，是TCP/IP协议族的核心协议。

目前使用的是IP协议第四版（IPv4），也是第一个被广泛使用，构成现今互联网技术的基石的协议。

<a href="http://acmerbar.com/wp-content/uploads/2015/12/IPv4协议图示.png"><img class="aligncenter size-medium wp-image-165" src="http://acmerbar.com/wp-content/uploads/2015/12/IPv4协议图示-300x274.png" alt="" width="300" height="274" /></a>

使用IP地址的原因：

（1）物理网络的差异已经存在（以太网、令牌环网、FDDI、帧中继、X.25、HDLC、PPP）。

（2）使用IP地址寻址时，设备更易于移动和维修。例如，如果一个网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。

（3）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。

IP地址分为IPv4(32位)，IPv6(128位)

IP地址划分：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/IP地址划分.png"><img class="aligncenter size-medium wp-image-166" src="http://acmerbar.com/wp-content/uploads/2015/12/IP地址划分-300x221.png" alt="" width="300" height="221" /></a>

即：

网络        最大                  第一个       最后一个         每个网络

类别      网络数                可用的         可用的           中最大的

网络号         网络号             主机数

A      126 (27 – 2)            1              126                16,777,214

B      16,383(214 - 1)      128.1       191.255                 65,534

C     2,097,151 (221 - 1) 192.0.1   223.255.255                254

<strong>【3】 IP 地址的一些重要特点</strong>

(1)  IP 地址是一种分等级的地址结构。分两个等级的好处是：

第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。

第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。

(2)  实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。

当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机(multihomed host)。

由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。

(3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。

(4) 所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。

<span style="color: #ff0000;">特殊IP地址：</span>

a.回送地址

IP地址中以127开始的IP地址作为保留地址，被称为“回送地址”。回送地址用于网络软件的测试，以及本地进程的通信。

任何程序一旦<u>接到使用了回送地址为目的地</u>址的数据，则该程序将不再转发数据，而是将其立即回送给源地址。

b.直接广播地址（Directed Brordcasting）

<b>      </b>将主机号各位全为“1”的IP地址称为直接广播地址。该地址主要用于广播，在使用时，用来代表该网络上所有的主机，例如，202.112.144是一个C类的网络标识，该网络的广播地址就是202.112.144.255；当该网络中的某台主机需要发送广播时，就可以使用这个地址向该网络上的所有主机发送报文

c.有限广播地址（Limiting Brordcasting）

TCP/IP协议规定，32比特位全为“1”的IP地址（255.255.255.255）为“有限广播地址”，这个地址主要用来进行本网广播。当需要在本网内广播，又不知道本网的网络号时，即可使用“有限（受限）广播地址”

d.本网地址

<u>本网地址</u><b>：</b>将IP地址中主机地址位全为“0”的IP地址叫做本网地址。这个地址用来表示“本主机所连接的网络”。例如，用“128.16.0.0”表示“128.16”这个B类网络；用“202.112.144.0”表示“202.112.144”这个C类网络。本网地址又被称为“0”地址。

e.私有地址

公有地址（全局地址）：能够在整个广域网（因特网）中使用，可以被世界各地联网的主机所访问到。

私有地址（局部地址）：只能在一个局域网中使用，其作用域的范围就是一个局域网（出了局域网就无效）。所以不同的局域网中的主机IP地址可以一样。

（私有地址范围：

1个A类地址：10.0.0.0

16个B类地址： 172.16.0.0 ~ 172.31.0.0

256个C类地址： 192.168.0.0 ~ 192.168.255.0

）

<strong>【4】IP数据报格式</strong>

<a href="http://acmerbar.com/wp-content/uploads/2015/12/IP数据报格式.png"><img class="aligncenter size-medium wp-image-167" src="http://acmerbar.com/wp-content/uploads/2015/12/IP数据报格式-300x203.png" alt="" width="300" height="203" /></a>

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>163</wp:post_id>
		<wp:post_date><![CDATA[2015-12-02 20:04:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-02 12:04:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-%e7%bd%91%e7%bb%9c%e5%b1%82%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>51NOD1265 (四点共面)</title>
		<link>http://acmerbar.com/168.html</link>
		<pubDate>Fri, 04 Dec 2015 02:50:30 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[题目链接：<span style="color: #008000;"><a style="color: #008000;" href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1265" target="_blank">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1265</a></span>
<div class="HI">
<div class="M_20 F16E Gray30 LH_200">
<div>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出"Yes"，否则输出"No"。</div>
</div>
</div>
<div class="HI">
<div class="M_20 F16E Gray30">
<div class="F18E Black MB_10">Input</div>
<pre class="F16E Gray30">第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)
第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。</pre>
<div class="F18E Black MT_10 MB_10">Output</div>
<pre class="F16E Gray30">输出共T行，如果共面输出"Yes"，否则输出"No"。</pre>
<div class="F18E Black MT_10 MB_10">Input示例</div>
<pre class="PreText F12 Gray70">1
1 2 0
2 3 0
4 0 0
0 0 0</pre>
<div class="F18E Black MT_10 MB_10">Output示例</div>
<pre class="PreText F12 Gray70">Yes</pre>
<div class="LH_120 P_10 BGGrayF4">
<div class="FL F16 MT_5 ML_10"><span class="F14 Gray88">【思路】：
</span></div>
<div class="FL F16 MT_5 ML_10">solution one:</div>
<div class="FL F16 MT_5 ML_10">利用四阶行列式计算</div>
<div class="FL F16 MT_5 ML_10">

代码：
<pre class="lang:c++ decode:true ">/*
四阶行列式
   |x1,y1,z1,1|
   |x2,y2,z2,1|
if |x3,y3,z3,1| ==0 puts("Yes");
   |x4,y4,z4,1|
*/
#include &lt;stdio.h&gt;
struct node{
    int x,y,z;
}s[4];
int main(){
    int t,rx1, ry1, rz1, rx2, ry2, rz2, rx3, ry3, rz3;
    scanf("%d", &amp;t);
    while (t--) {
            for(int i=1; i&lt;=4; ++i)
                scanf("%d%d%d",&amp;s[i].x,&amp;s[i].y,&amp;s[i].z);
        rx1 = s[1].x - s[2].x; ry1 = s[1].y - s[2].y; rz1 = s[1].z - s[2].z;
        rx2 = s[1].x - s[3].x; ry2 = s[1].y - s[3].y; rz2 = s[1].z - s[3].z;
        rx3 = s[1].x - s[4].x; ry3 = s[1].y - s[4].y; rz3 = s[1].z - s[4].z;
        if(rx1*ry2*rz3 + ry1*rz2*rx3 + rz1*rx2*ry3 == rz1*ry2*rx3 + ry1*rx2*rz3 + rx1*rz2*ry3) puts("Yes");
        else puts("No");
    }
    return 0;
}
</pre>
</div>
<div class="FL F16 MT_5 ML_10"></div>
<div class="FL F16 MT_5 ML_10"> solution two:</div>
<div class="FL F16 MT_5 ML_10">

计算几何模板，求得任意三点确定的平面，进而求得法向量，在用最后一点连接其中三点中其中一点，该直线和法向量点积为0 则在同一平面：
<pre class="lang:c++ decode:true ">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
const int maxn=1e5+10;
const double eps=1e-8;
int n,m,t;
struct Point
{
    double X,Y,Z;
    Point() {}
    Point(double xx,double yy,double zz)
    {
        X=xx;
        Y=yy;
        Z=zz;
    }
    friend  Point operator - (Point a,Point b)
    {
        return Point(a.X - b.X , a.Y - b.Y , a.Z - b.Z);
    }
}p[4];
Point det3(Point a,Point b)///三个坐标的叉积
{
    return Point(a.Y * b.Z - a.Z * b.Y , a.Z *b.X - a.X * b.Z , a.X * b.Y - a.Y * b.X);
}
Point Faxl(Point a,Point b,Point c)
{
    return det3((a-b),(b-c));
}
double dot(Point a,Point b) ///点积
{
    return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
}
bool sign(double x)
{
    return fabs(x)&lt;eps;
}
int solve(Point a,Point b,Point c,Point d)
{
    return sign(dot(Faxl(a,b,c),d-a));
}
int main()
{
    //freopen("1.txt","r",stdin);
    int t;scanf("%d",&amp;t);
    while(t--)
    {
        for(int i=1; i&lt;=4; ++i)
            scanf("%lf%lf%lf",&amp;p[i].X,&amp;p[i].Y,&amp;p[i].Z);
        if(solve(p[1],p[2],p[3],p[4])) puts("Yes");
        else puts("No");
    }
    return 0;
}

</pre>
</div>
<div class="FL F16 MT_5 ML_10"></div>
<div class="FL F16 MT_5 ML_10"></div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date><![CDATA[2015-12-04 10:50:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-04 02:50:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[51nod1265-%e5%9b%9b%e7%82%b9%e5%85%b1%e9%9d%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>最长回文字符串（manacher算法）</title>
		<link>http://acmerbar.com/170.html</link>
		<pubDate>Fri, 04 Dec 2015 10:36:42 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=170</guid>
		<description></description>
		<content:encoded><![CDATA[<strong> 最长回文子串</strong>
<div class="page">
<div class="file-box">
<div class="file">
<div id="readme" class="blob instapaper_body announce md"><article class="markdown-body entry-content">
<h3><a id="user-content-题目描述" class="anchor" href="http://taop.marchtea.com/01.05.html#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"> </a> 题目描述</h3>
给定一个字符串，求它的最长回文子串的长度。
<h3><a id="user-content-分析与解法" class="anchor" href="http://taop.marchtea.com/01.05.html#%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E6%B3%95"> </a> 分析与解法</h3>
最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。
<h4><a id="user-content-解法一" class="anchor" href="http://taop.marchtea.com/01.05.html#%E8%A7%A3%E6%B3%95%E4%B8%80"> </a> 解法一</h4>
那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：
<pre class="lang:c++ decode:true">int LongestPalindrome(const char *s, int n)
{
    int i, j, max,c;
    if (s == 0 || n &lt; 1)
        return 0;
    max = 0;
    for (i = 0; i &lt; n; ++i) { // i is the middle point of the palindrome  
        for (j = 0; (i - j &gt;= 0) &amp;&amp; (i + j &lt; n); ++j){ // if the length of the palindrome is odd  
            if (s[i - j] != s[i + j])
                break;
            c = j * 2 + 1;
        }
        if (c &gt; max)
            max = c;
        for (j = 0; (i - j &gt;= 0) &amp;&amp; (i + j + 1 &lt; n); ++j){ // for the even case  
            if (s[i - j] != s[i + j + 1])
                break;
            c = j * 2 + 2;
        }
        if (c &gt; max)
            max = c;
    }
    return max;
}</pre>
代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。
<h4><a id="user-content-解法二on解法" class="anchor" href="http://taop.marchtea.com/01.05.html#%E8%A7%A3%E6%B3%95%E4%BA%8Con%E8%A7%A3%E6%B3%95"> </a> 解法二、O(N)解法</h4>
在上文的解法一：枚举中心位置中，我们需要特别考虑字符串的长度是奇数还是偶数，所以导致我们在编写代码实现的时候要把奇数和偶数的情况分开编写，是否有一种方法，可以不用管长度是奇数还是偶数，而统一处理呢？比如是否能把所有的情况全部转换为奇数处理？

答案还是肯定的。这就是下面我们将要看到的Manacher算法，且这个算法求最长回文子串的时间复杂度是线性O(N)的。

首先通过在每个字符的两边都插入一个特殊的符号，将所有可能的奇数或偶数长度的回文子串都转换成了奇数长度。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。

此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。

以字符串12212321为例，插入#和$这两个特殊符号，变成了 S[] = "$#1#2#2#1#2#3#2#1#"，然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。

比如S和P的对应关系：
<ul>
	<li>S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #</li>
	<li>P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1</li>
</ul>
可以看出，P[i]-1正好是原字符串中最长回文串的总长度，为5。

接下来怎么计算P[i]呢？Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论：
<ul>
	<li>如果mx &gt; i，那么P[i] &gt;= Min(P[2 * id - i], mx - i)</li>
</ul>
C代码如下：
<pre class="lang:c++ decode:true">//mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i)
//故谁小取谁
if (mx - i &gt; P[2*id - i])
    P[i] = P[2*id - i];
else  //mx-i &lt;= P[2*id - i]
    P[i] = mx - i;</pre>
下面，令j = 2*id - i，也就是说j是i关于id的对称点。

当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]；

<a href="https://camo.githubusercontent.com/6e347c94c2660435bde50fa5305135229c8d76cf/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437363238345f37393335346134372e706e67" target="_blank"> <img src="https://camo.githubusercontent.com/6e347c94c2660435bde50fa5305135229c8d76cf/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437363238345f37393335346134372e706e67" alt="" data-canonical-src="http://www.felix021.com/blog/attachment/1318476284_79354a47.png" /> </a>

当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是 说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，再具体匹配。

<a href="https://camo.githubusercontent.com/ff7edaf62027622be69d38aa3412b542328f8386/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437383131345f34333739666235632e706e67" target="_blank"> <img src="https://camo.githubusercontent.com/ff7edaf62027622be69d38aa3412b542328f8386/687474703a2f2f7777772e66656c69783032312e636f6d2f626c6f672f6174746163686d656e742f313331383437383131345f34333739666235632e706e67" alt="" data-canonical-src="http://www.felix021.com/blog/attachment/1318478114_4379fb5c.png" /> </a>

此外，对于 mx &lt;= i 的情况，因为无法对 P[i]做更多的假设，只能让P[i] = 1，然后再去匹配。

综上，关键代码如下：
<pre class="lang:c++ decode:true ">//输入，并处理得到字符串s
int p[1000], mx = 0, id = 0;
memset(p, 0, sizeof(p));
for (i = 1; s[i] != '\0'; i++) 
{
    p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;
    while (s[i + p[i]] == s[i - p[i]]) 
        p[i]++;
    if (i + p[i] &gt; mx) 
    {
        mx = i + p[i];
        id = i;
    }
}
//找出p[i]中最大的</pre>
此Manacher算法使用id、mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。

参考： <a href="http://www.felix021.com/blog/read.php?2040"> http://www.felix021.com/blog/read.php?2040 </a> 。另外，这篇文章也不错： <a href="http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html"> http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html </a> 。

【注意】认真弄懂思想很重要！

</article></div>
</div>
</div>
<div> 例题练习：</div>
<div>

51NOD1089
<div class="MB_5"><a class="F30Black" href="http://www.51nod.com/onlineJudge/questionCode.html#%21problemId=1089">1089 最长回文子串 V2（Manacher算法）</a></div>
<div class="MB_5">

参考代码：
<pre class="lang:c++ decode:true">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
const int maxn=1100;
int len,p[2*maxn];
char str[2*maxn],newstr[2*maxn];
inline int Min(int a,int b) {return a&lt;b?a:b;}
void Change()
{
    int i;
    newstr[0]='$';
    newstr[1]='#';
    for(int i=0; i&lt;len; ++i)
    {
        newstr[2*i+2]=str[i];
        newstr[2*i+3]='#';
    }
    newstr[2*len+2]='\0';
    return ;
}
void Manacher()
{
    int i,j,id,mx=0,ret=1;
    len=2*len+2;
    for(i=0; i&lt;len; ++i)
    {
        if(mx&gt;i)
        {
            p[i]=Min(p[2*id-i],mx-i);
        }
        else
        {
            p[i]=1;
        }
        while(newstr[i+p[i]] == newstr[i-p[i]])
            p[i]++;
        if(p[i]+i&gt;mx)
        {
            mx=p[i]+i;
            id=i;
        }
        if(p[i]&gt;ret)
            ret=p[i];
    }
    for(i=id, j=0; i&lt;id+ret; ++i)
    {
        if(newstr[i]!='#')
        {
            str[j]=newstr[i];
            j++;
        }
    }
    str[id+ret]='\0';
    printf("%d\n",ret-1);
}
int main()
{
    //freopen("1.txt","r",stdin);
    int tot=1;
    while(~scanf("%s",str))
    {
      //  if(strcmp(str,"END")==0) break;
        len=strlen(str);
       // printf("Case %d: ",tot++);
        Change();
        Manacher();
    }
    return 0;
}</pre>
</div>
<div class="MB_5">HDU3068：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=3068</a></div>
<div class="MB_5">POJ 3974 :<a href="http://poj.org/problem?id=3974" target="_blank">http://poj.org/problem?id=3974</a></div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>170</wp:post_id>
		<wp:post_date><![CDATA[2015-12-04 18:36:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-04 10:36:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%97%e7%ac%a6%e4%b8%b2%ef%bc%88manacher%e7%ae%97%e6%b3%95%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2"><![CDATA[最长回文子串]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《计算机网络--概论》</title>
		<link>http://acmerbar.com/173.html</link>
		<pubDate>Sat, 05 Dec 2015 13:19:24 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=173</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>1【计算机网络在信息时代的作用】</strong>

21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。
网络现已成为信息社会的命脉和发展知识经济的重要基础。
网络是指“三网”，即电信网络、有线电视网络和计算机网络。
发展最快的并起到核心作用的是计算机网络。

1.1因特网发展的三个阶段
<ul>
	<li>第一阶段是从单个网络 ARPANET 向互联网发展的过程。</li>
	<li>1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。</li>
	<li>人们把 1983 年作为因特网的诞生时间。</li>
</ul>
1.2主机和路由器的不同作用
<ul>
	<li>主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组。</li>
	<li>路由器对分组进行存储转发，最后把分组交付目的主机。</li>
</ul>
1.3分组交换的优点
<ul>
	<li>高效    动态分配传输带宽，对通信链路是逐段占用。</li>
	<li>灵活    以分组为传送单位和查找路由。</li>
	<li>迅速    不必先建立连接就能向其他主机发送分组。</li>
	<li>可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。</li>
</ul>
1.4ARPNET概念

<b>美国高等研究计划署网络</b>（<span class="LangWithName">英语：<span lang="en" xml:lang="en">Advanced Research Projects Agency Network</span></span>，缩写为 <b>ARPAnet</b>），为美国国防高等研究计划署开发的世界上第一个运营的封包交换网络，它是全球互联网的始祖。

五大特点：

⑴支持资源共享； ⑵采用分布式控制技术； ⑶采用分组交换技术； ⑷使用通信控制处理机； ⑸采用分层的网络通信协议。

1.5 几种不同类别的网络
<ul>
	<li>广域网 WAN (Wide Area Network)</li>
	<li>局域网 LAN (Local Area Network)</li>
	<li>城域网 MAN (Metropolitan Area Network)</li>
	<li>个人区域网 PAN (Personal Area Network)</li>
</ul>
1.6  计算机网络的性能指标

1.6.1  速率
<span style="text-decoration: underline;">比特</span>（bit）：是计算机中数据量的单位，也是信息论中使用的信息量的单位。
Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。
<span style="text-decoration: underline;">速率：</span>即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等
速率往往是指额定速率或标称速率。

<span style="text-decoration: underline;">“带宽”</span>(bandwidth)：本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。
现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。

在计算机界，K = 210 = 1024，   M = 220, G = 230, T = 240。

<span style="text-decoration: underline;">吞吐量</span>(throughput)：表示在单位时间内通过某个网络（或信道、接口）的数据量。

<span style="text-decoration: underline;"> 时延(delay 或 latency)：</span>传输时延（发送时延 ）    发送数据时，数据块从结点进入到传输媒体所需要的时间。

<span style="text-decoration: underline;">传播时延  ：</span>电磁波在信道中需要传播一定的距离而花费的时间。

<span style="text-decoration: underline;">处理时延  ：</span>交换结点为存储转发而进行一些必要的处理所花费的时间。
<span style="text-decoration: underline;">排队时延 ：</span>结点缓存队列中分组排队所经历的时延。

总时延 = 发送时延+传播时延+处理时延+处理时延

时延带宽积 = 传播时延 × 带宽

1.7五层协议的体系结构

<a href="http://acmerbar.com/wp-content/uploads/2015/12/11111111111111.png"><img class="aligncenter size-medium wp-image-174" src="http://acmerbar.com/wp-content/uploads/2015/12/11111111111111-300x176.png" alt="" width="300" height="176" /></a>TCP/IP体系结构

<a href="http://acmerbar.com/wp-content/uploads/2015/12/2222222222222222.png"><img class="aligncenter size-medium wp-image-175" src="http://acmerbar.com/wp-content/uploads/2015/12/2222222222222222-300x209.png" alt="" width="300" height="209" /></a>客户进程和服务器进程使用 TCP/IP 协议进行通信的图示：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/3333333333333333333337.png"><img class="aligncenter size-medium wp-image-176" src="http://acmerbar.com/wp-content/uploads/2015/12/3333333333333333333337-300x156.png" alt="" width="300" height="156" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>173</wp:post_id>
		<wp:post_date><![CDATA[2015-12-05 21:19:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-05 13:19:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c-%e6%a6%82%e8%ae%ba%e3%80%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>51NOD 1256乘法逆元</title>
		<link>http://acmerbar.com/178.html</link>
		<pubDate>Mon, 07 Dec 2015 05:49:13 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=178</guid>
		<description></description>
		<content:encoded><![CDATA[<div class="HI">
<div class="M_20 F16E Gray30 LH_200">
<div>

给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。
<div id="fastCSharp30_bjbgbsbbbnbf"></div>
</div>
</div>
</div>
<div class="HI">
<div class="M_20 F16E Gray30">
<div class="F18E Black MB_10">Input</div>
<pre class="F16E Gray30">输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9)</pre>
<div class="F18E Black MT_10 MB_10">Output</div>
<pre class="F16E Gray30">输出一个数K，满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</pre>
<div class="F18E Black MT_10 MB_10">Input示例</div>
<pre class="PreText F12 Gray70">2 3</pre>
<div class="F18E Black MT_10 MB_10">Output示例</div>
<pre class="PreText F12 Gray70">2</pre>
</div>
</div>
<div class="HI">
<div class="LH_120 P_10 BGGrayF4">
<div class="FL">乘法逆元：</div>
<div class="FL">
<div class="para">若ax≡1 mod f, 则称a关于模f的乘法逆元为x。也可表示为ax≡1(mod f)。</div>
<div class="para">当a与f互素时，a关于模f的乘法逆元有唯一解。如果不互素，则无解。如果f为素数，则从1到f-1的任意数都与f互素，即在1到f-1之间都恰好有一个关于模f的乘法逆元。</div>
</div>
<div class="FL">【思路】</div>
<div class="FL">

solution one :

K*M%N=1可以写成K*M-Y*N=1，这样公式就变成了扩展欧几里德求K值,因为是要求最小的，所以求出特解K以后，要变成(K%N+N)%N。

代码：
<!--more-->
<pre class="lang:c++ decode:true">#pragma comment(linker, "/STACK:102400000,102400000")
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;
#include &lt;bitset&gt;
using namespace std;

typedef long long  LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;

LL M,N,k,x,y,g;
LL gcd(LL a,LL b)
{
    return b==0?a:gcd(b,a%b);
}
void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return ;
    }
    exgcd(b,a%b,x,y);
    LL t=x;
    x=y;
    y=t-(a/b)*y;
}
int main()
{
    while(~scanf("%lld%lld",&amp;M,&amp;N))
    {
        g=gcd(M,N);
        M/=g;N/=g;
        exgcd(M,N,x,y);
        k=(x%N+N)%N;
        printf("%lld\n",k);
    }
    return 0;
}
</pre>
solution two:貌似还可以用欧拉函数求出1-n与n互质的个数，然后在一次快速幂。

&nbsp;

</div>
<div class="FL"></div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>178</wp:post_id>
		<wp:post_date><![CDATA[2015-12-07 13:49:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-07 05:49:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[51nod-1256%e4%b9%98%e6%b3%95%e9%80%86%e5%85%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e4%b9%98%e6%b3%95%e9%80%86%e5%85%83"><![CDATA[乘法逆元]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[98]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 1452 Happy 2004 （约数之和）</title>
		<link>http://acmerbar.com/179.html</link>
		<pubDate>Mon, 07 Dec 2015 06:01:33 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=179</guid>
		<description></description>
		<content:encoded><![CDATA[<div class="panel_title" align="left"><span style="color: #008000;">【链接】：<a style="color: #008000;" href="http://acm.hdu.edu.cn/showproblem.php?pid=1452" target="_blank">HDU 1452 Happy 2004</a></span></div>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">

Consider a positive integer X,and let S be the sum of all positive integer divisors of 2004^X. Your job is to determine S modulo 29 (the rest of the division of S by 29).

Take X = 1 for an example. The positive integer divisors of 2004^1 are 1, 2, 3, 4, 6, 12, 167, 334, 501, 668, 1002 and 2004. Therefore S = 4704 and S modulo 29 is equal to 6.

</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">

The input consists of several test cases. Each test case contains a line with the integer X (1 &lt;= X &lt;= 10000000).

A test case of X = 0 indicates the end of input, and should not be processed.

</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case, in a separate line, please output the result of S modulo 29.</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<div>1 10000 0</div>
</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<div>6 10</div>
</div>
<div class="panel_bottom"> 【题目大意】：求2004^x的所有约数之和对MOD取余</div>
<div class="panel_bottom">【思路】考查（1）整数唯一分解定理；</div>
<div class="panel_bottom">                        （2）约数和定理。</div>
<div class="panel_bottom">
<p data-mce-="">①整数唯一分解定理：</p>
<p data-mce-="">一个整数A一定能被分成：A=(P<sub>1</sub>^K<sub>1</sub>)*(P<sub>2</sub>^K<sub>2</sub>)*(P<sub>3</sub>^K<sub>3</sub>).....*(P<sub>n</sub>^K<sub>n</sub>)的形式。其中P<sub>n</sub>为素数。</p>
<p data-mce-="">如2004=(2<sup>2</sup>)*3*167，那么2004<sup>x</sup>=(2<sup>2x</sup>)*(3<sup>x</sup>)*(167<sup>x</sup>)。</p>
<p data-mce-="">②约数和公式</p>
<p data-mce-="">对于一个已经被分解的整数A=(P<sub>1</sub>^K<sub>1</sub>)*(P<sub>2</sub>^K<sub>2</sub>)*(P<sub>3</sub>^K<sub>3</sub>).....*(P<sub>n</sub>^K<sub>n</sub>),有约数和S=(1+P<sub>1</sub><sup>2</sup>+P<sub>1</sub><sup>3</sup>+.....P<sub>1</sub><sup>k<sub>1</sub></sup>)*.....(1+P<sub>n</sub><sup>2</sup>+P<sub>n</sub><sup>3</sup>+.....P<sub>n</sub><sup>k<sub>n</sub></sup>)，(1+P1<sup>2</sup>+P1<sup>3</sup>+.....P1<sup>k1</sup>)是一个等比数列，化简为(P1<sup>k1+1</sup> -1)/(P1-1).对于2004^X, 只要求出a=pow(2,2*x+1)-1，b=pow(3,x+1)-1，c=pow(167,x+1)-1即可，问题要计算（3-1）*（167-1）关于29的乘法逆元，转化成乘法取模。</p>
<p data-mce-="">代码：</p>

<pre class="lang:c++ decode:true">#pragma comment(linker, "/STACK:102400000,102400000")
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;
#include &lt;bitset&gt;
using namespace std;

typedef long long  LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
const int MOD = 29;
LL ret,M,N,k,x,y,g;

LL poww(LL a,LL b)
{
    LL res=a,ans=1;
    while(b)
    {
        if(b&amp;1) ans=(ans*res)%MOD;
        b&gt;&gt;=1;
        res=(res*res)%MOD;
    }
    return ans;
}

LL inv(LL x)
{
    return poww(x,MOD-2);
}

int main()
{
   // freopen("1.txt","r",stdin);
    while(~scanf("%lld",&amp;x),x)
    {
        ret=(poww(2,2*x+1)-1)%MOD*(poww(3,x+1)-1)%MOD*(poww(167,x+1)-1)%MOD;
        printf("%lld\n",ret*inv(2*166)%MOD);
    }
    return 0;
}
</pre>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>179</wp:post_id>
		<wp:post_date><![CDATA[2015-12-07 14:01:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-07 06:01:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1452-happy-2004-%ef%bc%88%e7%ba%a6%e6%95%b0%e4%b9%8b%e5%92%8c%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[快速幂]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>51NOD 1240 莫比乌斯函数</title>
		<link>http://acmerbar.com/181.html</link>
		<pubDate>Mon, 07 Dec 2015 07:47:43 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=181</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #008000;">【链接】：<a style="color: #008000;" href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1240" target="_blank">51NOD 1240</a></span>
<div class="HI">
<div class="M_20 F16E Gray30 LH_200">

莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。
<div id="fastCSharp30_bjbgbsbbbnbf"></div>
<div>具体定义如下：</div>
<div>如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。</div>
<div>如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。</div>
<div>给出一个数n, 计算miu(n)。</div>
</div>
</div>
<div class="HI">
<div class="M_20 F16E Gray30">
<div class="F18E Black MB_10">Input</div>
<pre class="F16E Gray30">输入包括一个数n，(2 &lt;= n &lt;= 10^9)</pre>
<div class="F18E Black MT_10 MB_10">Output</div>
<pre class="F16E Gray30">输出miu(n)。</pre>
<div class="F18E Black MT_10 MB_10">Input示例</div>
<pre class="PreText F12 Gray70">5</pre>
<div class="F18E Black MT_10 MB_10">Output示例</div>
<pre class="PreText F12 Gray70">-1</pre>
</div>
</div>
【思路】根据题意模拟即可

代码：
<pre class="lang:c++ decode:true  ">#pragma comment(linker, "/STACK:102400000,102400000")
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;
#include &lt;bitset&gt;
using namespace std;

typedef long long  LL;
const int maxn = 1e6+10;
const int inf =0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
const int MOD = 29;
int n;

void Mubi_fiction(int n)
{
    int Num_Squarefactor=0,Num_prime=0; ///平方因子个数，素因子个数
    bool ok=0;
    for(int i=2; i&lt;=sqrt(n); ++i)
    {
        if(n%i==0)
        {
            Num_Squarefactor=0;
            Num_prime++;
            while(n%i==0)
            {
                Num_Squarefactor++;
                n/=i;
            }
        }
        if(Num_Squarefactor&gt;1)
        {
            ok=1;
            break;
        }
    }
    if(ok)
    {
        puts("0");
    }
    else
    {
        if(n&gt;1) Num_prime++;
        if(Num_prime&amp;1) puts("-1");
        else puts("1");
    }
}
int main()
{
    while(~scanf("%d",&amp;n))
    {
        Mubi_fiction(n);
    }
    return 0;
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>181</wp:post_id>
		<wp:post_date><![CDATA[2015-12-07 15:47:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-07 07:47:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[51nod-1240-%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af%e5%87%bd%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e8%8e%ab%e6%af%94%e4%b9%8c%e6%96%af"><![CDATA[莫比乌斯]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[15]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《软件工程--面向对象开发》笔记</title>
		<link>http://acmerbar.com/184.html</link>
		<pubDate>Mon, 07 Dec 2015 13:16:03 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=184</guid>
		<description></description>
		<content:encoded><![CDATA[《软件工程-面向对象开发》笔记

【2】面向对象
<ol>
	<li>概念</li>
	<li>面向对象开发方法：</li>
</ol>
OOSE（Object-Oriented Software Engineering，面向对象软件工程）

OWT（Object Modeling Technique，对象建模技术）

OOD（Object Oriented Design，面向对象设计）

OOAD（Object-Oriented Analysis and Design，面向对象分析与设计）
<ol start="3">
	<li>建模语言：UML</li>
</ol>
4.面向对象开发模型：

5.五种静态图
<ul>
	<li><u>用例图</u>：站在外部的角度，描述外部参与者之间活动。</li>
	<li><u>类图</u>：描述实体之间的关系，类似结构化设计中的E-R图，是DB（数据库）的依据。</li>
	<li>对象图：类图的实例化，或者说某个时刻类图的镜像。</li>
	<li>构建图：描述软件实现过程中各部分组成的关系。</li>
	<li>部署图：描述软件在真实环境下的部署。</li>
</ul>
6.四种动态图
<ul>
	<li>时序图：描述多个对象按照时间的先后顺序交互的过程。</li>
	<li>协作图：描述多个对象按照空间的交互过程。</li>
	<li>状态图：单个对象在不同时间段所表示的形态以及它们之间的转化。</li>
	<li>活动图：多个角色，用例之间的交互。</li>
</ul>
7.类图的关系

7.1关联关系：单向关联，双向关联，约束关联，限制关联，多元关联，XOR关联。

7.2聚集，组合关系。

7.3依赖关系。

7.4泛化关系。

总体图示：

<a href="http://acmerbar.com/wp-content/uploads/2015/12/22222222222222221.png"><img class="aligncenter size-medium wp-image-185" src="http://acmerbar.com/wp-content/uploads/2015/12/22222222222222221-300x184.png" alt="" width="300" height="184" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>184</wp:post_id>
		<wp:post_date><![CDATA[2015-12-07 21:16:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-07 13:16:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%bc%80%e5%8f%91%e3%80%8b%e7%ac%94%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b"><![CDATA[软件工程]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>安装CentOS7.0 无法联网的解决办法</title>
		<link>http://acmerbar.com/188.html</link>
		<pubDate>Tue, 08 Dec 2015 09:39:51 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=188</guid>
		<description></description>
		<content:encoded><![CDATA[最近遇到一个技术上的问题，安装CentOS最新版（目前7.0）版本服务器，主机连不上网，经过几番折腾，总结以下几条解决办法，希望看到的朋友能从中获得一些帮助。

【问题描述】安装CentOS7.0最新版服务器连不上网络。

【原因】：默认的安装完系统不自动配置网卡以及检测网络环境，不像Ubuntu安装完，只有插上有网的网线，就可以联网，因而无论网络有没有配置（即使在安装过程中完成了网络配置），都需要手动修改一下网卡的配置，重启相关服务

【解决办法】（1）手动配置网卡，IP相关信息

打开网络配置文件

# vi /etc/sysconfig/network-script/ifcfg-eth0

(先进入该目录   /etc/sysconfig/network-script/ifcfg-eth0，查看可以用的网卡。

)

如果要动态IP，设置为自动获取ip地址

ONBOOT=yes
NM_Controlled=no
BOOTPROTO=dhcp

（或）设置为固定ip地址

ONBOOT=yes
NM_Controlled=no
BOOTPROTO=static(把dhcp改成static)
IPADDR=####（输入要访问的IP地址，例如：192.168.1.123）
BROADCAST=####（广播地址，例如：192.168.1.255）
NETMASK=####（子网掩码，例如255,255,255,0具体看IP是哪类地址）
GATEWAY=####（配置网关，例如：192.168.1.1）
DNS1=192.168.1.1(配置DNS)
DNS2=192.168.1.2

网络配置文件配置项完整说明

TYPE=Ethernet      #网卡类型
DEVICE=eth0        #网卡接口名称
ONBOOT=yes          #系统启动时是否自动加载
BOOTPROTO=static    #启用地址协议 --static:静态协议 --bootp协议 --dhcp协议
IPADDR=192.168.1.123     #网卡IP地址
NETMASK=255.255.255.0    #网卡子网掩码
GATEWAY=192.168.1.1      #网卡网关地址
DNS1=10.203.104.41      #网卡DNS地址
HWADDR=00:0C:29:13:5D:74 #网卡设备MAC地址（注意要和主机上的一致）
BROADCAST=192.168.1.255  #网卡广播地址

配置完,reboot

#  sudo service network  restart

或者 systemctl status network查看服务状态,查看日志找到解决办法。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>188</wp:post_id>
		<wp:post_date><![CDATA[2015-12-08 17:39:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-08 09:39:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%ae%89%e8%a3%85centos7-0-%e6%97%a0%e6%b3%95%e8%81%94%e7%bd%91%e7%9a%84%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cent-os-%e5%ae%89%e8%a3%85"><![CDATA[CenT OS 安装]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%ef%bc%88os%ef%bc%89"><![CDATA[操作系统（OS）]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[244]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>WordPress登陆不了后台的原因及解决方法（登陆界面死循环）</title>
		<link>http://acmerbar.com/191.html</link>
		<pubDate>Thu, 10 Dec 2015 03:09:17 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=191</guid>
		<description></description>
		<content:encoded><![CDATA[昨天发现一个问题，RT，好像是WP的一个漏洞，找到原因与解决办法

解决：

我们找到wp-includes文件夹下的pluggable.php文件,修改一些代码即可:

登入到WP后台，找到所有以下文件，
<pre class="lang:c++ decode:true ">setcookie($auth_cookie_name,$auth_cookie,$expire,ADMIN_COOKIE_PATH,COOKIE_DOMAIN,$secure,true)</pre>
把其中的ADMIN_COOKIE_PATH改成SITECOOKIEPATH,之后重新登入即可

原因：

应该是Cookie的原因。这里更改了Cookie的目录,将“/wp-admin”变成了“/”,参见pluggable.php中的函数wp_parse_auth_cookie。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>191</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 11:09:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-10 03:09:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[wordpress%e7%99%bb%e9%99%86%e4%b8%8d%e4%ba%86%e5%90%8e%e5%8f%b0%e7%9a%84%e5%8e%9f%e5%9b%a0%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95%ef%bc%88%e7%99%bb%e9%99%86%e7%95%8c%e9%9d%a2%e6%ad%bb%e5%be%aa]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="wordpress"><![CDATA[WordPress]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令--more命令</title>
		<link>http://acmerbar.com/192.html</link>
		<pubDate>Thu, 10 Dec 2015 04:25:26 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=192</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>more命令</strong>，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。

<b>1．</b><b>命令格式：</b>

more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ]

<b>2．</b><b>命令功能：</b>

more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。

<b>3．</b><b>命令参数：</b>

+n      从笫n行开始显示

-n       定义屏幕大小为n行

+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示

-c       从顶部清屏，然后显示

-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能

-l        忽略Ctrl+l（换页）字符

-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似

-s       把连续的多个空行显示为一行

-u       把文件内容中的下画线去掉

<b>4．</b><b>常用操作命令：</b>

Enter    向下n行，需要定义。默认为1行

Ctrl+F   向下滚动一屏

空格键  向下滚动一屏

Ctrl+B  返回上一屏

=       输出当前行的行号

：f     输出文件名和当前行的行号

V      调用vi编辑器

!命令   调用Shell，并执行命令

q       退出more

实例：

more +3 test.php                  // 显示文件中从第三行起的内容

more +/login test.php        //从文件中查找第一个出现"login"的字符串

more +5 test.php                 //设定每屏显示5行

ls -l | more -5                       //每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息，按b 键返回显示。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>192</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 12:25:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-10 04:25:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-more%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux一些有趣的命令</title>
		<link>http://acmerbar.com/198.html</link>
		<pubDate>Thu, 10 Dec 2015 06:09:09 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=198</guid>
		<description></description>
		<content:encoded><![CDATA[【1】sl命令，会跑出来一辆咕咚咕咚的小火车，感觉很有意思

【2】fortune命令，随机输出一句话或短语或唐诗宋词，英文的安装fortune-mod，唐诗宋词安装fortune-zh,以后想背背古诗，就输这个命令好了

【3】xeyes命令，屏幕出来一个小眼睛，linux下的应用程序

【4】linuxlogo命令：打印linux的logo

【5】再试试下面这一串命令，也挺有意思的：

aptitude moo

aptitude -v moo

aptitude -vv moo

aptitude -vvv moo

aptitude -vvvv moo

aptitude -vvvvv moo

aptitude -vvvvvv moo

aptitude -vvvvvvv moo]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>198</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 14:09:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-10 06:09:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux%e4%b8%80%e4%ba%9b%e6%9c%89%e8%b6%a3%e7%9a%84%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令--nl命令</title>
		<link>http://acmerbar.com/199.html</link>
		<pubDate>Thu, 10 Dec 2015 06:16:00 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=199</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>nl命令</strong>

nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。

1．命令格式：

nl [选项]... [文件]...

2．命令参数：

-b  ：指定行号指定的方式，主要有两种：

-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；

-b t ：如果有空行，空的那一行不要列出行号(默认值)；

-n  ：列出行号表示的方法，主要有三种：

-n ln ：行号在萤幕的最左方显示；

-n rn ：行号在自己栏位的最右方显示，且不加 0 ；

-n rz ：行号在自己栏位的最右方显示，且加 0 ；

-w  ：行号栏位的占用的位数。

-p 在逻辑定界符处不重新开始计算。

3．命令功能：

nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。

4．使用实例：

nl test.php             //用行号列出文件内容
nl -b a test.php        //空本行也加上行号
nl -b a -n rz test.php  //让行号前面自动补上0,统一输出格式
nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w a 调整为a位。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>199</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 14:16:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-10 06:16:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-nl%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux下控制（帐户&amp;&amp;密码）过期方法</title>
		<link>http://acmerbar.com/200.html</link>
		<pubDate>Thu, 10 Dec 2015 09:28:22 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=200</guid>
		<description></description>
		<content:encoded><![CDATA[chage：密码失效是通过此命令来管理的。

参数意思：
-m 密码可更改的最小天数。为零时代表任何时候都可以更改密码。
-M 密码保持有效的最大天数。
-W 用户密码到期前，提前收到警告信息的天数。
-E 帐号到期的日期。过了这天，此帐号将不可用。
-d 上一次更改的日期
-i 停滞时期。如果一个密码已过期这些天，那么此帐号将不可用。
-l 例出当前的设置。由非特权用户来确定他们的密码或帐号何时过期。

在添加用户时  ,添加新用户 tom 命令：useradd tom -e 12/28/15 表示在12/28/2015年过期

已经添加用户，要调整过期，命令：chage -E  12/28/15 tom

查看用户过期信息命令：chage -l tom

Last password change             : 12月 10, 2015
Password expires                    : never
Password inactive                    : never
Account expires                        : 12月 28, 2015
Minimum number of days between password change        : 0
Maximum number of days between password change        : 99999
Number of days of warning before password expires    : 7
root@acmol-M52L-S3 ~#

密码过期设置：

root@acmol-M52L-S3 ~# chage -M 80 tom
root@acmol-M52L-S3 ~# chage -l tom
Last password change                    : 12月 10, 2015
Password expires                            :  2月 28, 2016
Password inactive                           : never
Account expires                              : 12月 28, 2015
Minimum number of days between password change        : 0
Maximum number of days between password change        : 80
Number of days of warning before password expires    : 7
root@acmol-M52L-S3 ~#]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>200</wp:post_id>
		<wp:post_date><![CDATA[2015-12-10 17:28:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-10 09:28:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux%e4%b8%8b%e6%8e%a7%e5%88%b6%ef%bc%88%e5%b8%90%e6%88%b7%e5%af%86%e7%a0%81%ef%bc%89%e8%bf%87%e6%9c%9f%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令--ls命令</title>
		<link>http://acmerbar.com/207.html</link>
		<pubDate>Sat, 12 Dec 2015 03:58:33 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=207</guid>
		<description></description>
		<content:encoded><![CDATA[ls 命令是linux下最常用的命令。ls命令就是list的缩写,缺省下ls用来打印出当前目录的清单,如果ls指定其他目录,那么就会显示指定目录里的文 件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件,而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!
<ol>
	<li><b></b><b>命令格式：</b></li>
</ol>
ls [选项] [目录名]
<ol start="2">
	<li><b></b><b>命令功能：</b></li>
</ol>
列出目标目录中所有的子目录和文件。
<ol start="3">
	<li><b></b><b>常用参数：</b></li>
</ol>
-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件

-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。

-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序

-C 每栏由上至下列出项目

–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是'never'、'always'或'auto'其中之一

-d, –directory 将目录象文件一样显示，而不是显示其下的文件。

-D, –dired 产生适合 Emacs 的 dired 模式使用的结果

-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效

-g 类似 -l,但不列出所有者

-G, –no-group 不列出任何有关组的信息

-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)

–si 类似 -h,但文件大小取 1000 的次方而不是 1024

-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地

–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)

-i, –inode 印出每个文件的 inode 号

-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目

-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。

-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。

-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息

-m 所有项目以逗号分隔，并填满整行行宽

-o 类似 -l,显示文件的除组信息外的详细信息。

-r, –reverse 依相反次序排列

-R, –recursive 同时列出所有子目录层

-s, –size 以块大小为单位列出所有文件的大小

-S 根据文件大小排序

–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：

extension -X status -c

none -U time -t

size -S atime -u

time -t access -u

version -v use -u

-t 以文件修改时间排序

-u 配合 -lt:显示访问时间而且依访问时间排序

配合 -l:显示访问时间但根据名称排序

否则：根据访问时间排序

-U 不进行排序;依文件系统原有的次序列出项目

-v 根据版本进行排序

-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值

-x 逐行列出项目而不是逐栏列出

-X 根据扩展名排序

-1 每行只列出一个文件

–help 显示此帮助信息并离开

–version 显示版本信息并离开

<b>命令实例</b>：

【root~#】ls -l -R  /home/test   //列出/home/test文件夹下的所有文件和目录的详细资料

【root～#】ls -a                          //-all  列出目录下的所有文件，包括以 . 开头的隐含文件

【root~#】ls -l t*                      //列出当前目录中所有以“t”开头的目录的详细内容

【root~#】ls -F /home/test |grep /$          // 只列出文件下的子目录

【root~#】ls -l /home/test | grep "^d"     //列出 /home/test 文件下面的子目录详细情况

【root~#】ls -AF  //列出目前工作目录下所有档案及目录;目录于名称后加"/", 可执行档于名称后加"*"

【root~#】ls | sed "s:^:`pwd`/:"    //在ls中列出文件的绝对路径

【root～#】find $PWD | xargs ls -ld        //递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径

【root~#】 ls -tl --time-style=full-iso   //指定文件时间输出格式

<b>显示彩色目录列表</b>

打开/etc/bashrc, 加入如下一行:

alias ls="ls --color"

下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:
<ol>
	<li>蓝色--&gt;目录</li>
	<li>绿色--&gt;可执行文件</li>
	<li>红色--&gt;压缩文件</li>
	<li>浅蓝色--&gt;链接文件</li>
	<li>灰色--&gt;其他文件</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>207</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 11:58:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 03:58:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-ls%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令--cd命令</title>
		<link>http://acmerbar.com/208.html</link>
		<pubDate>Sat, 12 Dec 2015 04:41:09 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=208</guid>
		<description></description>
		<content:encoded><![CDATA[cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。

所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。
<ol>
	<li>命令格式：</li>
</ol>
cd [目录名]
<ol start="2">
	<li>命令功能：</li>
</ol>
切换当前目录至dirName
<ol start="3">
	<li>常用范例</li>
</ol>
3.1 例一：进入系统根目录

命令：

cd /

输出：

[root@localhost ~]# cd /

说明：进入系统根目录,上面命令执行完后拿ls命令看一下，当前目录已经到系统根目录了

命令：

cd .. 或者 cd .. //

<strong>命令实例：</strong>
【root@acmol-M52L-S3 ~# 】cd ../..//
【root@acmol-M52L-S3 /#】 cd /home/tom/software/
【root@acmol-M52L-S3 /h/t/software#】 pwd
/home/tom/software
【root@acmol-M52L-S3 /h/t/software#】 cd ../..//
【root@acmol-M52L-S3 /home#】 cd ../..//
【root@acmol-M52L-S3 /# 】

&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>208</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 12:41:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 04:41:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-cd%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>银河【普吕多姆诗选】</title>
		<link>http://acmerbar.com/209.html</link>
		<pubDate>Sat, 12 Dec 2015 06:33:03 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=209</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="text-align: center;">有一夜，我对星星们说：</p>
<p style="text-align: center;">“你们看起来并不幸福；</p>
<p style="text-align: center;">你们在无限黑暗中闪烁，</p>
<p style="text-align: center;">脉脉柔情里含着痛苦。</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“仰望长空，我似乎看见</p>
<p style="text-align: center;">一支白色的哀悼的队伍，</p>
<p style="text-align: center;">贞女们忧伤地络绎而行，</p>
<p style="text-align: center;">擎着千千万万支蜡烛。</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“你们莫非永远祷告不停？</p>
<p style="text-align: center;">你们莫非是受伤的星星？</p>
<p style="text-align: center;">你们洒下的不是星光呵，</p>
<p style="text-align: center;">点点滴漓，是泪水晶莹。</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“星星们，你们是人的先祖，</p>
<p style="text-align: center;">你们也是神的先祖，</p>
<p style="text-align: center;">为什么你们竟含着泪？……”</p>
<p style="text-align: center;">星星们回答道：“我们孤独……</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“每一颗星都远离姐妹们，</p>
<p style="text-align: center;">你却以为她们都是近邻。</p>
<p style="text-align: center;">星星的光多么温柔、敏感，</p>
<p style="text-align: center;">在她的国内却没有证人，</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“她的烈焰放出满腔热情，</p>
<p style="text-align: center;">默然消失在冷漠的太空。”</p>
<p style="text-align: center;">于是我说，“我懂得你们！</p>
<p style="text-align: center;">因为你们就像心灵，</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">“每颗心发光，离姐妹很远，</p>
<p style="text-align: center;">尽管看起来近在身边。</p>
<p style="text-align: center;">而她——永桓孤独的她</p>
<p style="text-align: center;">在夜的寂静中默默自燃。”</p>
<p style="text-align: center;"></p>
<p style="text-align: center;">【作者简介】普吕多姆:第一位诺贝尔文学获得者</p>
<p style="text-align: center;">飞白 译</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>209</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 14:33:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 06:33:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%93%b6%e6%b2%b3%e3%80%90%e6%99%ae%e5%90%95%e5%a4%9a%e5%a7%86%e8%af%97%e9%80%89%e3%80%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>URAL-1142 Relations【dp】</title>
		<link>http://acmerbar.com/210.html</link>
		<pubDate>Sat, 12 Dec 2015 06:38:43 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=210</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #99cc00;">题目链接：<a style="color: #99cc00;" href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1142" target="_blank">http://acm.timus.ru/problem.aspx?space=1&amp;num=1142</a></span>

题目大意：用'='和'&lt;'连接n个元素，等号之间看做一个整体，求n个元素的所有可能的方案数

【思路】dp,令dp[i][j]表示i个数划分成j个有序集合的可能的情况数

那么如果将第i个数划分进原有的集合中，方案数为dp[i-1][j]*j;

如果将第i个数新建一个集合插进某个位置，方案数为dp[i-1][j-1]*j;

最后转移方程：dp[i][j]=dp[i-1][j-1]*j+dp[i-1][j]*j

代码：
<pre class="lang:c++ decode:true">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int n;
int a[10]= {3,13,75,541,4683,47293,545835,7087261,102247563};
int dp[105][105];
int ret[105];

void solve()
{
    memset(ret,0,sizeof(ret));
    dp[1][1]=1;///dp[i][j]表示i个数划分j种情况
    for(int i=2; i&lt;=n; ++i)
    {
        for(int j=1; j&lt;=i+1; ++j)
        {
            dp[i][j]=dp[i-1][j-1]*j+dp[i-1][j]*j;
            ret[i]+=dp[i][j];
        }
    }
    printf("%d\n",ret[n]);
}

int main()
{
    while(cin&gt;&gt;n&amp;&amp;n!=-1)
    {
       solve();
    }
    return 0;
}</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>210</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 14:38:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 06:38:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ural-1142-relations%e3%80%90dp%e3%80%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Ural - 1146  Maximum Sum【二维最大子矩阵和DP】</title>
		<link>http://acmerbar.com/211.html</link>
		<pubDate>Sat, 12 Dec 2015 06:43:01 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=211</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #99cc00;">题目链接：<a style="color: #99cc00;" href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1146" target="_blank">http://acm.timus.ru/problem.aspx?space=1&amp;num=1146</a></span>

题目大意：RT

【思路】：这个就是二维的最大连续和问题。
我们可以通过转化为一维的最大连续和来求解，方法就是用一个辅助数组temp。计算前缀和，temp的作用就是将n行的矩阵压缩为一行（累加求和），这样就转化为了一维的最大连续和问题。
然后我们对从第i行开始的子矩阵进行枚举即可。复杂度为O（N*N)
代码：
<pre class="lang:c++ decode:true">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 128;
int row,col;
int mat[maxn][maxn];
int temp[maxn][maxn];

void dp()
{
    int thissum,maxsum=-999;
    for(int i=1; i&lt;=row; ++i)
    {
        for(int j=1; j&lt;=col; ++j)
        {
            temp[i][j]=temp[i-1][j]+mat[i][j];
           // cout&lt;&lt;"i= "&lt;&lt;i&lt;&lt;"j= "&lt;&lt;j&lt;&lt;" "&lt;&lt;temp[i][j]&lt;&lt;endl;
        }
    }
    for(int i=1; i&lt;=row; ++i)
    {
        for(int j=i; j&lt;=row; ++j)
        {
            thissum=0;
            for(int k=1; k&lt;=col; ++k)
            {
                if(thissum&gt;0) thissum+=temp[j][k]-temp[i-1][k];
                else thissum=temp[j][k]-temp[i-1][k];
          //      cout&lt;&lt;"thissum= "&lt;&lt;thissum&lt;&lt;endl;
                maxsum=max(maxsum,thissum);
            }
        }
    }
    printf("%d\n",maxsum);
}

int main(void)
{
    //freopen("1.txt","r",stdin);
    while(~scanf("%d",&amp;row))
    {
        col=row;
        memset(temp,0,sizeof(temp));
        for(int i=1; i&lt;=row; ++i)
        {
            for(int j=1; j&lt;=col; ++j)
            {
                scanf("%d",&amp;mat[i][j]);
            }
        }
        dp();
    }
    return 0;
}
/*4
0 -2 -7 0
9 2 -6 2
-4 1 -4 1
-1 8 0 -2

15
*/
</pre>
&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>211</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 14:43:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 06:43:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ural-1146-maximum-sum%e3%80%90%e4%ba%8c%e7%bb%b4%e6%9c%80%e5%a4%a7%e5%ad%90%e7%9f%a9%e9%98%b5%e5%92%8cdp%e3%80%91]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-pwd命令</title>
		<link>http://acmerbar.com/212.html</link>
		<pubDate>Sat, 12 Dec 2015 06:59:23 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=212</guid>
		<description></description>
		<content:encoded><![CDATA[Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。

在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。

<b>1．</b><b>命令格式：</b>

pwd [选项]

<b>2．</b><b>命令功能：</b>

查看”当前工作目录“的完整路径

<b>3．</b><b>常用参数：</b>

一般情况下不带任何参数

如果目录是链接时：

格式：pwd -P  显示出实际路径，而非使用连接（link）路径。

<strong>命令实例：</strong>

目录连接链接时，pwd -P  显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径

【root@acmol-M52L-S3 ~#】 pwd
/root
【root@acmol-M52L-S3 ~#】 cd /home/tom
【root@acmol-M52L-S3 /h/tom#】 pwd
/home/tom
【root@acmol-M52L-S3 /h/tom# 】cd /etc/init.d/
【root@acmol-M52L-S3 /e/init.d#】 pwd
/etc/init.d
【root@acmol-M52L-S3 /e/init.d# 】pwd -P
/etc/init.d
【root@acmol-M52L-S3 /e/init.d#】]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>212</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 14:59:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 06:59:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-pwd%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-mkdir命令</title>
		<link>http://acmerbar.com/213.html</link>
		<pubDate>Sat, 12 Dec 2015 07:12:27 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=213</guid>
		<description></description>
		<content:encoded><![CDATA[mkdir 命令<span style="text-decoration: underline;">用来创建指定的名称的目录</span>，<span style="text-decoration: underline;">要求创建目录的用户在当前目录中具有写权限</span>，并<span style="text-decoration: underline;">且指定的目录名不能是当前目录中已有的目录。</span>

<b>1．</b><b>命令格式：</b>

mkdir [选项] 目录...

<b>2．</b><b>命令功能：</b>

通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)<span style="text-decoration: underline;">不能与其父目录(即父文件夹)中的文件名重名</span>，即同一个目录下不能有同名的(区分大小写)。

<b>3．</b><b>命令参数：</b>

-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask

-p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;

-v, --verbose  每次创建新目录都显示信息

--help   显示此帮助信息并退出

--version  输出版本信息并退出

命令实例：

【root~#】mkdir test1         //创建一个空目录

【root~#】mkdir -p test2/test3  //递归创建多个目录

【root~#】mkdir -m 777 test3  //创建权限为 777 的目录

【root~#】mkdir -v test4        //创建新目录都显示信息

【root~#】mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}}                     //一个命令创建项目的目录结构

参考：http://www.ibm.com/developerworks/cn/aix/library/au-badunixhabits.html

【root@acmol-M52L-S3 /h/tom#】 mkdir test
【root@acmol-M52L-S3 /h/tom#】 ll
total 20K
-rw-r--r-- 1 tom  tom  8.8K 12月 10 16:48 examples.desktop
drwxr-xr-x 2 root root 4.0K 12月 10 16:57 software/
drwxr-xr-x 2 root root 4.0K 12月 12 15:04 test/
【root@acmol-M52L-S3 /h/tom#】 mkdir -p test2/test3
【root@acmol-M52L-S3 /h/tom#】 ll
total 24K
-rw-r--r-- 1 tom  tom  8.8K 12月 10 16:48 examples.desktop
drwxr-xr-x 2 root root 4.0K 12月 10 16:57 software/
drwxr-xr-x 2 root root 4.0K 12月 12 15:04 test/
drwxr-xr-x 3 root root 4.0K 12月 12 15:04 test2/
【root@acmol-M52L-S3 /h/tom#】 cd test2/
【root@acmol-M52L-S3 /h/t/test2#】 ll
total 4.0K
drwxr-xr-x 2 root root 4.0K 12月 12 15:04 test3/
【root@acmol-M52L-S3 /h/t/test2#】 rmdir  test3/
【root@acmol-M52L-S3 /h/t/test2#】 ll
total 0
【root@acmol-M52L-S3 /h/t/test2#】 mkdir -m 888 test3
mkdir: invalid mode ‘888’
【root@acmol-M52L-S3 /h/t/test2#】 mkdir -m 777 test3
【root@acmol-M52L-S3 /h/t/test2# 】ll
total 4.0K
drwxrwxrwx 2 root root 4.0K 12月 12 15:05 test3/
【root@acmol-M52L-S3 /h/t/test2#】 mkdir -v test4
mkdir: created directory ‘test4’
【root@acmol-M52L-S3 /h/t/test2#】 ../
root@acmol-M52L-S3 /h/tom# 】
mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}}
mkdir: created directory ‘scf’
mkdir: created directory ‘scf/lib/’
mkdir: created directory ‘scf/bin/’
mkdir: created directory ‘scf/doc’
mkdir: created directory ‘scf/doc/info’
mkdir: created directory ‘scf/doc/product’
mkdir: created directory ‘scf/logs’
mkdir: created directory ‘scf/logs/info’
mkdir: created directory ‘scf/logs/product’
mkdir: created directory ‘scf/service’
mkdir: created directory ‘scf/service/deploy’
mkdir: created directory ‘scf/service/deploy/info’
mkdir: created directory ‘scf/service/deploy/product’
【root@acmol-M52L-S3 /h/tom# 】tree
.
├── examples.desktop
├── scf
│   ├── bin
│   ├── doc
│   │   ├── info
│   │   └── product
│   ├── lib
│   ├── logs
│   │   ├── info
│   │   └── product
│   └── service
│       └── deploy
│           ├── info
│           └── product
├── software
│   ├── hdparm.conf
│   ├── host.conf
│   ├── hostname
│   ├── hosts
│   ├── hosts.allow
│   └── hosts.deny
├── test
└── test2
├── test3
└── test4

18 directories, 7 files
【root@acmol-M52L-S3 /h/tom# 】]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>213</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 15:12:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 07:12:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-mkdir%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-rm命令</title>
		<link>http://acmerbar.com/214.html</link>
		<pubDate>Sat, 12 Dec 2015 08:06:23 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=214</guid>
		<description></description>
		<content:encoded><![CDATA[rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。

rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。

<b>1．</b><b>命令格式：</b>

rm [选项] 文件…

<b>2．</b><b>命令功能：</b>

删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。

<b>3．</b><b>命令参数：</b>

-f, --force    忽略不存在的文件，从不给出提示。

-i, --interactive 进行交互式删除

-r, -R, --recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。

-v, --verbose    详细显示进行的步骤

--help     显示此帮助信息并退出

--version  输出版本信息并退出

<b>实例一：</b>删除文件file，系统会先询问是否删除。

<b> 命令：</b>rm 文件名

<b> 实例二：</b>强行删除file，系统不再提示。

<b> 命令：</b>rm -f 文件名

<b>实例三：</b>删除任何.log文件；删除前逐一询问确认

<b>命令：</b>rm -i *.log

<b>实例四：</b>将 test子目录及子目录中所有档案删除

<b> 命令：</b>rm -r test

<b>实例五：</b>rm -rf test命令会将 test 子目录及子目录中所有档案删除,并且不用一一确认

<b> 命令：</b>rm -rf  test

<b>实例六：</b>删除以 -gg 开头的文件

<b>命令：</b>rm -- -gg

<strong>实例七</strong>：自定义回收站功能

<strong>命令</strong>：myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv "$@" $D &amp;&amp; echo "moved to $D ok"; }

<b>说明</b>：

上面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>214</wp:post_id>
		<wp:post_date><![CDATA[2015-12-12 16:06:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-12 08:06:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-rm%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>POJ 3013 Big Christmas Tree(最短路Dijkstra+优先队列优化&#124;&#124;SPFA)</title>
		<link>http://acmerbar.com/216.html</link>
		<pubDate>Sun, 13 Dec 2015 09:04:35 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=216</guid>
		<description></description>
		<content:encoded><![CDATA[题目链接：<a href="http://poj.org/problem?id=3013" target="_blank">http://poj.org/problem?id=3013</a>

【题目大意】：给n个点从1到n标号，下面一行是每个点的权，另外给出m条边，下面是每条边的信息，两个端点+权值，边是无向边。你的任务是选出一些边，使这个图 变成一棵树。这棵树的花费是这样算的，1号固定为树根，树中每个双亲节点下面的边都有个单价（即边权），然后单价乘上这条边的下面所有的子孙后代的点权和 （看sample2，只要除掉边 1 5 9 按照这个方法就能算出1210）

【思路】：

分析：把sample2用式子列一下就能发现，每个点的权都要乘上好几条边的权，是哪几条边呢，就是这个点回到点1的路径上的那些边

所以最后的树的花费可以写成  res = sum{  (点权) * (该点回到点1的路径的边权和)  } ，这些点是2到n，1是不用算的

所以决定这条式子大小的，只有  (该点回到点1的路径的边权和)  ，  只要能让它最小即可。  令到每个点回到点1的路径边权和最小是什么？就是最短路啊！

所以从点1运行一次最短路，就可以知道1到每个点的最短路（也就是每个点到点1的最短路，因为无向图）

但是要注意一个坑，没看清楚题意，超时了很多次，就是点数可能为0（太坑了），点数为0运行不了最短路一直卡在里面，所以特判一下，输出0，如果点数1同样也是0的，因为整个树不会有边

另外注意网上的各种说法

1.有人说dij过不了，是能过的

2.有人说dij要手写heap才能过，直接用STL的优先队列也是能过的

3.spfa能过
注意：点的数量高达5w个，用矩阵存不行，只能用边存。
还有路径和结果会超int，所以要提高INF的上限，<code>(1&lt;&lt;16)*50000</code>即可。

代码：
<pre class="lang:c++ decode:true">Dijkstra
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef long long LL;
const int maxn= 5*1e4+10;
const LL inf=(LL)(1&lt;&lt;16)*maxn;
int fa[maxn];
int dp[maxn];
int w[maxn];

struct Edge
{
    int from,to,dist;
};

struct HeapNode /// 优先队列的结点
{
    int d,u;
    bool operator &lt;(const HeapNode&amp; rhs) const
    {
        return d&gt;rhs.d;
    }
};

struct Dijkstra
{
    int n,m;               /// number of nodes and edges
    vector&lt;Edge&gt;edge;      /// edges
    vector&lt;int &gt;G[maxn];   ///graph
    bool vis[maxn];        ///visited?
    LL d[maxn];            ///dis
    int p[maxn];           ///pre edge

    void init(int _n)
    {
        n=_n;
        for(int i=0; i&lt;=n; ++i)
        {
            G[i].clear();
        }
        edge.clear();
    }

    void add_edge(int from,int to, int dist)
    {
        /// if non-directed, add twice
        edge.push_back((Edge)
        {
            from, to, dist
        });
        m = edge.size();
        G[from].push_back(m - 1);
    }

    void dijkstra(int n,int s)
    {
        priority_queue&lt;HeapNode&gt; que;
        for(int i=0; i&lt;n; ++i) d[i]=inf;
        d[s]=0;
        memset(vis,false,sizeof(vis));
        que.push((HeapNode)
        {
            0,s
        });

        while(!que.empty())
        {
            HeapNode x= que.top();
            que.pop();
            int u=x.u;
            if(vis[u]) continue;
            vis[u]=true;
            /// update the u's linking nodes
            for(int i=0; i&lt;G[u].size(); ++i)
            {
                ///ref for convenient
                Edge&amp; e= edge[G[u][i]];
                if (d[e.to] &gt; d[u] + e.dist)
                {
                    d[e.to] = d[u] + e.dist;
                    p[e.to] = G[u][i];
                    que.push((HeapNode)
                    {
                        d[e.to], e.to
                    });
                }
            }
        }
    }
} dij;
int t,v,e;
int main()
{
    //freopen("1.txt","r",stdin);
    scanf("%d",&amp;t);
    while(t--)
    {
        scanf("%d%d",&amp;v,&amp;e);
        dij.init(v);
        for(int i=0; i&lt;v; ++i) scanf("%d",&amp;w[i]);
        for(int i=0; i&lt;e; ++i)
        {
            int u,v,len;
            scanf("%d%d%d",&amp;u,&amp;v,&amp;len);
            dij.add_edge(u-1,v-1,len);
            dij.add_edge(v-1,u-1,len);
        }
        dij.dijkstra(v,0);
        bool loop=false;
        LL ret=0;
        for(int i=0; i&lt;v; ++i)
        {
            if(dij.d[i]==inf)
            {
                loop=true;
                break;
            }
            ret+=w[i]*dij.d[i];
        }
        if(loop)
        {
            puts("No Answer");
        }
        else cout&lt;&lt;ret&lt;&lt;endl;
    }
    return 0;
}


//SPFA

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef long long LL;
const int maxn= 5*1e4+10;
const LL inf=(LL)1&lt;&lt;16*maxn;
int fa[maxn];
int dp[maxn];
int w[maxn];

struct Edge
{
    int from,to,dist;
};

struct SPFA
{
    int n,m;         /// number of nodes and edges
    vector&lt;Edge&gt;edge;  /// edges
    vector&lt;int &gt;G[maxn];///graph
    bool vis[maxn];     ///visited?
    LL d[maxn];      ///dis
    int p[maxn];       ///prevent edge

    void init(int _n)
    {
        n=_n;
        for(int i=0; i&lt;=n; ++i)
        {
            G[i].clear();
        }
        edge.clear();
    }

    void add_edge(int from,int to, int dist)
    {
        /// if non-directed, add twice
        edge.push_back((Edge)
        {
            from, to, dist
        });
        m = edge.size();
        G[from].push_back(m - 1);
    }

    void spfa(int n,int s)
    {
        queue&lt;int&gt; que;
        while(!que.empty()) que.pop();
        for(int i=0; i&lt;n; ++i)
        {
            d[i]=inf;
            vis[i]=false;
        }
        d[s]=0;
        vis[s]=1;
        que.push(s);

        while(!que.empty())
        {
            int u=que.front();
            que.pop();
            vis[u]=false;
            /// update the u's linking nodes
            for(int i=0; i&lt;G[u].size(); ++i)
            {
                ///ref for convenient
                Edge&amp; e= edge[G[u][i]];
                if (d[e.to] &gt; d[u] + e.dist)
                {
                    d[e.to] = d[u] + e.dist;
                    p[e.to] = G[u][i];
                    if(!vis[e.to])
                    {
                        vis[e.to]=true;
                        que.push(e.to);
                    }
                }
            }
        }
    }
} dsp;
int t,v,e;
int main()
{
    //freopen("1.txt","r",stdin);
    scanf("%d",&amp;t);
    while(t--)
    {
        scanf("%d%d",&amp;v,&amp;e);
        dsp.init(v);
        for(int i=0; i&lt;v; ++i) scanf("%d",&amp;w[i]);
        for(int i=0; i&lt;e; ++i)
        {
            int u,v,len;
            scanf("%d%d%d",&amp;u,&amp;v,&amp;len);
            dsp.add_edge(u-1,v-1,len);
            dsp.add_edge(v-1,u-1,len);
        }
        dsp.spfa(v,0);
        /// cout&lt;&lt;dsp.d[v-1]&lt;&lt;endl;
        bool loop=false;
        LL ret=0;
        for(int i=0; i&lt;v; ++i)
        {
            if(dsp.d[i]==inf)
            {
                loop=true;
                break;
            }
            ret+=w[i]*dsp.d[i];
        }
        if(loop)
        {
            puts("No Answer");
        }
        else cout&lt;&lt;ret&lt;&lt;endl;
    }
    return 0;
}

/*
3
2 1
1 1
1 2 15
5 4
1 2 3 4 5
1 2 1
2 3 2
2 4 3
2 5 4
7 7
200 10 20 30 40 50 60
1 2 1
2 3 3
2 4 2
3 5 4
3 7 2
3 6 3
1 5 9

15
52
1210
*/
</pre>
&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>216</wp:post_id>
		<wp:post_date><![CDATA[2015-12-13 17:04:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-13 09:04:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[poj-3013-big-christmas-tree%e6%9c%80%e7%9f%ad%e8%b7%afdijkstra%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e4%bc%98%e5%8c%96spfa]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[20]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>如何做好每天的计划?</title>
		<link>http://acmerbar.com/217.html</link>
		<pubDate>Sun, 13 Dec 2015 10:03:56 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=217</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="header">
<div class="header">

<strong>Target</strong>：远景、目标和理想。生活中你会看到有些人（自己也会）时常会陷入到一种碌碌无为的状态呢？不是他不努力，碌碌嘛，说明他还是很勤奋 的，但为什么会无为？我觉得主要是没有目标或者目标不对。没有目标很容易理解，目标不对就是所做非所想。这样很容易产生一种心理就是：看似自己做了很多 事，但没有产生应有的成就感和意义感。要解决这个问题，首先要解决没有目标的问题。很多人可能会说：目标，我有啊！我在***年内买房、买车等等。可是我 们突出的一个问题：没有将目标细化，以至目标在我们心中渐渐模糊乃至不见踪影。目标是这样的东西，你不去思考怎么实现，不采取行动去实现，它就永远没有可 能实现。但是思考目标是一件令人头疼的事（这个我也是深有体会，一个重要原因是大多人都觉得目标离自己很远，就把它当做空想，觉得思考它没有意义）。比如 我说我的一个目标是三年内要做一个优秀的软件架构师。如果你认真思考这个目标，就会有很多问题：首先是优秀的架构师的定义是什么？这个是以自己的标准还是 别人的标准？如果确定了这个定义，就得再思考如何做才能实现这个目标？这个需要自己思考和调查研究，再接着就是制定具体行动计划。而在工作记录上写这个第 一个作用是激励自己，不要忘记自己的目标，第二个作用是要求认真思考如何实现目标。思考Target其实就是一个将Target转化为Task的过程。

</div>
<div class="header"></div>
<div class="header">ps:这个无为该怎么来衡量？也许在别人看起来你表面上做了很多事情，也许在你自己看起来也做了不少事情，但是实际效率并不高，你真的以为自己很努力，还是<a href="http://acmerbar.com/130.html" target="_blank">你只是看起来很努力</a></div>
<div class="header"></div>
<div class="header"></div>
<div class="header"><strong>Task：</strong>当天或短期任务。这个很容易理解，就是你每天都可以采取的行动。然后工作中每完成一项就把它划掉（这个是很有成就感的）。</div>
</div>
<div class="header"></div>
<div class="header"><strong>Think：</strong>当天的思考、心得、体会。一个人工作要创新，能力要提升，修养要提高，就得时时思考（包括反思）。思考记 录下来很有用。比如公司实施创新平台计划，我看书，看到某个公司的好的做法，就记录下来，有空去翻翻，思考公司能不能这样做。很多好的idea就是这样产 生的。还有公司的周报的一栏是工作心得，但是工作心得不能靠你写周报才去思考，那样强迫思考的心得不能打动人，也不能给人以启迪和思考。这个也不需要写很 多字，就当微博去写就行。</div>
<div class="header"></div>
<div class="header"><strong>Question：</strong>当天工作和生活遇到的问题。问题需要你去解决，但现实情况是问题一多人靠脑袋就记不住了。遇到问题一时解决不了的，记下来，有空翻翻想想，就等于延长了脑袋的思考时间，一些问题就是这样解决的。另外问题也是创新的一个源头。</div>
<div class="header"><strong>Record：</strong>杂事记录。比如开会、收到包裹或者汇款记之类的杂事，就是所有你认为记录都记录下来作为备忘录。</div>
<div class="header"></div>
<div class="header">转载自强哥博客：<a href="http://blog.csdn.net/dgq8211/article/details/7649490" target="_blank">如何做好每天的计划</a></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>217</wp:post_id>
		<wp:post_date><![CDATA[2015-12-13 18:03:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-13 10:03:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a6%82%e4%bd%95%e5%81%9a%e5%a5%bd%e6%af%8f%e5%a4%a9%e7%9a%84%e8%ae%a1%e5%88%92]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Java课程设计--实现windows记事本</title>
		<link>http://acmerbar.com/219.html</link>
		<pubDate>Mon, 14 Dec 2015 08:01:58 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=219</guid>
		<description></description>
		<content:encoded><![CDATA[使用的类：

import.java.io;

import java.swt;

import javax.swing;

import javax.swing.undo.UndoManager

实现功能：

【1】文件：
新建
打开
保存
另存为
退出
【2】编辑

剪切
复制
粘贴
删除
撤销
【3】格式
自动换行
字体格式
字体颜色
查找||替换
【4】查看
关于记事本
【5】帮助
帮助选项

【6】显示当前时间
代码：
<pre class="lang:c++ decode:true  ">package qqq;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.Calendar;
import java.util.GregorianCalendar;

import javax.swing.JButton;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JColorChooser;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JToolBar;
import javax.swing.undo.UndoManager; // 对菜单活动事件撤销的实现

public class NotePad extends JFrame /// extends继承JFrame类
{

	int start = 0, end = 0;
	private UndoManager manager = new UndoManager();// 添加布局管理器
	private JTextArea text = new JTextArea();
	private JFileChooser jfc = new JFileChooser();
	private String jsb = "新建记事本";
	private File file;
	private JMenuBar menu;

	// ---------------菜单栏
	private JMenu File_bar, Edit_bar, Format_bar, View_bar, Help_bar;

	// ---------------文件菜单
	private JMenuItem File_bar_creat, File_bar_open, File_bar_save, File_bar_othersave, File_bar_exit;

	// ---------------编辑菜单
	private JMenuItem Edit_bar_Revoke, Edit_bar_shear, Edit_bar_copy, Edit_bar_paste, Edit_bar_delete;

	// ---------------格式菜单
	private JMenuItem Format_bar_hl, m30, Format_bar_ztxz, Format_bar_ztsz, View_bar_about, Help_bar_help;

	// ---------------查找替换菜单
	private JMenuItem Format_bar_find_replace;

	private JLabel statusLabel1;
	private JToolBar statusBar;

	GregorianCalendar time = new GregorianCalendar();
	int hour = time.get(Calendar.HOUR_OF_DAY);
	int min = time.get(Calendar.MINUTE);
	int second = time.get(Calendar.SECOND);

	/* 文件格式过滤器 */
	public class filter extends javax.swing.filechooser.FileFilter
	{
		public boolean accept(File file)
		{
			String name = file.getName();
			name.toString(); // 该字符串中的数字被转换为字符
			/* 文件后缀是.txt且是个目录 */
			if (name.endsWith(".txt") || file.isDirectory())
			{
				return true;
			} else
				return false;
		}

		/* 将引用具体子类的子类对象的方法,不可以省略类中的getDescription(),原因是编译器只允许调用在类中声明的方法. */
		public String getDescription()
		{
			return ".txt";
		}
	}

	/* 将菜单项 JMenu添加菜单 JMenuBar */
	public JMenu AddBar(String name, JMenuBar menu)
	{
		JMenu jmenu = new JMenu(name);
		menu.add(jmenu);
		return jmenu;
	}

	/* 将菜单项JMenuItem添加到菜单JMenu */
	public JMenuItem AddItem(String name, JMenu menu)
	{
		JMenuItem jmenu = new JMenuItem(name);
		menu.add(jmenu);
		return jmenu;
	}

	class Clock extends Thread
	{ // 模拟时钟
		public void run()
		{
			while (true)
			{
				GregorianCalendar time = new GregorianCalendar();
				int hour = time.get(Calendar.HOUR_OF_DAY);
				int min = time.get(Calendar.MINUTE);
				int second = time.get(Calendar.SECOND);
				statusLabel1.setText(" 当前时间：" + hour + ":" + min + ":" + second);
				try
				{
					Thread.sleep(950);
				} catch (InterruptedException exception)
				{
				}

			}
		}
	}

	NotePad note;

	// public void NotePad()
	{
		Container container = getContentPane();
		setTitle(jsb); // 设置窗口标题
		setBounds(250, 250, 500, 500);// 设置边界
		JMenuBar menu = new JMenuBar(); // 添加菜单 JMenuBar
		this.setJMenuBar(menu);// 调用this方法
		text.getDocument().addUndoableEditListener(manager);// 用于获得程序当前有效的文档
		/*
		 * Font是JAVA中的字体类，PLAIN是Font类中的静态常量( static final ) ,表示是:普通样式常量 BOLD
		 * :粗体样式常量 ,ITALIC: 斜体样式常量,14:磅
		 */
		text.setFont(new Font("宋体", Font.PLAIN, 14));

		/* 光标颜色 */
		text.setCaretColor(Color.gray);

		/* 选中字体颜色 */
		text.setSelectedTextColor(Color.blue);

		/* 选中背景颜色 */
		text.setSelectionColor(Color.green);

		/* 是否换行 */
		text.setLineWrap(true);

		/* 是否单词边界换行（即有空白） */
		text.setWrapStyleWord(true);

		/* 文本区与边框的间距，四个参数分别为上、左、下、右 */
		text.setMargin(new Insets(3, 5, 3, 5));

		/* 创建一个 JScrollPane，它将视图组件显示在一个视口中，视图位置可使用一对滚动条控制 */
		add(new JScrollPane(text, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
				JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED));

		File_bar = this.AddBar("文件(F)", menu);
		// File_bar.setMnemonic('F');
		Edit_bar = this.AddBar("编辑(E)", menu);
		Format_bar = this.AddBar("格式(O)", menu);
		View_bar = this.AddBar("查看(V)", menu);
		Help_bar = this.AddBar("帮助(H)", menu);

		/* 文件选项 */
		/* 新建选项 */
		File_bar_creat = this.AddItem("新建(N)   Ctrl+N", File_bar);
		File_bar_creat.addActionListener(new ActionListener()
		{
			// @Override
			public void actionPerformed(ActionEvent arg0)
			{
				// 设置新文件内容
				text.setText("");
			}
		});

		/* 打开选项 */
		File_bar_open = this.AddItem("打开(O)   Ctrl+O", File_bar);
		File_bar_open.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				try
				{
					jfc.setCurrentDirectory(new File("."));// 设置当前目录
					jfc.setFileFilter(new filter()); // 过滤文件

					/*
					 * 确定是否将AcceptAll FileFilter用作可选择过滤器列表中一个可用选项。如果为假，
					 * 则AcceptAll文件过滤器从可用的文件过滤列表中删除。
					 * 如果为true，则AcceptAll文件过滤器将成为可用的文件过滤器。
					 */
					jfc.setAcceptAllFileFilterUsed(false); // 全选文件

					jfc.showOpenDialog(null); // 弹出一个 "Open File" 文件选择器对话框。
					file = jfc.getSelectedFile(); // 获取已经选择目录
					jsb = file.getName(); // 获取目录名
					setTitle(jsb); // 显示目录名
					int length = (int) (jfc.getSelectedFile()).length();
					char[] ch = new char[length];
					FileReader fr = new FileReader(file);
					fr.read(ch);
					jsb = new String(ch);
					text.setText(jsb.trim()); // 获得对象的字段的值，然后转成string类型，并且去掉前后空白~~ToString()是转化为字符串的方法
					// Trim()是去两边空格
				} catch (Exception e)
				{
					JOptionPane.showMessageDialog(null, e);
				}
			}
		});

		/* 保存选项 = (1)如果文件为空，新建一个目录保存；(2)如果当前文件存在，直接保存 */
		File_bar_save = this.AddItem("保存(S)   Ctrl+O", File_bar);
		File_bar_save.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				if (file == null)
				{
					try
					{
						jfc = new JFileChooser();
						jfc.setCurrentDirectory(null);
						jsb = JOptionPane.showInputDialog("请输入文件名：") + ".txt";
						/*
						 * setSelectedFile返回的是对话框中选中的文件但如果对话框类型是showSaveDialog的话,
						 * 那么这里返回的值是你要保存的文件, 这个文件可能存在,可能不存在,就是你在对话框中输入的文件名了,
						 * 既然知道了文件,如果不存在,就新建一个,然后向文件写入数据,这样就可以实现保存了
						 */
						jfc.setSelectedFile(new File(jsb));
						jfc.setFileFilter(new filter());
						int temp = jfc.showSaveDialog(null); // 获取当前对象
						if (temp == jfc.APPROVE_OPTION) // 获得选中的文件对象
						{
							if (file != null)
								file.delete();
							file = new File(jfc.getCurrentDirectory(), jsb);
							file.createNewFile();
							FileWriter fw = new FileWriter(file);
							fw.write(text.getText());
							fw.close();
						}
					} catch (Exception e)
					{
						JOptionPane.showMessageDialog(null, e);
					}
				} else
				{
					try
					{
						FileWriter fw = new FileWriter(file);
						fw.write(text.getText());
						fw.close();
					} catch (Exception e)
					{
						JOptionPane.showMessageDialog(null, e);
					}
				}
			}
		});

		/* 另存为选项 */
		File_bar_othersave = this.AddItem("另存为(A)...", File_bar);
		File_bar_othersave.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				// file fw = new file();
				jfc = new JFileChooser();
				jfc.setCurrentDirectory(new File("."));
				try
				{
					if (file == null)
					{
						jsb = JOptionPane.showInputDialog("请输入文件名：") + ".txt";
					} else
						jsb = file.getName();
					jfc.setSelectedFile(new File(jsb));
					jfc.setFileFilter(new filter());
					int temp = jfc.showSaveDialog(null);
					if (temp == jfc.APPROVE_OPTION) // 获得选中的文件对象
					{
						if (file != null)
							file.delete();
						file = new File(jfc.getCurrentDirectory(), jsb);
						file.createNewFile();
						FileWriter fw = new FileWriter(file);
						fw.write(text.getText());
						fw.close();
					}
				} catch (Exception e)
				{
					JOptionPane.showMessageDialog(null, e);
				}
			}
		});

		/* 将默认大小的分隔符添加到工具栏的末尾。 */
		File_bar.addSeparator();

		/* 退出选项 + 退出提示 */
		File_bar_exit = this.AddItem("退出(X)", File_bar);
		File_bar_exit.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				int state = JOptionPane.showConfirmDialog(note, "您确定要退出？退出前请确定您的文件已保存");
				if (state == JOptionPane.OK_OPTION)
					System.exit(0);
			}
		});

		/* 编辑选项 */
		/* 撤消选项 */
		Edit_bar_Revoke = this.AddItem("撤销(U)   Ctrl+Z", Edit_bar);
		Edit_bar_Revoke.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				if (manager.canUndo())
					manager.undo();
			}
		});

		/* 剪切选项 */
		Edit_bar_shear = this.AddItem("剪切(T)   Ctrl+X", Edit_bar);
		Edit_bar_shear.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				text.cut();
			}
		});

		/* 复制选项 */
		Edit_bar_copy = this.AddItem("复制(C)   Ctrl+C", Edit_bar);
		Edit_bar_copy.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				text.copy();
			}
		});

		/* 粘贴选项 */
		Edit_bar_paste = this.AddItem("粘贴(P)   Ctrl+V", Edit_bar);
		Edit_bar_paste.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				text.paste();
			}
		});

		/* 删除选项=用空格替换从当前选取的开始到结束 */
		Edit_bar_delete = this.AddItem("删除(L)   Del", Edit_bar);
		Edit_bar_delete.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				text.replaceRange("", text.getSelectionStart(), text.getSelectionEnd());
			}
		});

		/* 自动换行选项 */
		// m26 = this.AddItem("自动换行(W)", m3);
		JCheckBoxMenuItem Format_bar_hl = new JCheckBoxMenuItem("自动换行", true);
		Format_bar.add(Format_bar_hl);
		Format_bar_hl.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				/* 根据文件名获取文件信息 */
				if (Format_bar_hl.getState())
					text.setLineWrap(true);
				else
					text.setLineWrap(false);
			}
		});

		/* 字体选项 */
		/*
		 * 字体格式设置选项 GraphicsEnvironment 类描述了 Java(tm) 应用程序在特定平台上可用
		 * 
		 * 的 GraphicsDevice 对象和 Font 对象的集合
		 */
		Format_bar_ztxz = this.AddItem("字体选择(F)", Format_bar);
		Format_bar_ztxz.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				/* 获取本地图形环境 */
				GraphicsEnvironment gr = GraphicsEnvironment.getLocalGraphicsEnvironment();
				/* 字体名称列表框 */
				JList fontnames = new JList(gr.getAvailableFontFamilyNames());
				/* JScrollPane 管理视口、可选的垂直和水平滚动条以及可选的行和列标题视口 */
				int selection = JOptionPane.showConfirmDialog(null, new JScrollPane(fontnames), "请选择字体",
						JOptionPane.OK_CANCEL_OPTION);
				Object selectedFont = fontnames.getSelectedValue();
				if (selection == JOptionPane.OK_OPTION &amp;&amp; selectedFont != null)
				{
					text.setFont(new Font(fontnames.getSelectedValue().toString(), Font.PLAIN, 20));
				}
			}
		});
		/* 字体颜色设置选项 */
		Format_bar_ztsz = this.AddItem("颜色(C)", Format_bar);
		Format_bar_ztsz.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				Color color = JColorChooser.showDialog(null, "文字颜色选择", Color.BLACK);
				text.setForeground(color);
			}
		});
		Format_bar_find_replace = this.AddItem("替换(R)||查找(F)", Format_bar);
		Format_bar_find_replace.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				JDialog search = new JDialog();
				search.setSize(300, 100);
				search.setLocation(450, 350);
				JLabel label_1 = new JLabel("查找的内容");
				JLabel label_2 = new JLabel("替换的内容");
				JTextField textField_1 = new JTextField(5);
				JTextField textField_2 = new JTextField(5);
				JButton buttonFind = new JButton("查找下一个");
				JButton buttonChange = new JButton("替换");
				JPanel panel = new JPanel(new GridLayout(2, 3));
				panel.add(label_1);
				panel.add(textField_1);
				panel.add(buttonFind);
				panel.add(label_2);
				panel.add(textField_2);
				panel.add(buttonChange);
				search.add(panel);
				search.setVisible(true);
				// 为查找下一个 按钮绑定监听事件
				buttonFind.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						String findText = textField_1.getText();// 查找的字符
						String textArea = text.getText();// 当前文本框的内容

						start = textArea.indexOf(findText, end);
						end = start + findText.length();
						if (start == -1) // 没有找到
						{
							JOptionPane.showMessageDialog(null, "没找到" + findText, "记事本", JOptionPane.WARNING_MESSAGE);
							text.select(start, end);
						} else
						{
							text.select(start, end);
						}

					}
				});
				// 为替换按钮绑定监听时间

				buttonChange.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						String changeText = textField_2.getText();// 替换的字符串
						/* 如果选定文件为真 */
						if (text.getSelectionStart() != text.getSelectionEnd())
							text.replaceRange(changeText, text.getSelectionStart(), text.getSelectionEnd());
					}
				});
			}
		});

		View_bar_about = this.AddItem("关于记事本(About)", View_bar);
		View_bar_about.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				JOptionPane.showMessageDialog(null, "记事本\n开发语言：JAVA\n开发者：【贺荣伟&amp;&amp;李苗】\n联系方式：rongweih1995@gmail.com", "关于",
						JOptionPane.PLAIN_MESSAGE);
			}
		});

		Help_bar_help = this.AddItem("帮助选项(H)", Help_bar);
		Help_bar_help.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent event)
			{
				JOptionPane.showMessageDialog(null, "详细代码请移步\n博客：www.acmerbar.com", "帮助", JOptionPane.PLAIN_MESSAGE);
			}
		});

		JPanel toolBar = new JPanel();
		toolBar.setLayout(new FlowLayout(FlowLayout.LEFT));
		// --------------------------------------向容器添加工具栏

		container.add(toolBar, BorderLayout.NORTH);
		// -----------------------------------创建和添加状态栏

		// toolBar.add(File_bar);
		// toolBar.add(Edit_bar);
		// toolBar.add(Format_bar);
		// toolBar.add(Help_bar);
		// toolBar.add(View_bar);

		statusBar = new JToolBar();
		statusBar.setLayout(new FlowLayout(FlowLayout.LEFT));
		statusLabel1 = new JLabel(" 当前时间：" + hour + ":" + min + ":" + second);
		statusBar.add(statusLabel1);
		statusBar.addSeparator();
		container.add(statusBar, BorderLayout.SOUTH);
		statusBar.setVisible(true);
		Clock clock = new Clock();
		clock.start();
		this.setResizable(true); // 窗体是否可变
		this.setVisible(true); // 窗体是否可见
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	public static void main(String args[])
	{
		NotePad example = new NotePad();

	}

	/*
	 * public class jjishiben{ public static void main(Strin args[]) { public
	 * void Run() { NotePad note = new NotePad(); note.setTitle("记事本");
	 * note.setVisible(true); note.setBounds(250, 250, 500, 500);
	 * note.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } }
	 */
}

</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>219</wp:post_id>
		<wp:post_date><![CDATA[2015-12-14 16:01:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-14 08:01:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[java%e8%af%be%e7%a8%8b%e8%ae%be%e8%ae%a1-%e5%ae%9e%e7%8e%b0windows%e8%ae%b0%e4%ba%8b%e6%9c%ac]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="java"><![CDATA[java]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="programming-language"><![CDATA[编程语言]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-rmdir命令（6）</title>
		<link>http://acmerbar.com/220.html</link>
		<pubDate>Mon, 14 Dec 2015 11:13:56 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=220</guid>
		<description></description>
		<content:encoded><![CDATA[今天学习一下linux中命令： rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。

<b>1．</b><b>命令格式：</b>

rmdir [选项]... 目录...

<b>2．</b><b>命令功能：</b>

该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。

<b>3．</b><b>命令参数：</b>

- p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。

-v, --verbose  显示指令执行过程

<b>4．</b><b>命令实例：</b>

<b>实例一：</b>rmdir 不能删除非空目录

<b>命令：</b>

rmdir doc

<b>输出：</b>

[root@localhost scf]# tree

.

|-- bin

|-- doc

|   |-- info

|   `-- product

|-- lib

|-- logs

|   |-- info

|   `-- product

`-- service

`-- deploy

|-- info

`-- product

12 directories, 0 files

[root@localhost scf]# rmdir doc

rmdir: doc: 目录非空

[root@localhost scf]# rmdir doc/info

[root@localhost scf]# rmdir doc/product

[root@localhost scf]# tree

|-- bin

|-- doc

|-- lib

|-- logs

|   |-- info

|   `-- product

`-- service

`-- deploy

|-- info

`-- product

&nbsp;

10 directories, 0 files

&nbsp;

<b>说明：</b>

rmdir 目录名 命令不能直接删除非空目录

<b>实例2：</b>rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除

<b>命令：</b>

rmdir -p logs

<b>输出：</b>

[root@localhost scf]# tree

.

|-- bin

|-- doc

|-- lib

|-- logs

|   `-- product

`-- service

`-- deploy

|-- info

`-- product

&nbsp;

10 directories, 0 files

[root@localhost scf]# rmdir -p logs

rmdir: logs: 目录非空

[root@localhost scf]# tree

.

|-- bin

|-- doc

|-- lib

|-- logs

|   `-- product

`-- service

`-- deploy

|-- info

`-- product

&nbsp;

9 directories, 0 files

[root@localhost scf]# rmdir -p logs/product

[root@localhost scf]# tree

.

|-- bin

|-- doc

|-- lib

`-- service

`-- deploy

|-- info

`-- product

&nbsp;

7 directories, 0 files

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>220</wp:post_id>
		<wp:post_date><![CDATA[2015-12-14 19:13:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-14 11:13:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-rmdir%e5%91%bd%e4%bb%a4%ef%bc%886%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-mv命令（7）</title>
		<link>http://acmerbar.com/221.html</link>
		<pubDate>Mon, 14 Dec 2015 11:59:57 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=221</guid>
		<description></description>
		<content:encoded><![CDATA[今天来学习一下mv命令，mv是move的缩写，可以用来移动文件或者将文件改名，是Linux下常用的命令，经常用来备份文件或者目录。

命令格式：

<b>1．</b><b>命令格式：</b>

mv [选项] 源文件或目录 目标文件或目录

<b>2．</b><b>命令功能：</b>

视 mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文 件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或 目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢 失。

<b>3．</b><b>命令参数：</b>

-b ：若需覆盖文件，则覆盖前先行备份。

-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；

-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！

-u ：若目标文件已经存在，且 source 比较新，才会更新(update)

-t  ： --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。

<strong>4.实例</strong>

<b>实例一：文件改名</b>

<strong>命令</strong><b>：</b>mv 1.txt 1.log  //将文件1.txt重命名为1.log
<pre class="lang:c++ decode:true ">[root@acmol-M52L-S3 ~#] vim 1.txt
[root@acmol-M52L-S3 ~#] mv 1.txt 1.log
[root@acmol-M52L-S3 ~#] ll
总用量 24K
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root   12 Dec 14 19:35 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:37 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
[root@acmol-M52L-S3 ~#]</pre>
&nbsp;

<b>实例二：移动文件</b>

<strong>命令：</strong>mv 1.txt bbb   //移动1.txt到bbb目录
<pre class="lang:c++ decode:true">root@acmol-M52L-S3 ~# ll
总用量 24K
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root   12 Dec 14 19:35 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:37 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# mv 1.log bbb
root@acmol-M52L-S3 ~# ll
总用量 20K
-rw-r--r-- 1 root root   12 Dec 14 19:35 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:50 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# cd bbb
root@acmol-M52L-S3 ~/bbb# ll
总用量 4.0K
-rw-r--r-- 1 root root 8 Dec 14 19:47 1.log
root@acmol-M52L-S3 ~/bbb# 
</pre>
<b>实例三：</b>将文件log1.txt,log2.txt,log3.txt移动到目录test3中。

<b>命令：</b>mv log1.txt log2.txt log3.txt test3

mv -t /opt/soft/test/test4/ log1.txt log2.txt  log3.txt

<b>实例四：</b><b>将文件file1改名为file2，如果file2已经存在，则询问是否覆盖</b>

命令：mv -i log1.txt log2.txt
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# vim 1.txt
root@acmol-M52L-S3 ~# mv -i 1.txt 2.txt
mv：是否覆盖"2.txt"？ y
root@acmol-M52L-S3 ~# ll
总用量 20K
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:50 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# 
</pre>
<b>实例五：</b><b>将文件file1改名为file2，即使file2存在，也是直接覆盖掉。</b>

<b>命令：</b>mv -f log3.txt log2.txt

<b>说明</b>：

log3.txt的内容直接覆盖了log2.txt内容，-f 这是个危险的选项，使用的时候一定要保持头脑清晰，一般情况下最好不用加上它。

<b>实例六：目录的移动</b>

<b>命令：</b>mv dir1 dir2

<b>实例</b><b>7：移动当前文件夹下的所有文件到上一级目录</b>

<b>命令：</b>mv * ../
<pre class="lang:c++ decode:true">root@acmol-M52L-S3 ~# cd bbb
root@acmol-M52L-S3 ~/bbb# ll
总用量 4.0K
-rw-r--r-- 1 root root 8 Dec 14 19:47 1.log
root@acmol-M52L-S3 ~/bbb# mv * ../
root@acmol-M52L-S3 ~/bbb# ll
总用量 0
root@acmol-M52L-S3 ~/bbb# cd
root@acmol-M52L-S3 ~# ll
总用量 24K
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# 
</pre>
<b>实例八：把当前目录的一个子目录里的文件移动到另一个子目录里</b>

<b>命令：</b>mv test3/*.txt test5

说明：把test3目录下后缀为".txt"的文件移动到test5

<b>实例九：文件被覆盖前做简单备份，前面加参数-b</b>

<strong>命令</strong>：mv 1.txt -b 2.txt
<pre class="lang:c++ decode:true ">[root@acmol-M52L-S3~#] ll
总用量 20K
-rw-r--r-- 1 root root   12 Dec 14 19:35 1.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:37 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
[root@acmol-M52L-S3 ~#] mv 1.txt -b 2.txt
[root@acmol-M52L-S3 ~# ]ll
总用量 20K
-rw-r--r-- 1 root root   12 Dec 14 19:35 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:37 bbb/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp</pre>
<b>说明：</b>

-b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。

--backup该选项指定如果目标文件存在时的动作，共有四种备份策略：

1.CONTROL=none或off : 不备份。

2.CONTROL=numbered或t：数字编号的备份

3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1...n：

执行mv操作前已存在以数字编号的文件log2.txt.~1~，那么再次执行将产生log2.txt~2~，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。

4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>221</wp:post_id>
		<wp:post_date><![CDATA[2015-12-14 19:59:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-14 11:59:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-mv%e5%91%bd%e4%bb%a4%ef%bc%887%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-cp命令（8）</title>
		<link>http://acmerbar.com/224.html</link>
		<pubDate>Tue, 15 Dec 2015 08:19:18 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=224</guid>
		<description></description>
		<content:encoded><![CDATA[cp 命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在， 就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的 执行方式有些不同。

<b>1．</b><b>命令格式：</b>

用法：

cp [选项]... [-T] 源 目的

或：cp [选项]... 源... 目录

或：cp [选项]... -t 目录 源...

<b>2．</b><b>命令功能：</b>

将源文件复制至目标文件，或将多个源文件复制至目标目录。

<b>3．</b><b>命令参数：</b>

-a, --archive    等于-dR --preserve=all

--backup[=CONTROL    为每个已存在的目标文件创建备份

-b                类似--backup 但不接受参数

--copy-contents        在递归处理是复制特殊文件内容

-d                等于--no-dereference --preserve=links

-f, --force        如果目标文件无法打开则将其移除并重试(当 -n 选项

存在时则不需再选此项)

-i, --interactive        覆盖前询问(使前面的 -n 选项失效)

-H                跟随源文件中的命令行符号链接

-l, --link            链接文件而不复制

-L, --dereference   总是跟随符号链接

-n, --no-clobber   不要覆盖已存在的文件(使前面的 -i 选项失效)

-P, --no-dereference   不跟随源文件中的符号链接

-p                等于--preserve=模式,所有权,时间戳

--preserve[=属性列表   保持指定的属性(默认：模式,所有权,时间戳)，如果

可能保持附加属性：环境、链接、xattr 等

-R, -r, --recursive  复制目录及目录内的所有项目

<strong>实例</strong>

<b>实例一：复制单个文件到目标目录，文件在目标文件中不存在</b>

<b>命令：</b>cp  1.log  test

说明：若目标文件存在，则询问是否覆盖

<b>实例二：复制整个目录</b>

<b>命令：cp 目录1 目录2
</b>
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# mkdir ccc
root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 14:36 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 2 root root 4.0K Dec 15 16:13 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# cp -a bbb ccc
root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 14:36 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 3 root root 4.0K Dec 15 16:13 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# cd ccc
root@acmol-M52L-S3 ~/ccc# ll
总用量 4.0K
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
root@acmol-M52L-S3 ~/ccc# cp -a bbb ddd
root@acmol-M52L-S3 ~/ccc# ll
总用量 8.0K
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 ddd/
root@acmol-M52L-S3 ~/ccc# 
</pre>
<b>实例三：复制的1.log 建立一个连结档1link.log</b>

<b>命令：</b>cp -s 1.log 1link.log
<pre class="lang:c++ decode:true "> root@acmol-M52L-S3 ~# ll
总用量 28K
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# cp -s 1.log 1link.log
root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# 
</pre>
相当于建立的是一个『快捷方式』]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>224</wp:post_id>
		<wp:post_date><![CDATA[2015-12-15 16:19:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-15 08:19:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-cp%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-touch 命令（9）</title>
		<link>http://acmerbar.com/225.html</link>
		<pubDate>Tue, 15 Dec 2015 08:45:16 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=225</guid>
		<description></description>
		<content:encoded><![CDATA[今天我们来学习一下touch命令，之前的cat命令一般是用来查看文本文件内容，<em>touch</em>可以新建一个空文件,也可以修改文件的创建时间。

<b>1．</b><b>命令格式：</b>

touch [选项]... 文件...

<b>2．</b><b>命令参数：</b>

-a   或--time=atime或--time=access或--time=use 　只更改存取时间。

-c   或--no-create 　不建立任何文档。

-d 　使用指定的日期时间，而非现在的时间。

-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。

-m   或--time=mtime或--time=modify 　只更改变动时间。

-r 　把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。

-t 　使用指定的日期时间，而非现在的时间。

<b>3．</b><b>命令功能：</b>

touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。

<b>实例一：创建不存在的文件</b>

<b>命令：</b>touch a.txt b.txt

创建两个不存在的文本文档

<b>实例二：更新文件1的时间和文件2时间戳相同</b>

<b>命令：</b>touch -r  a.cpp 1.log
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:47 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# touch -r a.cpp 1.log
root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:33 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# 
</pre>
<b>实例三：设定文件的时间戳</b>

<b>命令：</b>touch -t 201211142234.50 a.cpp
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 15  2015 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Dec 14 19:33 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# touch -t 201211142234.50 a.cpp
root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 15  2015 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Nov 14  2012 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# 
</pre>
<b>说明：</b>

-t  time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数:

[[CC]YY]MMDDhhmm[.SS]

CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch   将把年数CCYY限定在 1969--2068之内．MM为月数，DD为天将把年数CCYY限定在1969--2068之内．MM为月数，DD为天数，hh 为小时数(几 点)，mm为分钟数，SS为秒数．此处秒的设定范围是0--61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系 统的限制，早于1970年1月1日的时间是错误的。

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>225</wp:post_id>
		<wp:post_date><![CDATA[2015-12-15 16:45:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-15 08:45:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-touch-%e5%91%bd%e4%bb%a4%ef%bc%889%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令-cat 命令（10）</title>
		<link>http://acmerbar.com/226.html</link>
		<pubDate>Tue, 15 Dec 2015 09:09:13 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=226</guid>
		<description></description>
		<content:encoded><![CDATA[今天学习一下cat命令，cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。

<b>1．</b><b>命令格式：</b>

cat [选项] [文件]...

<b>2．</b><b>命令功能：</b>

<b>cat主要有三大功能：</b>

1.一次显示整个文件:cat filename

2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.

3.将几个文件合并为一个文件:cat file1 file2 &gt; file

<b>3．</b><b>命令参数：</b>

-A, --show-all           等价于 -vET

-b, --number-nonblank    对非空输出行编号

-e                       等价于 -vE

-E, --show-ends          在每行结束处显示 $

-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号

-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行

-t                       与 -vT 等价

-T, --show-tabs          将跳格字符显示为 ^I

-u                       (被忽略)

-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外

<strong>实例：</strong>

<b>实例一：把 1.txt 的文件内容加上行号后输入 2.txt 这个文件里</b>

<b>命令：</b>cat -n  1.txt 2.txt
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# ll
总用量 28K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 15  2015 1.log
-rw-r--r-- 1 root root    8 Dec 14 19:53 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Nov 14  2012 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# touch 1.txt
root@acmol-M52L-S3 ~# vim 1.txt
root@acmol-M52L-S3 ~# vim 2.txt
root@acmol-M52L-S3 ~# clear
[3;J
root@acmol-M52L-S3 ~# ll
总用量 32K
lrwxrwxrwx 1 root root    5 Dec 15 16:17 1link.log -&gt; 1.log
-rw-r--r-- 1 root root    8 Dec 15  2015 1.log
-rw-r--r-- 1 root root   17 Dec 15 16:51 1.txt
-rw-r--r-- 1 root root   18 Dec 15 16:51 2.txt
-rw-r--r-- 1 root root   15 Dec 14 19:36 2.txt~
-rw-r--r-- 1 root root   23 Nov 14  2012 a.cpp
drwxr-xr-x 2 root root 4.0K Dec 14 19:55 bbb/
drwxr-xr-x 4 root root 4.0K Dec 15 16:14 ccc/
-rw-r--r-- 1 root root   68 Dec 14 19:32 test.cpp
root@acmol-M52L-S3 ~# cat -n 1.txt 2.txt
     1	2015-13
     2	2015-14
     3	
     4	2015-15
     5	2015-16
     6	
     7	
root@acmol-M52L-S3 ~# cat 2.txt
2015-15
2015-16


root@acmol-M52L-S3 ~# 
</pre>
<b>实例二：把 文件1 和 文件2 的文件内容加上行号（空白行不加）之后将内容附加到 文件3 里。 </b>

<b>命令：</b>cat -b 1.txt 2.txt 3.txt
<pre class="lang:c++ decode:true">root@acmol-M52L-S3 ~# vim 3.txt
root@acmol-M52L-S3 ~# cat -b 1.txt 2.txt 3.txt
     1	2015-13
     2	2015-14

     3	2015-15
     4	2015-16


     5	2015 -17
     6	2015 -18

root@acmol-M52L-S3 ~# 
</pre>
<b>实例三：把文件1 的文件内容加上行号后输入 文件2这个文件里
</b>

<b>命令：cat  -n  文件1  &gt; 文件2</b>

<b>实例四：把文件1 的文件内容加上行号后重定向输入 文件2这个文件里
</b>

<b>命令：cat  -n  文件1  &gt;&gt; 文件2</b>
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# cat -n 2.txt &gt; 3.txt
root@acmol-M52L-S3 ~# cat 3.txt 
     1	2015-15
     2	2015-16
     3	
     4	
root@acmol-M52L-S3 ~# cat -n 1.txt &gt;&gt; 3.txt 
root@acmol-M52L-S3 ~# cat 3.txt 
     1	2015-15
     2	2015-16
     3	
     4	
     1	2015-13
     2	2015-14
     3	
root@acmol-M52L-S3 ~# 
</pre>
<b>实例五：反向列出
</b>

<b>命令：tac 文件
</b>
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# cat log.txt 
ewe
3434
ewr

root@acmol-M52L-S3 ~# tac log.txt 

ewr
3434
ewe
root@acmol-M52L-S3 ~# 
</pre>
<b>说明：</b>

tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>226</wp:post_id>
		<wp:post_date><![CDATA[2015-12-15 17:09:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-15 09:09:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-cat-%e5%91%bd%e4%bb%a4%ef%bc%8810%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="linux-command"><![CDATA[Linux命令学习]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 4514 湫湫系列故事——设计风景线(判环+求最长链)</title>
		<link>http://acmerbar.com/227.html</link>
		<pubDate>Tue, 15 Dec 2015 12:39:39 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=227</guid>
		<description></description>
		<content:encoded><![CDATA[【题目链接】：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4514" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4514</a>

【题目大意】：
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">　　随着杭州西湖的知名度的进一步提升，园林规划专家湫湫希望设计出一条新的经典观光线路，根据老板马小腾的指示，新的风景线最好能建成环形，如果没有条件建成环形，那就建的越长越好。
现在已经勘探确定了n个位置可以用来建设，在它们之间也勘探确定了m条可以设计的路线以及他们的长度。请问是否能够建成环形的风景线？如果不能，风景线最长能够达到多少？
其中，可以兴建的路线均是双向的，他们之间的长度均大于0。</div>
<div class="panel_bottom"></div>
Input
<div class="panel_content">　　测试数据有多组，每组测试数据的第一行有两个数字n, m，其含义参见题目描述；
接下去m行，每行3个数字u v w，分别代表这条线路的起点，终点和长度。<b>[Technical Specification]</b>
1. n&lt;=100000
2. m &lt;= 1000000
3. 1&lt;= u, v &lt;= n
4. w &lt;= 1000

</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">　　对于每组测试数据，如果能够建成环形（并不需要连接上去全部的风景点），那么输出YES，否则输出最长的长度，每组数据输出一行。</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<div>3 3</div>
<div>1 2 1</div>
<div>2 3 1</div>
<div>3 1 1</div>
</div>
<div class="panel_bottom"></div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<div>YES</div>
</div>
<div class="panel_bottom"> Source</div>
<div class="panel_content"><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2013%CC%DA%D1%B6%B1%E0%B3%CC%C2%ED%C0%AD%CB%C9%B3%F5%C8%FC%B5%DA%B6%FE%B3%A1%A3%A83%D4%C222%C8%D5%A3%A9&amp;source=1&amp;searchmode=source"> 2013腾讯编程马拉松初赛第二场（3月22日） </a></div>
<div class="panel_content"></div>
<div class="panel_content">【分析】</div>
<div class="panel_content">  判环：并查集判环，因为并查集本身就是树型结构，如果要连接的两点的祖先都相同，那么就已经有环了，</div>
<div class="panel_content">  最长链：跑一遍SPFA即可，其中可以证明的是最长链的两端必定是入度为1的</div>
<div class="panel_content">这里需要知道一个知识点：求一个连通块中的最长路径，首先，从任意从该连通块中任意一个结点出发，求最长路径，最长路径的端点是S，然后再从S出发求最长路径L，路径L就是所要求的路径</div>
<div class="panel_content">或者可以dfs一遍</div>
<div class="panel_content">相当于暴力了，800多秒，还没学会树形DP，待更新～～</div>
<div class="panel_content">代码：</div>
<div class="panel_content">
<pre class="lang:c++ decode:true ">/*
* Problem:HDU 4514
* Running time: 858MS
* Complier: G++
* Author: javaherongwei
* Create Time: 20:30 2015/12/15 星期二
*/
#pragma comment(linker,"/STACK:102400000,102400000")
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef long long LL;
const int maxn= 1e5+10;
const LL inf=(LL)0x3f3f3f3f;
int fa[maxn];
int dp[maxn];
int w[maxn];
int indeg[maxn];
int maxx;
int cnt;
int head[maxn];

int t,v,e;
bool vis[maxn];     ///visited?
LL d[maxn];      ///dis
int p[maxn];       ///prevent edge

struct Edge
{
    int from,to,dist;
}G[maxn*10*4];

void add_edge(int a,int b,int c)
{
    G[cnt].from=b;
    G[cnt].to=c;
    G[cnt].dist=head[a];
    head[a]=cnt++;
}

int spfa(int start)
{
    queue&lt;int&gt; que;
    while(!que.empty()) que.pop();
    for(int i=1; i&lt;=v; ++i)
    {
        d[i]=inf;
        vis[i]=false;
    }
    d[start]=0;
    vis[start]=1;
    que.push(start);
    while(!que.empty())
    {
        int u=que.front();
        que.pop();
        vis[u]=false;
        /// update the u's linking nodes
        for(int i=head[u]; i+1; i=G[i].dist)
        {
            int to=G[i].from;
            int w=G[i].to;
            if(d[u]+w&lt;d[to])
            {
                d[to]=d[u]+w;
                if(maxx&lt;d[to])
                maxx=d[to];
                if(vis[to])continue;
                vis[to]=1;
                que.push(to);
            }
        }
    }
}

int find(int x)
{
    if(x==fa[x]) return x;
    return fa[x]=find(fa[x]);
}

void init(int n)
{
    for(int i=1;i&lt;=n;i++)fa[i]=i;
    memset(head,-1,sizeof(head));
    memset(indeg,0,sizeof(indeg));
    cnt=0;
    maxx=-inf;
}

int main()
{
  //freopen("1.txt","r",stdin);
    while(~scanf("%d%d",&amp;v,&amp;e))
    {

        init(v);
        bool loop=false;
        int fx,fy;

        while(e--)
        {
            int u,v,len;
            scanf("%d%d%d",&amp;u,&amp;v,&amp;len);
            indeg[u]++;
            indeg[v]++;
            if(loop) continue;
            fx=find(u);
            fy=find(v);
            if(fx!=fy) fa[fy]=fx;
            else loop=true;
            add_edge(u,v,len);
            add_edge(v,u,len);
        }
        if(loop)
        {
            puts("YES");
        }
        else
        {
            for(int i=1; i&lt;=v; ++i)
            {
                if(indeg[i]==1)
                {
                    spfa(i);
                }
            }
           printf("%d\n",maxx);
        }
    }
    return 0;
}</pre>
DFS判环：
<pre class="lang:c++ decode:true ">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

typedef long long LL;
const int maxn=1e5+10;
const int inf=0x3f3f3f3f;
int head[maxn];
int cnt,n,m;
int dis[maxn];
bool vis[maxn],vis2[maxn];
int indeg[maxn];
int maxx;

struct node
{
    int from,to,next;
} edge[maxn*10*4];

void add_edge(int u,int v,int w)
{
    edge[cnt].from=v;
    edge[cnt].to=w;
    edge[cnt].next=head[u];
    head[u]=cnt++;
}

int spfa(int start)
{
    queue&lt;int&gt; que;
    while(!que.empty()) que.pop();
    for(int i=1; i&lt;=n; ++i)
    {
        dis[i]=inf;
        vis[i]=false;
    }
    dis[start]=0;
    vis[start]=1;
    que.push(start);
    while(!que.empty())
    {
        int u=que.front();
        que.pop();
        vis[u]=false;
        for(int i=head[u]; ~i; i=edge[i].next)
        {
            int to=edge[i].from;
            int w=edge[i].to;
            if(dis[u]+w&lt;dis[to])
            {
                dis[to]=dis[u]+w;
                if(maxx&lt;dis[to])
                    maxx=dis[to];
                if(vis[to])continue;
                vis[to]=1;
                que.push(to);
            }
        }
    }
}

bool dfs(int pre ,int u)///dfs判环
{
    vis2[u]=true;
    for(int i=head[u]; ~i; i=edge[i].next)
    {
        int v=edge[i].from;
        if(v==pre) continue;
        if(vis2[v]) return false;
        if(!dfs(u,v)) return false;
    }
    return true;
}

void init()
{
    memset(head,-1,sizeof(head));
    memset(vis2,false,sizeof(vis));
    memset(indeg,0,sizeof(indeg));
    maxx=-inf;
    cnt=0;
}

int main()
{
   // freopen("1.txt","r",stdin);
    while(~scanf("%d%d",&amp;n,&amp;m))
    {
        init();
        while(m--)
        {
            int u,v,w;
            scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
            indeg[u]++;
            indeg[v]++;
            add_edge(u,v,w);
            add_edge(v,u,w);
        }
        bool loop=false;
        for(int i=1; i&lt;=n; ++i)
        {
            if(vis2[i]) continue;
            if(!dfs(0,i))
            {
                loop=true;
                break;
            }
        }
        if(loop)
        {
            puts("YES");
        }
        else
        {
            for(int i=1; i&lt;=n; ++i)
            {
                if(indeg[i]==1)
                {
                    spfa(i);
                }
            }
            printf("%d\n",maxx);
        }
    }
    return 0;
}
</pre>
&nbsp;

</div>
<div class="panel_bottom"></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>227</wp:post_id>
		<wp:post_date><![CDATA[2015-12-15 20:39:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-15 12:39:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-4514-%e6%b9%ab%e6%b9%ab%e7%b3%bb%e5%88%97%e6%95%85%e4%ba%8b-%e8%ae%be%e8%ae%a1%e9%a3%8e%e6%99%af%e7%ba%bf%e5%88%a4%e7%8e%af%e6%b1%82%e6%9c%80%e9%95%bf%e9%93%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="spfa"><![CDATA[SPFA]]></category>
		<category domain="category" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[54]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>冯立：1769本书的“读立时代”</title>
		<link>http://acmerbar.com/229.html</link>
		<pubDate>Wed, 16 Dec 2015 11:01:27 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=229</guid>
		<description></description>
		<content:encoded><![CDATA[<section class="article">自本科以来，八年间他读完了超过1700本书，其中2014年达到峰值，这一年就读了510本书。在这8年中，他还考察与游历了12个国家以及国内120个县市，听了超过3000张音乐专辑、看了1000部电影，本硕博的学业也没有耽误。

他就是清华历史系博士生冯立。在豆瓣上，他有一个更为人所熟知的名字，《海淀知名书店指南》的作者“王韧勉”。截至2015年11月19日，他已经在8年间读过了1769本书，而在一个月之前，这个数字还是1731。

如果翻看冯立读过的书目，会发现他的涉猎极为广泛，里面有各个方面、五花八门的书：推理、科幻、动漫、评论、杂志、畅销书、英语、经典文学、纯学术……

每 天早上8点起床、晚上12点睡觉，生活作息十分规律的冯立随时随地都可以读书。在图书馆看纸质版、大部头，出门坐地铁可以读电子版、轻松些的书，临睡前还 可以听有声书。在注意力碎片化的时代，冯立觉得学习者也要迅速调整和适应，依据不同的阅读环境，用碎片化的时间和方式去阅读。就是这样，冯立把读书变成一 件像呼吸一样自然地融入日常生活的事。

当 然，能在网上被很多书友奉为“书神”，绝不仅仅是数量的累积和形式上的“阅读”，多年坚持下来的冯立更在意的是书籍的内容和深入的思考，也摸索出一套适合 自己的阅读之道。在他看来，重要的是找到“自己看书的体系，找到搜罗好书的方式”。例如，冯立发现学术类书籍往往有固定的写作套路，因此读起来按照这个作 者的思路推进很容易能抓住重点。

冯立给自 己设置了一个任务，每读完100本书，就要写一篇总结性的文章，为这100本书评选出一个前十名榜单，并和网友分享读书笔记和阅读心得。他曾写道：“读书 要读出不同的维度，而不仅仅是停留在阅读的表层，简单阅读就去表扬抑或批驳某本书的优劣”。2015年10月2日，冯立在豆瓣上发布日记《如何让你的阅读 更高效？——1700本书阅读总结》。他总结道：“必读书目的存在性在于精华而不在多，书单的存在亦在其参考作用，而非全盘接受，阅读本身就是很私人化的 事务，以主题阅读为基础，以读书笔记为拓展，创制符合自己需求的书单，才能让自己的阅读更成体系，更有条理。”

与 其坐而论道，不如起而行之。从大一制订读书计划开始，冯立并非“三分钟热度”，而是坚持着阅读的习惯,保持对行走的热爱，而且打游戏、谈恋爱、社会实践、 旅行……他把丰富的生活体验和阅读结合起来，他觉得这样才能更加真切深度的感受世界，让阅读体会更加丰厚。正如冯立所说，阅读不是简简单单从头翻到最后一 页的简单过程，其中凝结着生命中相遇的点点滴滴，阅读是全身心释放的过程。

From: <a href="http://www.tsinghua.edu.cn/publish/newthu/8912/2015/20151208082942301945637/20151208082942301945637_.html" target="_blank">http://www.tsinghua.edu.cn/publish/newthu/8912/2015/20151208082942301945637/20151208082942301945637_.html</a>

</section>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>229</wp:post_id>
		<wp:post_date><![CDATA[2015-12-16 19:01:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-16 11:01:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%86%af%e7%ab%8b%ef%bc%9a1769%e6%9c%ac%e4%b9%a6%e7%9a%84%e8%af%bb%e7%ab%8b%e6%97%b6%e4%bb%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[26]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 5100 Chessboard &amp;&amp; Ural 1255 Graveyard of the Cosa Nostra(棋盘覆盖)</title>
		<link>http://acmerbar.com/231.html</link>
		<pubDate>Thu, 17 Dec 2015 06:03:57 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=231</guid>
		<description></description>
		<content:encoded><![CDATA[两道题是一样 的

【题意】<strong>用 k × 1 的小矩形覆盖一个 n × n 的正方形棋盘，问正方形棋盘最多能被覆盖多少。
</strong>

【思路】<strong>规律就是：如果n&lt;k，肯定不行。</strong><strong>定义t=n%k;也就是水平放满小矩形后余下的地方，然后我们要考虑可以将小矩形竖着放，紧接着，有一个规律：</strong>

<strong>如果(t&lt;=k/2),结果为：n*n-t*t；</strong><strong>否则结果为：n*n-(k-t)*(k-t)；</strong>

证明看Matrix67这里:<a href="http://www.matrix67.com/blog/archives/5900" target="_blank"> 趣题：用 k × 1 的矩形覆盖 n × n 的正方形棋盘</a>

HDU 5100 求面积代码：
<pre class="lang:c++ decode:true ">/*
Problem :HDU 5100 - Chessboard
Author: javaherongwei
Time: 2015/12/13
Runtime:15ms
*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
using namespace std;
const int maxn=3005;
typedef long long LL;

int main()
{
    // freopen("1.txt","r",stdin);
    int n,k;
    int t;scanf("%d",&amp;t);
    while(t--)
    {
        scanf("%d%d",&amp;n,&amp;k);
        if(n&lt;k)
        {
            puts("0");
            continue;
        }
        int t=n%k;
        if(t&lt;=k/2) printf("%d\n",(n*n-t*t));
        else printf("%d\n",(n*n-(k-t)*(k-t)));
    }
    return 0;
}
/*
2
6 3
5 3

36
24
*/
</pre>
URAl  1255 求个数，除以k就行了

代码：
<pre class="lang:c++ decode:true ">/*
Problem :URAL 1255 - Graveyard of the Cosa Nostra
Author: javaherongwei
Time: 2015/12/13
Runtime:0ms
*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
using namespace std;
const int maxn=3005;
typedef long long LL;

int main()
{
    // freopen("1.txt","r",stdin);
    int n,k;
    while(~scanf("%d%d",&amp;n,&amp;k))
    {
        if(n&lt;k){
            puts("0");
            continue;
        }
        int t=n%k;
        if(t&lt;=k/2) printf("%d\n",(n*n-t*t)/k);
        else printf("%d\n",(n*n-(k-t)*(k-t))/k);
    }
    return 0;
}
/*
5 3

6
*/
</pre>
&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>231</wp:post_id>
		<wp:post_date><![CDATA[2015-12-17 14:03:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-17 06:03:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-5100-chessboard-ural-1255-graveyard-of-the-cosa-nostra%e6%a3%8b%e7%9b%98%e8%a6%86%e7%9b%96]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%80%9d%e7%bb%b4%e9%a2%98"><![CDATA[思维题]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[14]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[22]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Ural 1249  Ancient Necropolis(模拟矩阵压缩)(有问题待补～～)</title>
		<link>http://acmerbar.com/234.html</link>
		<pubDate>Thu, 17 Dec 2015 07:19:24 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=234</guid>
		<description></description>
		<content:encoded><![CDATA[【题目链接】：<a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1249" target="_blank">http://acm.timus.ru/problem.aspx?space=1&amp;num=1249</a>

【题意】：给你一个01矩阵，只要满足最少有相邻的4个1形成一个矩形视为一个古墓，判断给的的图是否有古墓

【思路】：将输入矩阵压缩成两行，然后判断每四个矩形之和

<del>貌似错误的代码：被自己出的一组数据卡掉，但是之前是已经AC的</del>
<pre class="lang:c++ decode:true ">/*
Problem: Ural 1249  Ancient Necropolis
Author: herongwei
Runtime:0ms
Creat time:2015/12/13
*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 3005;
int get(int a,int b,int c,int d)
{
    if(a+b+c+d==3) return 1;
    return 0;
}
int mat[2][maxn];
int main()
{
   // freopen("1.txt","r",stdin);
    int n,m;
    while(~scanf("%d%d",&amp;n,&amp;m))
    {
        bool yes=false;
        memset(mat,0,sizeof(mat));
        for(int i=1; i&lt;=n; ++i)
        {
            for(int j=1; j&lt;=m; ++j)
            {
                scanf("%d",&amp;mat[i%2][j]);
                //   cout&lt;&lt;"i= "&lt;&lt;i&lt;&lt;"j= "&lt;&lt;j&lt;&lt;"mat[i%2][j]= "&lt;&lt;mat[i%2][j]&lt;&lt;endl;
            }
        }
        for(int j=2; j&lt;=m; ++j)
        {
            if(get(mat[0][j-1],mat[0][j],mat[1][j-1],mat[1][j]))
            {
                yes=true;
                break;
            }
        }
        if(yes) puts("No");
        else puts("Yes");
    }
    return 0;
}
/*
2 2
0 1
1 1
NO
3 3
0 0 1
1 1 0
1 1 0
Yes
4 4
1 1 1 1
1 1 0 1
0 0 1 0
1 1 1 0
No
*/
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>234</wp:post_id>
		<wp:post_date><![CDATA[2015-12-17 15:19:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-17 07:19:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ural-1249-ancient-necropolis%e6%a8%a1%e6%8b%9f%e7%9f%a9%e9%98%b5%e5%8e%8b%e7%bc%a9%e6%9c%89%e9%97%ae%e9%a2%98%e5%be%85%e8%a1%a5%ef%bd%9e%ef%bd%9e]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%9a%b4%e5%8a%9b"><![CDATA[暴力]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[14]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 5547 Sudoku  ( 搜索+The 2015 China Collegiate Programming Contest H题)</title>
		<link>http://acmerbar.com/236.html</link>
		<pubDate>Sat, 19 Dec 2015 12:31:26 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=236</guid>
		<description></description>
		<content:encoded><![CDATA[【题目链接】：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5547" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=5547</a>

【题意】简单数独，给你一个4*4的棋盘，划分成为4个2*2的小棋盘，求合法以及唯一解

【思路】数据小，爆搜即可

ps：跟常规的数独不一样，斜对角线可以数字重复，so对每个2*2的小矩形判断即可

弱渣的代码：
<pre class="lang:c++ decode:true ">/*
Problem : HDU 5547 Sudoku
Author  : javaherongwei
Language : G++
CreateTime: 2015/12/19
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 5;
char map[maxn][maxn];

void print()                        /*输出答案*/
{
    for(int i=0; i&lt;4; ++i)
    {
        for(int j=0; j&lt;4; ++j)
        {
            printf("%c",map[i][j]);
        }
        puts("");
    }
}

bool check(int row,int col,int val)  /*判断4个2*2的方格的可能性*/
{
    for(int i=0; i&lt;4; i++)
    {
        if(map[row][i]==val||map[i][col]==val) return true;
    }
    if(row/2==0&amp;&amp;col/2==0) ///左上角
    {
        if(map[0][0]==val||map[0][1]==val||map[1][0]==val||map[1][1]==val) return true;
    }
    else if(row/2==0&amp;&amp;col/2) ///右上角
    {
        if(map[0][2]==val||map[0][3]==val||map[1][2]==val||map[1][3]==val) return true;
    }
    else if(row/2&amp;&amp;col/2==0) ///左下角
    {
        if(map[2][0]==val||map[2][1]==val||map[3][0]==val||map[3][1]==val) return true;
    }
    else if(row/2&amp;&amp;col/2) ///右下角
    {
        if(map[2][2]==val||map[2][3]==val||map[3][2]==val||map[3][3]==val) return true;
    }
    return false;
}

void dfs(int row,int col)
{
    if(row==4)              /*因为每一步都进行了判断，所以搜索到底的时候输出答案*/
    {
        print();
        return ;
    }
    if(map[row][col]!='*')  /* 控制搜索的方向即从数字开始搜，当列为3从下一行开始搜索*/
    {
        if(col==3) dfs(row+1,0);
        else dfs(row,col+1);
    }
    else
    {
        for(int k=1; k&lt;=4; ++k)
        {
            if(!check(row,col,k+'0')) /*判断当前空白可以填数*/
            {
                map[row][col]=k+'0';  /*填数字*/
                if(col==3) dfs(row+1,0);  /* 从数字开始搜，当列为3从下一行开始搜索*/
                else dfs(row,col+1);
                map[row][col]='*';   /*注意回溯！*/
            }
        }
    }
}
int main()
{
   // freopen("1.txt","r",stdin);
    int n,tot=1;
    scanf("%d",&amp;n);
    while(n--)
    {
        for(int i=0; i&lt;4; ++i)
        {
            scanf("%s",map[i]);
        }
        printf("Case #%d:\n",tot++);
        dfs(0,0);  /*从(0,0)开始搜索*/
    }
    return 0;
}
/*
Sample Input

3
****
2341
4123
3214
*243
*312
*421
*134
*41*
**3*
2*41
4*2*



Sample Output

Case #1:
1432
2341
4123
3214
Case #2:
1243
4312
3421
2134
Case #3:
3412
1234
2341
4123

*/
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>236</wp:post_id>
		<wp:post_date><![CDATA[2015-12-19 20:31:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-19 12:31:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-5547-sudoku-%e6%90%9c%e7%b4%a2the-2015-china-collegiate-programming-contest-h%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="category" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个Linux命令－which命令(11)</title>
		<link>http://acmerbar.com/237.html</link>
		<pubDate>Wed, 23 Dec 2015 12:13:48 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=237</guid>
		<description></description>
		<content:encoded><![CDATA[今天来学习一下which 命令，

常见查找命令，在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：
which  查看可执行文件的位置。
whereis 查看文件的位置。
locate   配合数据库查看文件位置。
find   实际搜寻硬盘查询文件名称。

which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

<b>1．</b><b>命令格式：</b>

which 可执行文件名称

<b>2．</b><b>命令功能：</b>

which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。

<b>3．</b><b>命令参数：</b>

-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。

-p 　与-n参数相同，但此处的包括了文件的路径。

-w 　指定输出时栏位的宽度。

-V 　显示版本信息

<strong>４．命令实例</strong>

查找which,pwd,lsmod,cd命令

<strong>注意</strong>

【１】查找cd命令会查不到，这是因为cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以查不到。

【２】

which 在PATH变量指定的路径中搜索某个系统命令的位置并且返回第一个搜索结果。也就是说使用which命令就可以看到某个系统命令是否存在以及执行的到底是哪一个位置的命令。
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# which
root@acmol-M52L-S3 ~# which which
/usr/bin/which
root@acmol-M52L-S3 ~# which pwd
/bin/pwd
root@acmol-M52L-S3 ~# which lsmod
/sbin/lsmod
root@acmol-M52L-S3 ~# which cd
root@acmol-M52L-S3 ~#</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>237</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 20:13:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 12:13:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4%ef%bc%8dwhich%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>每天一个linux命令-whereis 命令(12)</title>
		<link>http://acmerbar.com/239.html</link>
		<pubDate>Wed, 23 Dec 2015 13:29:39 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=239</guid>
		<description></description>
		<content:encoded><![CDATA[whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。

和 find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即 将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。

但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。

<b>1．</b><b>命令格式：</b>

whereis [-bmsu] [BMS 目录名 -f ] 文件名

<b>2．</b><b>命令功能：</b>

whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。

<b>3．</b><b>命令参数：</b>

-b   定位可执行文件。

-m   定位帮助文件。

-s   定位源代码文件。

-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。

-B   指定搜索可执行文件的路径。

-M   指定搜索帮助文件的路径。

-S   指定搜索源代码文件的路径。

<strong>４．命令实例</strong>

只将二进制文件 查找出来
<pre class="lang:c++ decode:true ">root@acmol-M52L-S3 ~# whereis tomcat
tomcat:
root@acmol-M52L-S3 ~# whereis find
find: /usr/bin/find /usr/share/man/man1/find.1.gz
root@acmol-M52L-S3 ~# whereis -b svn
svn:
root@acmol-M52L-S3 ~# apt-get install svn
正在读取软件包列表... 完成
正在分析软件包的依赖关系树       
正在读取状态信息... 完成       
E: 未发现软件包 svn
root@acmol-M52L-S3 ~# whereis -m find
find: /usr/share/man/man1/find.1.gz
root@acmol-M52L-S3 ~# whereis -s find
find:
root@acmol-M52L-S3 ~# 

</pre>
&nbsp;

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>239</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 21:29:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 13:29:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%af%8f%e5%a4%a9%e4%b8%80%e4%b8%aalinux%e5%91%bd%e4%bb%a4-whereis-%e5%91%bd%e4%bb%a412]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础(1) --Swap &amp; Bubble-Sort &amp; Select-Sort</title>
		<link>http://acmerbar.com/247.html</link>
		<pubDate>Thu, 31 Dec 2015 13:25:40 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=247</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

代码：
<pre class="lang:c++ decode:true">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;

/*Swap的简单实现*/
///C语言方式(by-pointer):
template &lt;typename Type&gt;
bool swapByPointer(Type *p1,Type *p2)
{
    ///确保两个指针不会指向同一个对象
    if(p1 == NULL || p2 == NULL)
    {
        return false;
    }
    if(p1!=p2)
    {
        Type temp= *p1;
        *p1=*p2;
        *p2=temp;
    }
    return true;
}
///C++特有方式(by-reference:引用):
template &lt;typename Type&gt;
void swapByReference(Type &amp;k1,Type &amp;k2)
{
    if(k1!=k2)
    {
        Type temp=k1;
        k1=k2;
        k2=temp;
    }
}

/*  冒泡排序(Bubble-Sort) */
/*
算法思想:
	从左到右扫描数据,找出最大的元素,将其放到数组右边;
过程:
	循环比较相邻的两个数,如果左边的数比右边的大,则交换两个数;
*/
template &lt;typename Type&gt;
void bubbleSort(Type *begin,Type *end)
{
    if((begin == end ) || (begin == NULL ) || (end == NULL)) return ;
    int length = end-begin;

    ///注意点(1):保证一旦数组有序, 则会直接停止排序, 不会在继续进行无用的循环
    bool isOrder = false;

    ///外层循环控制扫描次数(length-1)
    ///注意点(2):N个元素其实只需N-1次扫描

    for(int i=0; !isOrder&amp;&amp;i&lt;length-1; ++i)
    {
        ///首先假定这次数组已经有序
        isOrder =true;
        ///注意点(3):确保能够从0扫描到最后一个未排序的元素
        for(Type *iter = begin ; iter&lt;end-i-1; ++iter)
        {
            ///如果前面的左边的元素&gt;右边的元素
            if(*iter&gt;*(iter+1))
            {
                swapByReference(*iter,*(iter+1));
                isOrder= false;
            }
        }
    }
}
template &lt;typename Type&gt;
void bubbleSort(Type *array, int length)
{
    return bubbleSort(array, array+length);
}

/*选择排序(Select-Sort)*/
/*
思想:
	从当前尚未排序的序列中选择一个最小的元素, 将之放到已排序的序列的队列的末尾;
要点:
	1.注意三个指针(inner, outer, miner)所代表的含义;
	2.同时注意是从未排序的序列中进行查找最小元素!
*/
template &lt;typename Type&gt;
void selectSort(Type *begin, Type *end)
{
    if((begin == end)|| (begin == NULL) || (end == NULL)) return ;
    ///只要循环到最后一个元素的前一个就行了,因为剩下的那个肯定是最大的
    for(Type *outer= begin ; outer&lt;end-1; ++outer)
    {
        ///注意:是从尚未排序的序列中查找(miner = outer, inner = outer+1)
        Type *miner = outer;
        ///从miner+1开始遍历数组, 寻找一个元素值小于*miner的
        for(Type *inner = outer+1; inner &lt;end; ++inner)
        {
            if(*inner &lt;*miner)
                miner= inner;
        }
        if(miner !=outer) std::swap(*miner,*outer);
    }
}
///为了能够让STL的标准容器如vector使用
template &lt;typename Iterator&gt;
void selectSort(Iterator iter1, Iterator iter2)
{
    return selectSort(&amp;(*iter1), &amp;(*iter2));
}

template &lt;typename Type&gt;
void selectSort(Type *array, int length)
{
    return selectSort(array, array+length);
}

int main()
{
}
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>247</wp:post_id>
		<wp:post_date><![CDATA[2015-12-31 21:25:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-31 13:25:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%801-swap-bubble-sort-select-sort]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU计算机学院大学生程序设计竞赛（2015’12）</title>
		<link>http://acmerbar.com/248.html</link>
		<pubDate>Sat, 02 Jan 2016 15:33:09 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=248</guid>
		<description></description>
		<content:encoded><![CDATA[Problem 1001 <a href="http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&amp;cid=657">The Country List</a>

【题意】：给你许多（0 &lt; n &lt; 100）字符串，统计len一样且出现连续小写字母相同的至少两次的字符串有多少组，大写要视为小写统一处理

【思路】：直接模拟即可

代码：
<pre class="lang:c++ decode:true">/*
Problem 1001 :The Country List
Author: herongwei
Result: Accepted
Time  : 2015/12/26
*/
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int maxn = 105;
char st[maxn][26];
int main()
{
   // freopen("1.txt","r",stdin);
    int t;
    while(~scanf("%d",&amp;t))
    {
        for(int i=0; i&lt;t; ++i)
        {
            scanf("%s",&amp;st[i]);
        }
        for(int i=0; i&lt;t; ++i)
        {
            int len=strlen(st[i]);
            for(int j=0; j&lt;len; ++j)
            {
                if(st[i][j]&gt;='A'&amp;&amp;st[i][j]&lt;='Z')
                    st[i][j]=st[i][j]-'A'+'a';
            }
        }
        int s,ret=0;
        for(int i=0; i&lt;t; ++i)
        {
            for(int j=0; j&lt;t; ++j)
            {
                if(i!=j)
                {
                    if(strlen(st[i])==strlen(st[j]))
                    {
                        int len=strlen(st[i]);
                        s=0;
                        for(int z=0; z&lt;len; ++z)
                        {
                            if(st[i][z]==st[j][z])
                                s++;
                        }if(s&gt;2) { ret++; break;}
                    }
                }
            }
        }
        printf("%d\n",ret);
    }
    return 0;
}
/*
3
Denmark
GERMANY
China
4
Aaaa
aBaa
cBaa
cBad

2
4
*/</pre>
Problem :1002  <a href="http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1002&amp;cid=657">Polygon</a>

【题意】Give you a simple polygon and a line, and your task is to calculate the length of the line which is covered by the polygon.

求多边形和线段交

【思路】：算法：
求出直线与多边形的所有交点，
排序后，判断每一段线段是否在多边形内（判断中点是否在多边形内），求和。

代码：
<pre class="lang:c++ decode:true ">/*
Problem 1002 :Polygon
Author  : herongwei
Language : G++
Result: Accepted
CreateTime: 2015/12/27
*/
/******************************************************************
题意：
多边形有n个顶点，输入m条直线，分别输出它们在多边形内的长度，边界也算
算法：
求出直线与多边形的所有交点，
排序后，判断每一段线段是否在多边形内（判断中点是否在多边形内），求和。
*******************************************************************/
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long LL;

const int maxn = 1e4+10;
const double eps = 1e-8;
const double pi = acos(-1.0);
const int inf = 0x3f3f3f3f;
int n;
struct Point
{
    double x,y;
} p1[maxn],p2[maxn];

int cmp(Point a,Point b)
{
    if(fabs(a.x-b.x)&lt;eps) return a.y&lt;b.y;
    return a.x&lt;b.x;
}

double mutipy(double a,double b)
{
    return (a-b)*(a-b);
}
double dist(Point a,Point b)
{
    return sqrt(mutipy(a.x,b.x)+mutipy(a.y,b.y));
}
double cross(Point A,Point B,Point C)///求两个向量叉乘：AB * AC
{
    return (C.x-A.x)*(B.y-A.y)-(B.x-A.x)*(C.y-A.y);
}
bool on_Seg(Point A,Point B,Point C)///判断点C时候在线段A, B上
{
    if(cross(A, B, C)==0) ///叉乘为0，则向量平行
    {
        if(C.x&gt;=min(A.x,B.x)&amp;&amp;C.x&lt;=max(A.x,B.x)&amp;&amp;C.y&gt;=min(A.y,B.y)&amp;&amp;C.y&lt;=max(A.y,B.y))
            return true;
    }
    return false;
}
bool Is_Seg_intersect(Point p1,Point p2,Point p3,Point p4)///判断线段是否相交
{
    double d1=cross(p3,p4,p1);  ///叉乘为0，则向量平行
    double d2=cross(p3,p4,p2);
    double d3=cross(p1,p2,p3);
    double d4=cross(p1,p2,p4);
    if(d1*d2&lt;0&amp;&amp;d3*d4&lt;0)   return true;
    else if(d1==0&amp;&amp;on_Seg(p3,p4,p1))   return true;
    else if(d2==0&amp;&amp;on_Seg(p3,p4,p2))   return true;
    else if(d3==0&amp;&amp;on_Seg(p1,p2,p3))   return true;
    else if(d4==0&amp;&amp;on_Seg(p1,p2,p4))   return true;
    return false;
}
Point Seg_intersection(Point a1, Point a2, Point b1, Point b2)///计算线段交点
{
    Point ret = a1;
    double t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x))
               / ((a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x));
    ret.x += (a2.x - a1.x) * t;
    ret.y += (a2.y - a1.y) * t;
    return ret;
}
int InPolygon(Point a)///判断点是否在多边形的内部
{
    int i;
    Point b,c,d;
    b.y=a.y;
    b.x=1e15;///定义射线
    int flag=0;
    int count=0;
    for(i=0; i&lt;n; i++)
    {
        c = p1[i];
        d = p1[i + 1];
        if(on_Seg(c,d,a))///该点在多边形的一条边上
            return 1;
        if(fabs(c.y-d.y)&lt;eps)
            continue;
        if(on_Seg(a,b,c))///和顶点相交的情况，如果y值较大则取
        {
            if(c.y&gt;d.y)
                count++;
        }
        else if(on_Seg(a,b,d))///和顶点相交的情况，如果y值较大则取
        {
            if(d.y&gt;c.y)
                count++;
        }
        else if(Is_Seg_intersect(a,b,c,d))///和边相交
            count++;
    }
    return count%2;///当L和多边形的交点数目C是奇数的时候，P在多边形内，是偶数的话P在多边形外。
}
bool Intersect(Point s,Point e,Point a,Point b)
{
    return cross(e,a,s)*cross(e,b,s)&lt;=0;
}///所在直线相交

double solve(Point s,Point e)
{
    int i,j,k=0;
    double sum=0;
    Point a,b,temp;
    for(i=0; i&lt;n; i++) ///遍历所有点计算交点
    {
        a=p1[i];
        b=p1[i+1];
        if(fabs(cross(e,a,s))&lt;eps&amp;&amp;fabs(cross(e,b,s))&lt;eps)
        {
            p2[k++]=a;
            p2[k++]=b;
        }
        else if(Intersect(s,e,a,b))///两直线相交
        {
            p2[k++]=Seg_intersection(s,e,a,b);///两直线交点
        }
    }
    if(k==0) return 0.0;
    sort(p2,p2+k,cmp); /// 排序，由于割线是直线，所以交点必定线性分布
    p2[k]=p2[0];
    for(i=0; i&lt;k-1; i++)
    {
        a=p2[i];
        b=p2[i+1];
        temp.x=(a.x+b.x)/2.0;
        temp.y=(a.y+b.y)/2.0;
        if(InPolygon(temp))///如果两点的中点在多边形外部，说明直线在外部
            sum+=dist(a,b);
    }
    return sum;
}
int main()
{
   // freopen("1.txt","r",stdin);
    double sum;
    Point s,e;
    while(~scanf("%d",&amp;n))
    {
        for(int i=0; i&lt;n; ++i)
            scanf("%lf%lf",&amp;p1[i].x,&amp;p1[i].y);
        p1[n]=p1[0];
        for(int j=0; j&lt;1; ++j) ///多条线段换成m
        {
            scanf("%lf%lf%lf%lf",&amp;s.x,&amp;s.y,&amp;e.x,&amp;e.y);
            sum=solve(s,e);
        }
        printf("%.3f\n",sum);
    }
    return 0;
}
/*
Sample Input
4
0 0
0 1
1 1
1 0
0 0 1 1
4
0 0
0 1
1 1
1 0
0 0 1 0
9
0 0
0 2
1 1
2 2
3 1
4 2
5 1
6 2
6 0
0 1 6 1


Sample Output
1.414
1.000
6.000


*/
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>248</wp:post_id>
		<wp:post_date><![CDATA[2016-01-02 23:33:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-02 15:33:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%ad%a6%e9%99%a2%e5%a4%a7%e5%ad%a6%e7%94%9f%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%ab%9e%e8%b5%9b%ef%bc%88201512%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础(2) --顺序查找 &amp; 二分查找</title>
		<link>http://acmerbar.com/250.html</link>
		<pubDate>Mon, 04 Jan 2016 04:32:12 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=250</guid>
		<description></description>
		<content:encoded><![CDATA[回顾一下顺序查找&amp;&amp;二分查找

代码：
<pre class="lang:c++ decode:true ">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;


/*  顺序查找
适用范围: 没有进行排序的数据序列
缺点：速度非常慢, 效率为O(N)
*/
template &lt;typename Type&gt;
Type *sequenceSearch(Type *begin, Type *end, const Type &amp;searchValue)
throw(std::range_error)
{
    if ((begin == end) || (begin == NULL) || (end == NULL))
        throw std::range_error("pointer unavailable");

    for (Type *index = begin; index &lt; end; ++index)
    {
        if (*index == searchValue)
            return index;
    }
    return end;
}
template &lt;typename Type&gt;
Type *sequenceSearch(Type *array, int length, const Type &amp;searchValue)
throw(std::range_error)
{
    return sequenceSearch(array, array+length, searchValue);
}

/*
迭代二分查找
应用范围:数据必须首先排序,才能应用二分查找;效率为(logN)

算法思想:

	譬如数组{1， 2， 3， 4， 5， 6， 7， 8， 9}，查找元素6，用二分查找的算法执行的话，其顺序为：

	    1.第一步查找中间元素，即5，由于5&lt;6，则6必然在5之后的数组元素中，那么就在{6， 7， 8， 9}中查找，

	    2.寻找{6， 7， 8， 9}的中位数，为7，7&gt;6，则6应该在7左边的数组元素中，那么只剩下6，即找到了。

    二分查找算法就是不断将数组进行对半分割，每次拿中间元素和目标元素进行比较。
*/
template &lt;typename Type&gt;
Type *binarySearch(Type *begin, Type *end,Type &amp;searchValue)
{
    if( (begin == end) || (begin == NULL) || (end==NULL) )
      return 0;
    Type *left= begin ,right= end;
    while(left&lt;=right)
    {
        Type *mid = (left+right);
        if(*mid == searchValue) return mid;
        else if(searchValue&gt;*mid) left= mid+1;
        else right=mid-1;
    }
    return left; 
}
template &lt;typename Type&gt;
Type *binarySearch(Type *array, int length, const Type &amp;searchValue)
{
    return binarySearch(array, array+length, searchValue);
}
/*
递归二分查找
	算法思想如同迭代二分查找;
*/
//实现
template &lt;typename Type&gt;
Type *binarySearchByRecursion(Type *pre, Type *last, const Type &amp;searchValue)
{
    if ((pre == NULL) || (last == NULL))
        throw std::range_error("pointer unavailable");
    if (pre &lt;= last)
    {
        Type *mid = pre + (last-pre)/2;
        if (*mid == searchValue)
            return mid;
        else if (searchValue &gt; *mid) return binarySearchByRecursion(mid+1, last, searchValue);
        else return binarySearchByRecursion(pre, mid-1, searchValue);
    }
    return NULL;
}

</pre>
小结:

其实C++ 的STL已经实现好了std::binary_search(),在用的时候我们只需调用即可, 但是二分算法的思想还是非常重要的, 在求解一些较为复杂的问题时, 我们时常能够看到二分的身影.

学习自：<a href="http://m.blog.csdn.net/blog/hanqing280441589/42317853" target="_blank">http://m.blog.csdn.net/blog/hanqing280441589/42317853</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>250</wp:post_id>
		<wp:post_date><![CDATA[2016-01-04 12:32:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-04 04:32:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%802-%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%9f%a5%e6%89%be"><![CDATA[查找]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础(3) --堆排序</title>
		<link>http://acmerbar.com/254.html</link>
		<pubDate>Mon, 04 Jan 2016 12:53:40 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=254</guid>
		<description></description>
		<content:encoded><![CDATA[堆排序（Heap_Sort）,就是利用堆（完全二叉树，所有根节点的值大于等于左右结点的称为大顶堆，小于的称为小顶堆）（大顶堆或小顶堆）进行排序的方法，它的基本思想是：将待排序的序列构造成一个大顶堆
，此时，整个序列的最大值就是大顶堆的根结点，将它移走（其实就是将其与堆数组的末尾元素交换），此时末尾元素就是最大值
，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值，如此反复执行，便能得到一个有序序列
<pre class="lang:c++ decode:true">void heap_Adjust(int s,int m)/*对arr[1..n]进行堆调整，用temp做暂存单元 */
{
    int i,j,left,right,temp;
    temp = arr[s];
    left=2*s;/* 二叉树的性质，一颗完全二叉树，当前结点序号s，左儿子序号2s，右儿子序号2s+1*/
    for(; left&lt;=m; left*=2) /* 沿关键字较大的孩子结点向下筛选*/
    {
        if(arr[left]&lt;arr[left+1] &amp;&amp; left &lt;m) ++left;/*每次取左右儿子最大值,left为关键字中较大的记录的下标*/
        if(temp&gt;=arr[left]) break;
        arr[s]=arr[left];
        s=left;
    }
    arr[s]=temp;/*插入*/
}
void heap_Sort(int n)
{
    for(int i=n/2; i&gt;0; --i) /* 由一个无序的序列建成一个堆 */
        heap_Adjust(i,n);     /* 将arr[1-n]建成初始堆 */
    for(int i=n; i&gt;1; --i) /* 对当前无序区arr[1..i]进行堆排序，共做n-1趟。 */
    {
        swap(arr[1],arr[i]);
        /* 将堆顶和堆中最后一个记录交换 */
        heap_Adjust(1,i-1);/*将arr[1..i-1]重新调整为堆，仅有arr[1]可能违反堆性质 */
    }
}</pre>
复杂度分析：
堆排序的运行时间主要是消耗在初始构建堆和重建堆的反复筛选上
在建堆的过程中，因为我们是从完全二叉树的最下层最右边的非终端结点开始构建，将它与其子孩子进行比较交换，因此，对于
每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)
在正式排序时，第i次取堆记录重建堆需要用O（logi）的时间（完全二叉树的某个结点到根节点距离为【log2i】+1），并且需要取n-1次堆顶记录
因此，重建堆的时间复杂度为O（nlogn）
适合元素较多且不稳定

测试：
<pre class="lang:c++ decode:true ">/*
Please input total element number of the sequence:
Please input the elements one by one:
The sequence you input is:
   1   5   9   8   7
The sequence after heap_Sort is:
   1   5   7   8   9
Process returned 0 (0x0)   execution time : 0.140 s
Press any key to continue.
*/
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>254</wp:post_id>
		<wp:post_date><![CDATA[2016-01-04 20:53:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-04 12:53:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%803-%e5%a0%86%e6%8e%92%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础（4）--快速排序</title>
		<link>http://acmerbar.com/256.html</link>
		<pubDate>Tue, 05 Jan 2016 02:31:14 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=256</guid>
		<description></description>
		<content:encoded><![CDATA[<pre class="lang:c++ decode:true">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn = 1e5+10;
const int inf = 0x3f3f3f3f;
int arr[maxn];
int n;

int Partition(int arr[],int low,int high)
{
    int pivot_key;/*枢轴*/

    /*三数取中*/
//    int mid = (high+low)/2;
//    if(arr[low]&gt;arr[high]) swap(low,high);
//    if(arr[mid]&gt;arr[high]) swap(high,mid);
//    if(arr[mid]&gt;arr[low]) swap(mid,low);
    pivot_key=arr[low];/*将数组元素的第一个记录作为枢轴记录*/
    int temp=pivot_key;/*备份关键字*/
    while(low&lt;high)
    {
        while(low&lt;high &amp;&amp; arr[high]&gt;=pivot_key) --high; /*从后向前搜索比key小的值*/
        arr[low]=arr[high];                             /*比key小的放左边*/
        while(low&lt;high &amp;&amp; arr[low] &lt;=pivot_key) ++low;  /*从前向后搜索比key大的值，比key大的放右边*/
        arr[high]=arr[low];                             /*比key大的放右边*/
    }
    arr[low]=temp;
    return low;
}
void Quick_Sort(int arr[],int low,int high)
{
    int pivot;
    /*
    if(low&lt;high)
    {
        pivot = Partition(arr,low,high);
        Quick_Sort(arr,low,pivot-1);
        Quick_Sort(arr,pivot+1,high);
    }
    */
    /*递归尾部优化*/
    while(low&lt;high)
    {
        pivot = Partition(arr,low,high);
        Quick_Sort(arr,low,pivot-1);
        low=pivot+1;
    }
}
int main()
{
    freopen("1.txt","r",stdin);
    puts("Please input total element number of the sequence:");
    scanf("%d",&amp;n);
    if(n&lt;=0||n&gt;inf)
    {
        printf("n must more than 0 and less than %d.\n",inf);
        exit(0);
    }
    puts("Please input the elements one by one:");
    for(int i=0; i&lt;n; ++i)
        scanf("%d",&amp;arr[i]);
    puts("The sequence you input is:");
    for(int i=0; i&lt;n; ++i)
        printf("%4d",arr[i]);
    Quick_Sort(arr,0,n-1);
    puts("\nThe sequence after Quick_Sort is:");
    for(int i=0; i&lt;n; ++i)
        printf("%4d",arr[i]);
    return 0;
}

/*
Please input total element number of the sequence:
Please input the elements one by one:
The sequence you input is:
  27  38  13  49  76  97  65
The sequence after Quick_Sort is:
  13  27  38  49  65  76  97
Process returned 0 (0x0)   execution time : 0.479 s
Press any key to continue.
*/
</pre>
快速排序是最流行的,也是速度最快的排序算法(C++ STL 的sort函数就是实现的快速排序); 快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据序列变成有序序列。其算法的特点就是有一个枢轴(pivot), 枢轴左边的元素都小于/等于枢轴所指向的元素, 枢轴右边的元素都大于枢轴指向的元素;

快速排序算法思想:

设要排序的数组是A[0], ..., A[N-1]，首先任意选取一个数据作为standard（通常选用数组的最后一个数）作为关键数据，然后将所有比它小的数都放到它前面,所有比它大的数都放到它后面(其实只要保证所有比他小的元素都在其前面,则后一条件则自动满足了),这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。(信息来源:百度百科)

《算法导论》的思想：

代码：
<pre class="lang:c++ decode:true ">/**说明: 
    几乎国内所有的数据结构与算法的教材中的Partition实现都 
    类似于上面的那一种, 虽然易于理解,但实现过于复杂; 
    &lt;算法导论&gt;中给出了另一种实现方式, 
    该方式虽然不易于理解(其实明白其原理之后你就会爱上她),但是比较容易实现! 
*/  
template &lt;typename Type&gt;  
int partitionBy1Loop(Type *array, int p, int r)  
{  
    Type x = array[r];  //x作为最终枢轴所指向的元素  
    //i指向的是枢轴左边的最后一个元素  
    //也就是与x左邻元素的下标  
    int i = p - 1;  
    //j则不断的寻找下一个&lt;=x的元素  
    for (int j = p; j &lt; r; ++j)  
    {  
        if (array[j] &lt;= x)  
        {  
            ++ i;  
            std::swap(array[i], array[j]);  
        }  
    }  
    std::swap(array[i+1], array[r]);  
  
    //最终使得所有(i+1)左边的元素都&lt;=array[i+1],  
    //因此, 所有array[i+2:r]的元素都是大于array[i+1]的  
  
    return i+1;  
}</pre>
<h2>快速排序的时间复杂性</h2>
假设一次划分所得枢轴位置 i = k，则对 n 个记录进行快排所需时间：

T(n) = {Tpass(n) + T(k-1) + T(n-k) |Tpass(n)为对 n 个记录进行一次划分所需时间}

若待排序列中记录的关键字是随机分布的，则 k 取 1 至 n 中任意一值的可能性相同。

由此可得快速排序所需时间的平均值为：

<img src="http://img.blog.csdn.net/20150103140440921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" />

设 Tavg(1)≤b,则可得结果：

<img src="http://img.blog.csdn.net/20150103140533593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" />

因此:快速排序的时间复杂度为O(nlogn)

若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n^2)。

为避免出现这种情况，需在进行一次划分之前，进行“预处理”，即:先对 R(s).key,  R(t).key 和 R[ë(s+t)/2û].key，进行相互比较，然后取关键字为三个元素中居中间的那个元素作为枢轴记录。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>256</wp:post_id>
		<wp:post_date><![CDATA[2016-01-05 10:31:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-05 02:31:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%80%ef%bc%884%ef%bc%89-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%ef%bc%88quick_sort%ef%bc%89"><![CDATA[快速排序（Quick_Sort）]]></category>
		<category domain="category" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础（5）--归并排序</title>
		<link>http://acmerbar.com/258.html</link>
		<pubDate>Tue, 05 Jan 2016 02:45:22 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=258</guid>
		<description></description>
		<content:encoded><![CDATA[归并排序的基本思想：

将两个或两个以上的有序子序列”归并”为一个有序序列:假定待排序表含有n个记录, 则可以看成是n个有序的子表, 每个子表长度为1, 然后两两归并, 得到[n/2]个长度为2或1的有序表,; 再量量归并, ...., 如此重复, 直到合并成为一个长度为n的有序表为止, 这种排序方法称为2-路归并排序.如图为一个2-路归并排序的一个示例:

<img src="http://img.blog.csdn.net/20150103194801441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvempmMjgwNDQxNTg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" />

代码：（递归实现）
<pre class="lang:c++ decode:true ">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn = 1e5+10;
const int inf = 0x3f3f3f3f;
int arr[maxn];
int n;

/*将有序的r1[s..m]和r1[m+1..n]归并到有序的t1[i..n];*/
void Merge(int r1[],int t1[],int s,int m,int n)
{
    int j,k,l;
    for(j=m+1, k=s; s&lt;=m&amp;&amp;j&lt;=n; ++k) /*将r1[]中记录由小到大归并到t1[]*/
    {
        if(r1[s]&lt;r1[j])
            t1[k]=r1[++s];
        else t1[k]=r1[++j];
    }
    if(s&lt;=m)
    {
        for(l=0; l&lt;=m-s; ++l)
            t1[k+l]=r1[s+l];   /*将剩余的r1[s..m]*复制到t1[];*/
    }
    if(j&lt;=n)
    {
        for(l=0; l&lt;=n-j; ++l)
            t1[k+l]=r1[j+l]; /*将剩余的r1[j..n]*复制到t1[];*/
    }
}
int r1[maxn],t1[maxn],t2[maxn];
/*将 r1[s..t] 归并排序为 t1[s..t]*/
void Msort(int r1[],int t1[],int s,int t)
{
    int m;
    if(s==t) t1[s]=r1[s];
    else
    {
        m=(s+t)&gt;&gt;1;  /*将r1[s..t]平分为r1[s..m],r1[m+1..t];*/
        Msort(r1,t2,s,m); /*递归将r1[s..m]归并为有序的t2[s..m];*/
        Msort(r1,t2,m+1,t);/*递归将r1[m+1..t]归并为有序的t2[m+1..t];*/
        Merge(t2,t1,s,m,t);/*递归将t2[s..m]归并为有序的t2[m+1..t]归并到t1[s..t];*/
    }
}
</pre>
可以看出对n个记录进行归并排序的时间复杂度为Ο(nlogn)。即:

(1)每一趟归并(合并)的时间复杂度为 O(n);

(2)总共需进行[logn]趟。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>258</wp:post_id>
		<wp:post_date><![CDATA[2016-01-05 10:45:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-05 02:45:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%80%ef%bc%885%ef%bc%89-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%ef%bc%88merge_sort%ef%bc%89"><![CDATA[归并排序（Merge_Sort）]]></category>
		<category domain="category" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>数据结构基础（5）--线性表的操作</title>
		<link>http://acmerbar.com/259.html</link>
		<pubDate>Wed, 06 Jan 2016 13:22:36 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=259</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

代码：
<pre class="lang:c++ decode:true ">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn = 1e5+10;
const int inf = 0x3f3f3f3f;
int arr[maxn];
int n;
typedef int status;
typedef int ElemType;
typedef struct
{
    ElemType data[maxn]; /*数组存储数据元素*/
    int length; /*线性表当前长度*/
} Sqlist;
/*初始条件：顺序线性表已经存在*/
/*用e返回L中第i个数据元素的值*/
status Getelem(Sqlist *L,int i,ElemType *e)
{
    if(L-&gt;length==0 || i&lt;1 ||i&gt;L-&gt;length) return false;
    *e=L-&gt;data[i-1];
    return true;
}

/*insert */
/*
*若插入位置不合理，抛出异常;
*L.length &gt;= maxn return false;
*from the last position to the i-th position move back one position
*insert e to the i-th position
*length+=1;
*/
status ListInsert(Sqlist *L,int i,ElemType e)
{
     if(L-&gt;length&gt;=maxn) return false;
     if(i&lt;1 || i&gt;L-&gt;length+1) return false;
     if(i&lt;=L-&gt;length) /*若插入位置合法*/
     {
         for(int k=L-&gt;length-1; k&gt;=i-1; --k)
            L-&gt;data[k+1]=L-&gt;data[k];
     }
     L-&gt;data[i-1]=e;
     L-&gt;length++;
     return true;
}

/*delete */
/*
*如果删除位置不合理，抛出异常
*pick up the delete e
*from the e position to the last position,than move pre one position
*length-=1;
*/
status ListDelete(Sqlist *L,int i,ElemType *e)
{
    if(L-&gt;length ==0 )return false;
    if(i&lt;1 || i&gt;L-&gt;length) return false;
    *e=L-&gt;data[i-1];
    if(i&lt;L-&gt;length)
    {
        for(int k=i; k&lt;L-&gt;length; ++k)
            L-&gt;data[k-1]=L-&gt;data[k];
    }
    L-&gt;length--;
    return true;
}
/*
线性表的顺序存储结构，在存，读取数据时，时间复杂度为O（1），插入或删除为O(n)
优点：
无须为表示表中元素之间的逻辑关系而增加额外的存储空间
可以快速的存取表中的元素
缺点：插入和删除操作要移动大量元素，难以确定存储空间的容量，造成存储空间的“碎片”
*/</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>259</wp:post_id>
		<wp:post_date><![CDATA[2016-01-06 21:22:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-06 13:22:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%9f%ba%e7%a1%80%ef%bc%885%ef%bc%89-%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%9a%84%e6%93%8d%e4%bd%9c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e7%ba%bf%e6%80%a7%e8%a1%a8"><![CDATA[线性表]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 1060 Leftmost Digit(数学技巧)</title>
		<link>http://acmerbar.com/261.html</link>
		<pubDate>Thu, 14 Jan 2016 11:39:59 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=261</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="font-family: SimSun; font-size: medium;">【链接】：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1060" target="_blank">click here~~</a></span>

<span style="font-family: SimSun; font-size: medium;">【题意】：求n^n得到的数的最左边的数</span>

<span style="font-family: SimSun; font-size: medium;">【思路】</span>

<span style="font-family: SimSun; font-size: medium;">开始看到此题首先想到的是位运算，记得有一个向右取第k 位数的技巧：<span class="Apple-style-span">　num &gt;&gt; (num_length-1) &amp; 1，则还需要知道数的位数，可以转换成字符串来处理</span></span>

<span style="font-family: SimSun; font-size: medium;">另外一种巧妙的方法：</span>

<span style="font-family: SimSun; font-size: medium;">需要用到科学记数法和对数运算的知识：把num^num的值记作：num^num=a*10^n，比如三位数abc= a.bc*10^2,那么（1&lt;a&lt;10）;
然后通过两边取对数的方法得到num*log10(1.0*num)=log10(a)+n,这时0&lt;log10(a)&lt;1;令x=n+log10(a),得到log10(a)=x-n;所以a=10^(x-n)；n为整数部分，log10(a)为小数部分，由x=n+log10(a),可知(int)x=n；最终a=10^（x-n）=10^(x-(int)x)
</span>

<span style="font-family: SimSun; font-size: medium;">代码：</span>
<pre class="lang:c++ decode:true ">/*
Problem :HDU 1060 Leftmost Digit
Author : herongwei
Language : G++
Result : Accepted
CreateTime: 2016/01/11
*/
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
int main()
{
    // freopen("1.txt","r",stdin);
    int t;
    scanf("%d",&amp;t);
    while(t--)
    {
        int n;
        scanf("%d",&amp;n);
        double m;
        if(n==1){puts("1");continue;}
        m=n*log10((double)n);
        m-=(long long)m;
        printf("%d\n",(int)pow(10,m));
    }
    return 0;
}</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>261</wp:post_id>
		<wp:post_date><![CDATA[2016-01-14 19:39:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-14 11:39:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-1060-leftmost-digit%e6%95%b0%e5%ad%a6%e6%8a%80%e5%b7%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e5%ad%a6%e9%a2%98"><![CDATA[数学题]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HDU 2183 How many prime numbers（大素数判断）</title>
		<link>http://acmerbar.com/262.html</link>
		<pubDate>Thu, 14 Jan 2016 12:33:23 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=262</guid>
		<description></description>
		<content:encoded><![CDATA[HDU 2183   How many prime numbers

大素数判断

【思路】Miller_Rabin 算法进行素数测试

代码：
<pre class="lang:c++ decode:true">/*
Problem :HDU 2138 How many prime numbers
Author  : herongwei
Language : G++
Result  : Accepted
CreateTime: 2016/01/14
*/
#include &lt;math.h&gt;
#include &lt;queue&gt;
#include &lt;time.h&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;
#define Max(a,b) a&gt;b?a:b
#define Min(a,b) a&gt;b?b:a
#define mem(a,b) memset(a,b,sizeof(a))
int dir[4][2]= {{1,0},{-1,0},{0,1},{0,-1}};
const double eps = 1e-6;
const double Pi = acos(-1.0);
static const int inf= 0x3f3f3f3f;
static const int maxn = 1e5+10;
typedef long long LL;

/* *************************************************
* Miller_Rabin 算法进行素数测试
* 速度快，可以判断一个 &lt; 2^63 的数是不是素数
*
**************************************************/
const int S = 8; //随机算法判定次数，一般8~10就够了
// 计算ret = (a*b)%c a,b,c &lt; 2^63
LL mult_mod(LL a,LL b,LL c)
{
    a %= c;
    b %= c;
    LL ret = 0;
    LL tmp = a;
    while(b)
    {
        if(b &amp; 1)
        {
            ret += tmp;
            if(ret &gt; c)ret -= c;//直接取模慢很多
        }
        tmp &lt;&lt;= 1;
        if(tmp &gt; c)tmp -= c;
        b &gt;&gt;= 1;
    }
    return ret;
}
// 计算 ret = (a^n)%mod
LL pow_mod(LL a,LL n,LL mod)
{
    LL ret = 1;
    LL temp = a%mod;
    while(n)
    {
        if(n &amp; 1)ret = mult_mod(ret,temp,mod);
        temp = mult_mod(temp,temp,mod);
        n &gt;&gt;= 1;
    }
    return ret;
}
// 通过 a^(n-1)=1(mod n)来判断n是不是素数
// n-1 = x*2^t 中间使用二次判断
// 是合数返回true, 不一定是合数返回false
bool check(LL a,LL n,LL x,LL t)
{
    LL ret = pow_mod(a,x,n);
    LL last = ret;
    for(int i = 1; i &lt;= t; i++)
    {
        ret = mult_mod(ret,ret,n);
        if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n-1)return true;//合数
        last = ret;
    }
    if(ret != 1)return true;
    else return false;
}
//**************************************************
// Miller_Rabin算法
// 是素数返回true,(可能是伪素数)
// 不是素数返回false
//**************************************************
bool Miller_Rabin(LL n)
{
    if( n &lt; 2)return false;
    if( n == 2)return true;
    if( (n&amp;1) == 0)return false;//偶数
    LL x = n - 1;
    LL t = 0;
    while( (x&amp;1)==0 )
    {
        x &gt;&gt;= 1;
        t++;
    }
    srand(time(NULL));/* *************** */
    for(int i = 0; i &lt; S; i++)
    {
        LL a = rand()%(n-1) + 1;
        if( check(a,n,x,t) )
            return false;
    }
    return true;
}
int main()
{
    //freopen("1.txt","r",stdin);
    LL n,m,sum;
    while(~scanf("%lld",&amp;n))
    {
        sum=0;
        for(int i=0; i&lt;n; ++i)
        {
            scanf("%lld",&amp;m);
            if(Miller_Rabin(m)) sum++;
        }
        printf("%lld\n",sum);
    }
    return 0;
}
</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>262</wp:post_id>
		<wp:post_date><![CDATA[2016-01-14 20:33:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-14 12:33:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hdu-2183-how-many-prime-numbers%ef%bc%88%e5%a4%a7%e7%b4%a0%e6%95%b0%e5%88%a4%e6%96%ad%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[11]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>分布式处理之MapReduce</title>
		<link>http://acmerbar.com/263.html</link>
		<pubDate>Wed, 20 Jan 2016 13:50:23 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=263</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>分布式处理之MapReduce</h1>
<h2><a id="user-content-方法介绍" class="anchor" href="http://taop.marchtea.com/06.05.html#%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"></a>方法介绍</h2>
MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。

适用范围：数据量大，但是数据种类小可以放入内存

基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。
<h3><a id="user-content-基础架构" class="anchor" href="http://taop.marchtea.com/06.05.html#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"></a>基础架构</h3>
读者必须先要明确以下几点，以作为阅读后续内容的基础知识储备：
<ol>
	<li>MapReduce是一种模式。</li>
	<li>Hadoop是一种框架。</li>
	<li>Hadoop是一个实现了MapReduce模式的开源的分布式并行编程框架。</li>
</ol>
所以，你现在，知道了什么是MapReduce，什么是hadoop，以及这两者之间最简单的联系，而本文的主旨即是，一句话概括： <strong><em>在hadoop的框架上采取MapReduce的模式处理海量数据</em> </strong>。下面，咱们可以依次深入学习和了解MapReduce和hadoop这两个东西了。
<h3><a id="user-content-mapreduce模式" class="anchor" href="http://taop.marchtea.com/06.05.html#mapreduce%E6%A8%A1%E5%BC%8F"></a>MapReduce模式</h3>
前面说了，MapReduce是一种模式，一种什么模式呢?一种云计算的核心计算模式，一种分布式运算技术，也是简化的分布式编程模式，它主要用于解决问题的程序开发模型，也是开发人员拆解问题的方法。

Ok，光说不上图，没用。如下图所示，MapReduce模式的主要思想是将自动分割要执行的问题（例如程序）拆解成Map（映射）和Reduce（化简）的方式，流程图如下图1所示：
<a href="http://taop.marchtea.com/images/8/8.2/8.2.1.gif" target="_blank"><img src="http://taop.marchtea.com/images/8/8.2/8.2.1.gif" alt="" /></a>

在数据被分割后通过Map函数的程序将数据映射成不同的区块，分配给计算机机群处理达到分布式运算的效果，在通过Reduce 函数的程序将结果汇整，从而输出开发者需要的结果。

MapReduce借鉴了函数式程序设计语言的设计思想，其软件实现是指定一个Map函数，把键值对(key/value)映射成新的键值对(key/value)，形成一系列中间结果形式的key/value 对，然后把它们传给Reduce(规约)函数，把具有相同中间形式key的value合并在一起。Map和Reduce函数具有一定的关联性。函数描述如表1 所示：
<a href="http://taop.marchtea.com/images/8/8.2/8.2.2.gif" target="_blank"><img src="http://taop.marchtea.com/images/8/8.2/8.2.2.gif" alt="" /></a>

MapReduce致力于解决大规模数据处理的问题，因此在设计之初就考虑了数据的局部性原理，利用局部性原理将整个问题分而治之。MapReduce集群由普通PC机构成，为无共享式架构。在处理之前，将数据集分布至各个节点。处理时，每个节点就近读取本地存储的数据处理（map），将处理后的数据进行合并（combine）、排序（shuffle and sort）后再分发（至reduce节点），避免了大量数据的传输，提高了处理效率。无共享式架构的另一个好处是配合复制（replication）策略，集群可以具有良好的容错性，一部分节点的down机对集群的正常工作不会造成影响。

ok，你可以再简单看看下副图，整幅图是有关hadoop的作业调优参数及原理，图的左边是MapTask运行示意图，右边是ReduceTask运行示意图：
<a href="http://taop.marchtea.com/images/8/8.2/8.2.3.gif" target="_blank"><img src="http://taop.marchtea.com/images/8/8.2/8.2.3.gif" alt="" /></a>

如上图所示，其中map阶段，当map task开始运算，并产生中间数据后并非直接而简单的写入磁盘，它首先利用内存buffer来对已经产生的buffer进行缓存，并在内存buffer中进行一些预排序来优化整个map的性能。而上图右边的reduce阶段则经历了三个阶段，分别Copy-&gt;Sort-&gt;reduce。我们能明显的看出，其中的Sort是采用的归并排序，即merge sort。
<h2><a id="user-content-问题实例" class="anchor" href="http://taop.marchtea.com/06.05.html#%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B"></a>问题实例</h2>
<ol>
	<li>The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:</li>
	<li>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</li>
	<li>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</li>
</ol>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>263</wp:post_id>
		<wp:post_date><![CDATA[2016-01-20 21:50:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-20 13:50:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%88%86%e5%b8%83%e5%bc%8f%e5%a4%84%e7%90%86%e4%b9%8bmapreduce]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="professional-employment-work"><![CDATA[专业-就业-工作]]></category>
		<category domain="category" nicename="%e4%ba%91%e8%ae%a1%e7%ae%97"><![CDATA[云计算]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++标准模板库函数系列之count</title>
		<link>http://acmerbar.com/268.html</link>
		<pubDate>Wed, 27 Jan 2016 12:41:46 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=268</guid>
		<description></description>
		<content:encoded><![CDATA[C++标准模板库函数，用于统计某一值在一定范围内出现的次数。
<h2 class="para-title level-2"><span class="title-text">函数功能</span></h2>
<div class="para">统计某一值在一定范围内出现的次数（函数模板）Count appearances of value in range</div>
<div class="para">
<h2 class="para-title level-2"><span class="title-text">函数原型</span></h2>
<div>
<div id="highlighter_316361" class="syntaxhighlighter  cpp">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div></td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">class</code> <code class="cpp plain">InputIterator, </code><code class="cpp keyword bold">class</code> <code class="cpp plain">T&gt;  </code></div>
<div class="line number2 index1 alt1"><code class="cpp keyword bold">typename</code> <code class="cpp plain">iterator_traits&lt;InputIterator&gt;::difference_type </code></div>
<div class="line number3 index2 alt2"><code class="cpp plain">count (</code></div>
<div class="line number4 index3 alt1"><code class="cpp plain">InputIterator first, </code></div>
<div class="line number5 index4 alt2"><code class="cpp plain">InputIterator last, </code></div>
<div class="line number6 index5 alt1"><code class="cpp keyword bold">const</code> <code class="cpp plain">T&amp; val</code></div>
<div class="line number7 index6 alt2"><code class="cpp plain">);</code></div>
</div></td>
</tr>
</tbody>
</table>
<h2 class="para-title level-2"><span class="title-text">输入参数</span></h2>
<div class="para">         first：查询的起始位置，为一个迭代器
last： 查询的结束位置，为一个迭代器</div>
<div class="para">
<h2 class="para-title level-2"><span class="title-text">返回值</span></h2>
<div class="para">通过比较是否等于 val 返回[first,last]与 val相等的数值的个数。（Returns the number of elements in the range [first,last] that compare equal to val.）</div>
</div>
<div class="para">
<h2 class="para-title level-2"><span class="title-text">注意事项</span></h2>
<div class="para">       注意本函数与find的区别：
count 返回值为查找的个数
find 返回值为一个迭代器</div>
</div>
<h2 class="para">实例</h2>
<pre class="lang:c++ decode:true ">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    using namespace std;
    vector&lt;int&gt; vecIntegers;
    for (int nNum=-9; nNum&lt;10; ++nNum)
    {
        vecIntegers.push_back(nNum);
    }
    vector&lt;int&gt;::const_iterator iElementLocator;
    for (iElementLocator=vecIntegers.begin();iElementLocator != vecIntegers.end();++iElementLocator)
    {
        cout &lt;&lt; *iElementLocator &lt;&lt; ' ';
    }
    ////////////////////////////////关键代码///////////////////////////////////////////////////////
    size_t nNumZoros = count(vecIntegers.begin(), vecIntegers.end(), 0); //查看0的个数
    //////////////////////////////////////////////////////////////////////////////////////
    cout &lt;&lt; "vector 中 0 的个数为：" &lt;&lt; nNumZoros &lt;&lt; endl &lt;&lt; endl;
    return 0;
}
运行结果
1
2
3
-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9
vector 中 0 的个数为：1
Press any key to continue
</pre>
&nbsp;
<div class="para">：</div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>268</wp:post_id>
		<wp:post_date><![CDATA[2016-01-27 20:41:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-27 12:41:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[c%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf%e5%ba%93%e5%87%bd%e6%95%b0%e7%b3%bb%e5%88%97%e4%b9%8bcount]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="stl%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf%e5%ba%93"><![CDATA[STL标准模板库]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[7]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++标准模板库函数系列之count_if</title>
		<link>http://acmerbar.com/269.html</link>
		<pubDate>Wed, 27 Jan 2016 12:45:42 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=269</guid>
		<description></description>
		<content:encoded><![CDATA[这个模板函数是<a href="http://baike.baidu.com/subview/3236256/17259245.htm" target="_blank">count函数</a>的泛化版本,用断言指定的条件代替等于一个指定的值。 如果第三个参数为真，则返回[_First, _Last)范围之间的个数。

实例：
<pre class="lang:c++ decode:true">实例
#include &lt;bits/stdc++.h&gt;

using namespace std;

bool Judge(int value)
{
    return value &gt;10;
}
int main()
{
    vector&lt;int&gt; v1;
    vector&lt;int&gt;::iterator Iter;
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(10);
    v1.push_back(40);
    v1.push_back(10);
    for (Iter = v1.begin(); Iter != v1.end(); Iter++) cout &lt;&lt; *Iter &lt;&lt; " ";
    vector&lt;int&gt;::iterator::difference_type result1;
    result1 = count_if(v1.begin(), v1.end(), Judge);
    cout &lt;&lt; "The number of elements in v1 greater than 10 is: "
         &lt;&lt; result1 &lt;&lt; "." &lt;&lt; endl;
}
运行结果
1
2
v1 = 10 20 10 40 10
The number of elements in v1 greater than 10 is: 2.</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>269</wp:post_id>
		<wp:post_date><![CDATA[2016-01-27 20:45:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-27 12:45:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[c%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf%e5%ba%93%e5%87%bd%e6%95%b0%e7%b3%bb%e5%88%97%e4%b9%8bcount_if]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="stl%e6%a0%87%e5%87%86%e6%a8%a1%e6%9d%bf%e5%ba%93"><![CDATA[STL标准模板库]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>四种GCC内置位运算函数</title>
		<link>http://acmerbar.com/270.html</link>
		<pubDate>Thu, 28 Jan 2016 10:56:56 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=270</guid>
		<description></description>
		<content:encoded><![CDATA[<ul>
	<li>int __builtin_ffs (unsigned int x)
返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4。</li>
	<li>int __builtin_clz (unsigned int x)
返回前导的0的个数。</li>
	<li>int __builtin_ctz (unsigned int x)
返回后面的0个个数，和__builtin_clz相对。</li>
	<li>int __builtin_popcount (unsigned int x) (很有用处啊)
返回二进制表示中1的个数。</li>
	<li>int __builtin_parity (unsigned int x)
返回x的奇偶校验位，也就是x的1的个数模2的结果。</li>
</ul>
此外，这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如int __builtin_clzll。

此外，基于稀疏表（Sparse Table）的RMQ问题，可以使用 __builtin_clz函数进行预处理。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>270</wp:post_id>
		<wp:post_date><![CDATA[2016-01-28 18:56:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-28 10:56:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9b%9b%e7%a7%8dgcc%e5%86%85%e7%bd%ae%e4%bd%8d%e8%bf%90%e7%ae%97%e5%87%bd%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cc"><![CDATA[C/C++]]></category>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[21]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《Desperate Housewives/绝望的主妇》8段经典美句</title>
		<link>http://acmerbar.com/272.html</link>
		<pubDate>Sat, 06 Feb 2016 08:33:52 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=272</guid>
		<description></description>
		<content:encoded><![CDATA[<b>论身份（1）</b>
<blockquote><b>1.When I was alive,I maintained many different identities-lover,wife,and ultimately,victim.Yes,labels are important to the living.They dictate how people see themselves.</b>

<b>当我活着的时候，我保持着很多不同的身份--恋人，妻子，最终是受害者。是的，这样那样的标签对于活着的人们来说是很重要的，因为它指示了人们如何看待自己。</b></blockquote>
<b>笔记：</b>

<b>identity n.身份；ID卡= identity card;</b>

<b>PIN = Personal Identification Number;</b>

<b>label n 标签； the+形容词 表示一类人</b>

<b>dictate v :命令 issue commands or orders for</b>

<b>论身份（2）</b>
<blockquote><b>Competition , it means different things to different people,But whether to friendly rivalry.or fight to the death.The end result is the same.There will be Winners,and there will be Losers,Of course the trick is ,to know which battles to fight,you see,no victory comes without a price.</b>

<b>竞争因人而异，但是不管是友好竞争还是生死决斗，结果都是相同的--有赢家，也有输家。但是，诀窍是，懂得去参加什么样的竞争，要知道，胜利都是用代价换来的。</b></blockquote>
<b>笔记：</b>

<b>rival 对手 区别enemy - rivalry n.竞争，对抗</b>

<b>trick n .窍门，花招 - tricky</b>

<b>battle n .战争</b>
<blockquote><b>论身份（3）</b>

<b>People are complicated creatures ,on the one hand able to perform great acts of charity,on the other,capable of the most underhanded forms of betrayal,it is a constant battle that rages within all of us,because the better angels of our nature,and the temptation of our inner demons,and sometimes the only way to ward off darkness ,is to share a light of compassion.</b>

<b>人类是复杂的动物，一方面，表现着善心，另一方面，却又表现阴险和背叛，我们都时常在天性的本善与内心的恶魔之间挣扎。有时候，唯一能阻挡黑暗的方法，就是闪耀怜悯的光辉</b></blockquote>
<b>笔记：</b>

<b>underhanded adj.阴险的。</b>

<b>rage vi.流行，发怒的</b>

<b>ward vt.避开 ward off 避开；compassion ：同情</b>
<blockquote><b>论信任（4）</b>

<b>Trust is a fragile thing ,once earned,it affords us tremendous freedom,but once trust is lost,it can be impossible to recover,of course,the truth is we never know who can trust ,those we ` re closest to can betray us,and total </b><b>strangers can come to our rescue,in the end,most people decide to trust themselves,it really is the simplest way,to keep from getting burned.</b>

<b>信任真是一件脆弱的东西，一旦赢得信任，会提供给我们巨大的空间，而一旦失去了，就不可能在恢复。当然，事实上我们永远不知道我们能信任谁：那些我们最亲近的人可能会背叛我们；而陌生人却能帮助我们，最后，大多数人决定只能信任他们自己。这的确是最简单的方法，来防止引火烧身。</b></blockquote>
<b>笔记：</b>

<b>tremendous adj.巨大的  recover v.恢复</b>

<b>betray v.背叛 rescue n,vt 拯救，救援。</b>

<b>论英雄（5）</b>
<blockquote><b>We all honor heroes for different reasons,sometimes for their daring,sometimes for their bravery,sometimes for their goodness,but mostly we honor heroes,because at one point or another,we all dream to be rescued ,of course if the right hero doesn`t come along,sometimes we just have to rescue by ourselves.</b>

<b>我们都因为各种各样的原因崇拜英雄：有时是因为他们敢于冒险，有时是因为他们的勇敢，有时是因为他们的善良。但是，绝大部分，是因为，或多或少，我们都梦想着被拯救。当然，如果我们盼望的英雄没有出现，有时候，我们就必须自我拯救了。</b></blockquote>
<b>笔记：</b>

<b>daring 胆量；bravery 勇敢</b>
<blockquote><b>论春天（6）</b>

<b>Spring comes every year to Wisteria Lane,It is the time when flowers start to bloom,when butterflies emerge from their cocoons,when bees begin to search for nectar.Sping is also the time when a young man`s fancy turns to obsession</b>

<b>春天每年都降临在紫藤巷，这是花开锦簇的时节，蝴蝶终于破茧而出，蜜蜂也到处寻找花蜜，春天也让年轻人的幻想变成一种狂热。</b></blockquote>
<b>笔记：</b>

<b>bloom 使...茂盛</b>

<b>butterfly 蝴蝶；cocoon 茧</b>

<b>Bee 蜜蜂；nectar 花蜜</b>

<b>obsession n.沉溺</b>
<blockquote><b>论誓言（7）</b>

<b>The vow is simple ,really .Those who take it promise to stay together,for better or for worse,for richer or for poorer,in sickness and in health,to honor and to cherish,forsaking all others,untill death do us part.Yes,the vow is simple.Finding someone worthy of such a promise is the hard part.But if we can ,that`s when we begin to live happily even after.</b>

<b>婚姻誓言其实很简单。双方要发誓不论顺境或是逆境，尊重并且珍惜对方，贫穷或是富有，疾病或者健康，永远忠贞，至死不渝。是的，誓言很简单，找到值得为其许下这个誓言的人才是困难的。但要是我们找到了，那就是从此幸福的生活在一起的故事的开始。</b></blockquote>
<blockquote><b>论誓言（8）</b>

<b>Nothing is forever.And the time comes when we all must say goodbye to the world we know.Goodbye to everything we had taken for granted.</b><b>Goodbye to those we thought would never abandon us.And when these changes finally do occur,when the familiar has departed and the unfamiliar has taken its place,all any of us can really do is to say hello and welcome.</b>

<b>没有什么事情是永恒的。当时间到来，我们不得不挥手告别我们熟悉的世界；告别我们深知的一切；告别认为会用不抛弃我们的人。当着这些改变最终发生的时候，当熟悉远离而陌生来领的时候，我们所能做的，就是说声“你好，欢迎”。</b></blockquote>
<b>笔记：</b>

<b>take ... for granted 把...认为理所当然</b>

<b>depart v.离开</b>

<b>最喜欢的一句：</b>
<blockquote><b>论desperation（绝望）</b>

<b>We all have moments  of desperation.If we can face them head on,that`s when we find out just how strong we really are.</b>

<b>我们都有绝望的时候，如果我们能够直面面对，那时候我们才知道我们到底有多坚强。</b></blockquote>
<b>看看美剧果然是个学习英语的好方法，附下载链接</b>

<a href="http://www.meijutt.com/content/meiju612.html" target="_blank">绝望的主妇</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>272</wp:post_id>
		<wp:post_date><![CDATA[2016-02-06 16:33:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-02-06 08:33:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8adesperate-housewives%e7%bb%9d%e6%9c%9b%e7%9a%84%e4%b8%bb%e5%a6%87%e3%80%8b8%e6%ae%b5%e7%bb%8f%e5%85%b8%e7%be%8e%e5%8f%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="professional-employment-work"><![CDATA[专业-就业-工作]]></category>
		<category domain="category" nicename="%e8%8b%b1%e8%af%ad%e5%ad%a6%e4%b9%a0"><![CDATA[英语学习]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Codeforces Round #342 (Div. 2)</title>
		<link>http://acmerbar.com/274.html</link>
		<pubDate>Sun, 07 Feb 2016 12:17:31 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=274</guid>
		<description></description>
		<content:encoded><![CDATA[比赛链接：<a href="http://codeforces.com/contest/625" target="_blank">http://codeforces.com/contest/625</a>

A：换瓶子问题，智力题

B:字符串子串个数判断

C：矩阵单调递增

代码：<a href="http://blog.csdn.net/u013050857/article/details/50643139" target="_blank">http://blog.csdn.net/u013050857/article/details/50643139</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>274</wp:post_id>
		<wp:post_date><![CDATA[2016-02-07 20:17:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-02-07 12:17:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[codeforces-round-342-div-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="cf"><![CDATA[CF]]></category>
		<category domain="category" nicename="%e6%af%94%e8%b5%9b"><![CDATA[比赛]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[23]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>矩阵相乘的算法研究</title>
		<link>http://acmerbar.com/275.html</link>
		<pubDate>Tue, 09 Feb 2016 08:36:49 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=275</guid>
		<description></description>
		<content:encoded><![CDATA[<div class="page">
<div class="file-box">
<div class="file">
<div id="readme" class="blob instapaper_body announce md"><article class="markdown-body entry-content">
<h1>矩阵相乘</h1>
<h2><a id="user-content-题目描述" class="anchor" href="http://taop.marchtea.com/02.08.html#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"></a>题目描述</h2>
请编程实现矩阵乘法，并考虑当矩阵规模较大时的优化方法。
<h2><a id="user-content-分析与解法" class="anchor" href="http://taop.marchtea.com/02.08.html#%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E6%B3%95"></a>分析与解法</h2>
根据wikipedia上的介绍：两个矩阵的乘法仅当第一个矩阵A的行数和另一个矩阵B的列数相等时才能定义。如A是m×n矩阵，B是n×p矩阵，它们的乘积AB是一个m×p矩阵，它的一个元素其中 1 ≤ i ≤ m, 1 ≤ j ≤ p。

<a href="http://taop.marchtea.com/images/41~42/42.1.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.1.png" alt="" /></a>

值得一提的是，矩阵乘法满足结合律和分配率，但并不满足交换律，如下图所示的这个例子，两个矩阵交换相乘后，结果变了：

<a href="http://taop.marchtea.com/images/41~42/42.1-2.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.1-2.png" alt="" /></a>

下面咱们来具体解决这个矩阵相乘的问题。
<h3><a id="user-content-解法一暴力解法" class="anchor" href="http://taop.marchtea.com/02.08.html#%E8%A7%A3%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"></a>解法一、暴力解法</h3>
其实，通过前面的分析，我们已经很明显的看出，两个具有相同维数的矩阵相乘，其复杂度为O(n^3)，参考代码如下：
<pre class="lang:c++ decode:true ">void MulMatrix_one(int **a,int **b,int **c)
{
    for(int i=0; i&lt;size; ++i)
    {
        for(int j=0; j&lt;size; ++j)
        {
            c[i][j]=0;
            for(int k=0; k&lt;size; ++k)
            {
                c[i][j]+=a[i][k]*b[k][j];
            }
        }
    }
}</pre>
&nbsp;
<div class="highlight highlight-cpp"></div>
<h3><a id="user-content-解法二strassen算法" class="anchor" href="http://taop.marchtea.com/02.08.html#%E8%A7%A3%E6%B3%95%E4%BA%8Cstrassen%E7%AE%97%E6%B3%95"></a>解法二、Strassen算法</h3>
在解法一中，我们用了3个for循环搞定矩阵乘法，但当两个矩阵的维度变得很大时，O（n^3）的时间复杂度将会变得很大，于是，我们需要找到一种更优的解法。

一般说来，当数据量一大时，我们往往会把大的数据分割成小的数据，各个分别处理。遵此思路，如果丢给我们一个很大的两个矩阵呢，是否可以考虑分治的方法循序渐进处理各个小矩阵的相乘，因为我们知道一个矩阵是可以分成更多小的矩阵的。

如下图，当给定一个两个二维矩阵A B时：

<a href="http://taop.marchtea.com/images/41~42/42.2.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.2.png" alt="" /></a>

这两个矩阵A B相乘时，我们发现在相乘的过程中，有8次乘法运算，4次加法运算：

<a href="http://taop.marchtea.com/images/41~42/42.3.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.3.png" alt="" /></a>

矩阵乘法的复杂度主要就是体现在相乘上，而多一两次的加法并不会让复杂度上升太多。故此，我们思考，是否可以让矩阵乘法的运算过程中乘法的运算次数减少，从而达到降低矩阵乘法的复杂度呢？答案是肯定的。

1969年，德国的一位数学家Strassen证明O(N^3)的解法并不是矩阵乘法的最优算法，他做了一系列工作使得最终的时间复杂度降低到了O(n^2.80)。

他是怎么做到的呢？还是用上文A B两个矩阵相乘的例子，他定义了7个变量：

<a href="http://taop.marchtea.com/images/41~42/42.4.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.4.png" alt="" /></a>

如此，Strassen算法的流程如下：
<ul>
	<li>两个矩阵A B相乘时，将A, B, C分成相等大小的方块矩阵：</li>
</ul>
<a href="http://taop.marchtea.com/images/41~42/42.5.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.5.png" alt="" /></a>
<ul>
	<li>可以看出C是这么得来的：</li>
</ul>
<a href="http://taop.marchtea.com/images/41~42/42.6.jpeg" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.6.jpeg" alt="" /></a>
<ul>
	<li>现在定义7个新矩阵（ <em>读者可以思考下，这7个新矩阵是如何想到的 </em>）：</li>
</ul>
<a href="http://taop.marchtea.com/images/41~42/42.7.jpeg" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.7.jpeg" alt="" /></a>
<ul>
	<li>而最后的结果矩阵C 可以通过组合上述7个新矩阵得到：</li>
</ul>
<a href="http://taop.marchtea.com/images/41~42/42.8.jpeg" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.8.jpeg" alt="" /></a>

表面上看，Strassen算法仅仅比通用矩阵相乘算法好一点，因为通用矩阵相乘算法时间复杂度是 <a href="https://camo.githubusercontent.com/aeef0df9107adbd6463c9e4fe6748f7815dec922/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537426e253545333d6e2535452537426c6f675f3238253744253744" target="_blank"><img src="https://camo.githubusercontent.com/aeef0df9107adbd6463c9e4fe6748f7815dec922/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537426e253545333d6e2535452537426c6f675f3238253744253744" alt="equation" data-canonical-src="http://latex.codecogs.com/gif.latex?%7Bn%5E3=n%5E%7Blog_28%7D%7D" /> </a>，而Strassen算法复杂度只是 <a href="https://camo.githubusercontent.com/f7e265e7402a954d8853d9724b203e0f648a12bf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e2535452537426c6f675f3237253744293d4f286e253545253742322e38303725374429253744" target="_blank"><img src="https://camo.githubusercontent.com/f7e265e7402a954d8853d9724b203e0f648a12bf/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e2535452537426c6f675f3237253744293d4f286e253545253742322e38303725374429253744" alt="equation" data-canonical-src="http://latex.codecogs.com/gif.latex?%7BO(n%5E%7Blog_27%7D)=O(n%5E%7B2.807%7D)%7D" /> </a>。但随着n的变大，比如当n &gt;&gt; 100时，Strassen算法是比通用矩阵相乘算法变得更有效率。

如下图所示：

<a href="http://taop.marchtea.com/images/41~42/42.9.png" target="_blank"><img src="http://taop.marchtea.com/images/41~42/42.9.png" alt="" /></a>

根据wikipedia上的介绍，后来，Coppersmith–Winograd 算法把 N* N大小的矩阵乘法的时间复杂度降低到了： <a href="https://camo.githubusercontent.com/3828207037dbef5a343930907319c428337e9443/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e33373534373725374429253744" target="_blank"><img src="https://camo.githubusercontent.com/3828207037dbef5a343930907319c428337e9443/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e33373534373725374429253744" alt="equation" data-canonical-src="http://latex.codecogs.com/gif.latex?%7BO(n%5E%7B2.375477%7D)%7D" /> </a>，而2010年，Andrew Stothers再度把复杂度降低到了 <a href="https://camo.githubusercontent.com/b4ca1c880f8008d0063ab91cd95d8271dd5846e1/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e3337333625374429253744" target="_blank"><img src="https://camo.githubusercontent.com/b4ca1c880f8008d0063ab91cd95d8271dd5846e1/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e3337333625374429253744" alt="equation" data-canonical-src="http://latex.codecogs.com/gif.latex?%7BO(n%5E%7B2.3736%7D)%7D" /> </a>，一年后的2011年，Virginia Williams把复杂度最终定格为： <a href="https://camo.githubusercontent.com/9e7e3d9b8139728ee592e2b6dc0f3ed69605b6d0/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e3337323725374429253744" target="_blank"><img src="https://camo.githubusercontent.com/9e7e3d9b8139728ee592e2b6dc0f3ed69605b6d0/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2537424f286e253545253742322e3337323725374429253744" alt="equation" data-canonical-src="http://latex.codecogs.com/gif.latex?%7BO(n%5E%7B2.3727%7D)%7D" /> </a>。

转载：<a href="http://taop.marchtea.com/02.08.html" target="_blank">http://taop.marchtea.com/02.08.html</a>

</article>
<div id="nav"></div>
</div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>275</wp:post_id>
		<wp:post_date><![CDATA[2016-02-09 16:36:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-02-09 08:36:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%9f%a9%e9%98%b5%e7%9b%b8%e4%b9%98%e7%9a%84%e7%ae%97%e6%b3%95%e7%a0%94%e7%a9%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm-programing"><![CDATA[ACM算法编程]]></category>
		<category domain="category" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[23]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>《The Big Bang Theory/生活大爆炸 》8段经典美剧</title>
		<link>http://acmerbar.com/278.html</link>
		<pubDate>Sun, 21 Feb 2016 06:04:59 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=278</guid>
		<description></description>
		<content:encoded><![CDATA[<b>1.Sheldom 的自信</b>
<blockquote>I'm a physicist. I have a working knowledge of the entire universe and everything it contains.

--But,Sheldom,without your insight and leadship,this entire enterprise will surely fail.

--You're right,of course.</blockquote>
我是一个物理学家（physicist），上知天文下知地理,整一个宇宙里包含的奥妙我都知道。

--但是，sheldom，没有你的观点和领导气质，整个事业将会失败。

--那是当然！

<b>2.Sheldom 的座位</b>
<blockquote>In the winter, that seat is close enough to the radiator to remain warm,and yet not so close as to cause perspiration;int the summer,it's directly in the path of a cross-breeze created by opening windows there and there.It faces the television at any angle that neither direct.thus discouraging coversation,nor so far wide as to create a parallax distortion.I could go on,but I think I've made my point.</blockquote>
在冬天，这个座位靠近暖气从而可以保持温暖，在夏天，也不是靠的那么近从而避免出汗，更是一个通风口。看电视的时候，既不会阻碍谈话，也不会导致失帧，对于这个座位的好处我还可以继续说，但是我觉得够了。

<b>3.石头剪刀布</b>
<blockquote>Scissors cuts paper; paper covers rock; rock crushes lizard;lizard poisons Spock;Spock smashes scissors;scissors decapitate lizard;lizard eats paper;paper disproves Spock;Spock evaporates rock;rock crushes lizards;</blockquote>
decapitate vt.斩首，解雇。

剪刀削减纸;纸覆盖岩石,石头砸碎蜥蜴,蜥蜴毒药Spock;Spock打碎剪刀,剪刀斩首蜥蜴,蜥蜴吃了纸,纸反驳了Spock,Spock蒸发岩石,岩石粉碎蜥蜴;

<b>4.Sheldom 和 Stephen William Hawking（斯蒂芬·威廉·霍金）的对话</b>
<blockquote>--Do you like brain teasers?

--Oh,I love brain teasers.

--What does Sheldom Cooper and a black hole have in common?

--They both suck!</blockquote>
--你喜欢脑筋急转弯吗？

- -噢，我喜欢脑筋急转弯。

- 那么谢尔顿·库珀和黑洞有什么共同之处？

--他们都很烂

<b>5 .</b>
<blockquote>A Chinese research team ran a test and the results were extremely promising.They called it the greatest thing since the Communist party,althougth I'm pretty sure that Communist party made them say that.I like China.They know how to keep people in line。</blockquote>
一个来自中国的团队做了一个实验，实验的结果非常有前景，他们称发现了自从中国共产党执政以来最伟大的东西，尽管我很确信是共产党让他们说的，我喜欢中国，他们知道如何控制人们。

<b>6.Lenard 和Penny 在婚礼上</b>
<blockquote>Penny,we are made of particles that have existed since the moment the universe begin,I would like to think those atoms traveled 14 billion years through time and space to create us, so that we could be together and make each other whole.</blockquote>
Penny,我们都是由自从宇宙开始诞生之后的粒子组成，我必须要说这些元素历经14亿年的时间和空间的穿越才创造出了我们,因此我们可以在一起并且互相弥补对方。

<b>7.Howard 和 Bernadette 在婚礼上</b>
<blockquote>Until I met you,I couldn't  imagine spending my life with just one person,And now,I couldn't imagine spending one day of it without you.</blockquote>
在我认识你之前，我无法想象如何只和一个人共度余生，但是现在我无法想象在没有你的一天里我该如何生活。

<b>8.谈girlfriend</b>
<blockquote>With the understanding that nothing changes whatsoever,physical or otherwise,I would not object to us longer characterizing you as "not my girlfriend" (quadruple negative!)</blockquote>
没有什么变化，物理或以其他方式的理解，我也不会反对我们不再描述你作为“不是我的女朋友”（四重否定！）--“你可以成为我的女朋友吗？”]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>278</wp:post_id>
		<wp:post_date><![CDATA[2016-02-21 14:04:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-02-21 06:04:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e3%80%8athe-big-bang-theory%e7%94%9f%e6%b4%bb%e5%a4%a7%e7%88%86%e7%82%b8-%e3%80%8b8%e6%ae%b5%e7%bb%8f%e5%85%b8%e7%be%8e%e5%89%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e8%8b%b1%e8%af%ad%e5%ad%a6%e4%b9%a0"><![CDATA[英语学习]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[13]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[24]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[zengda]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[admin@zengda.xin]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.zengda.xin/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[103.230.120.4]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-04-06 10:45:17]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-04-06 02:45:17]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[不错，不错，看看了！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1459910717.8517720699310302734375;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[易路营销软件]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[219329@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.219329.zzkkaa.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[112.246.70.129]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-04-25 09:47:58]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-04-25 01:47:58]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[来看看你，祝好！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1461548879.4196031093597412109375;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>25</wp:comment_id>
			<wp:comment_author><![CDATA[2409318949]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2409318949@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.2409318949.zzmmaa.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[27.206.125.4]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-06-02 09:48:03]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-06-02 01:48:03]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[看看您的博客！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1464832083.3005759716033935546875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[2952858635]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2952858635@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.2952858635.mmxxaa.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[27.206.51.126]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-06-17 08:15:12]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-06-17 00:15:12]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[年中快乐！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1466122512.8275039196014404296875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>34</wp:comment_id>
			<wp:comment_author><![CDATA[增达信购]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[674289@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.674289.zzwwaa.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[112.246.68.12]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-06-28 14:29:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-06-28 06:29:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[虚心学习！！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1467095369.282207965850830078125;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>35</wp:comment_id>
			<wp:comment_author><![CDATA[蒂欧娜]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[504730@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.504730.diouna.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[112.246.68.12]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-06-30 10:46:13]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-06-30 02:46:13]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我就是随便看看！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1467254773.2264740467071533203125;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>83</wp:comment_id>
			<wp:comment_author><![CDATA[QQ541100304]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[541100304@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.541100304.diouna.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[27.206.55.244]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-08-11 15:58:06]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-08-11 07:58:06]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博客不错，嘎嘎！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1470902287.7781200408935546875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>#2017新年计划#</title>
		<link>http://acmerbar.com/283.html</link>
		<pubDate>Tue, 24 Jan 2017 02:55:47 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=283</guid>
		<description></description>
		<content:encoded><![CDATA[【1】重新部署一下个人博客，wordpress感觉好臃肿，用用typecho或Hexo。

【2】弄好OJV2.0的前端：登入注册，各种导航栏，简单的和后台数据交互。

【3】看完《疯狂的程序员》，《进击的局座悄悄话》，《Pyhon开发实战》，《离散数学》，《中国少了一味药》，《30天读懂经济学人》，至少六本。。。

【4】锻炼身体：每周而到三次小伙伴打篮球，每晚睡觉前30+标准俯卧撑。

【5】100days百词斩读完4本英文名著（已经读完一本（The Little Prince））。

【6】每周刷2-3道算法题，不刷题脑子都变得越来越笨了~~。

【7】呵呵，最重要的早起早睡！！！早起早睡！！！早起早睡！！！，重要的事说三遍，把2016一年考研的按时起床按时睡觉的我给找回来！！！

就酱~~待补~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>283</wp:post_id>
		<wp:post_date><![CDATA[2017-01-24 10:55:47]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-01-24 02:55:47]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[2017%e6%96%b0%e5%b9%b4%e8%ae%a1%e5%88%92]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<category domain="category" nicename="%e7%94%9f%e6%b4%bb%e9%9a%8f%e7%ac%94"><![CDATA[生活随笔]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[bot_views]]></wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[15]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>201</wp:comment_id>
			<wp:comment_author><![CDATA[九州套图]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[1517375298@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.3i4.com.cn/?ic=fiends123</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[123.129.50.4]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-02-06 12:41:32]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-02-06 04:41:32]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[来看看咯~]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1486356092.447022914886474609375;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>239</wp:comment_id>
			<wp:comment_author><![CDATA[增达网QQ-33092290]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[33092290@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.cxb.zengda.xin/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[142.54.173.194]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-03-20 16:19:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-03-20 08:19:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[真是时光荏苒！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1489997975.45187091827392578125;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>593</wp:comment_id>
			<wp:comment_author><![CDATA[增达网]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[2543697027@qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.kk8888kk.zengda.xin/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[39.81.106.237]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2017-05-14 16:24:20]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2017-05-14 08:24:20]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[受教了！呵呵！]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_result]]></wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key><![CDATA[akismet_history]]></wp:meta_key>
				<wp:meta_value><![CDATA[a:2:{s:4:"time";d:1494750261.0213420391082763671875;s:5:"event";s:9:"check-ham";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>个人微信公众号</title>
		<link>http://acmerbar.com/287.html</link>
		<pubDate>Tue, 04 Jul 2017 00:49:10 +0000</pubDate>
		<dc:creator><![CDATA[jiabei]]></dc:creator>
		<guid isPermaLink="false">http://acmerbar.com/?p=287</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://acmerbar.com/wp-content/uploads/2017/07/qrcode_for_gh_cf44650afa81_430.jpg"><img class="aligncenter size-medium wp-image-288" src="http://acmerbar.com/wp-content/uploads/2017/07/qrcode_for_gh_cf44650afa81_430-300x300.jpg" alt="qrcode_for_gh_cf44650afa81_430" width="300" height="300" /></a>

【微信号】：加贝木苇的理想国

【内容】 ：学习，读书，算法交流。

欢迎关注，谢谢！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>287</wp:post_id>
		<wp:post_date><![CDATA[2017-07-04 08:49:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2017-07-04 00:49:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%aa%e4%ba%ba%e5%be%ae%e4%bf%a1%e5%85%ac%e4%bc%97%e5%8f%b7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study-notes-summary"><![CDATA[学习笔记/总结]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[views]]></wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
